{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This website provides code documentation, including tutorials and API references, for the CLT Toolkit. In addition, this website provides code and mathematical formulation documentation for MetroFluSim.</p> <p>The CLT Toolkit is a modular Python codebase for scalable compartmental models of respiratory virus transmission in a city. This effort is spearheaded by the Meyers Lab and epiENGAGE center under a CDC-funded effort to provide high quality technical tools for modeling. This toolkit takes care of fundamental simulation mechanics, allowing users to efficiently build and adapt multiple stochastic models without reimplementing common operations from scratch. This toolkit streamlines the construction of granular metapopulation models -- heterogenous regions can be easily modeled as distinct locations or subpopulations with age and risk groups, all integrated within a single metapopulation framework. </p> <p>The toolkit is used to create MetroFluSim, a high fidelity city-level influenza model that captures population-level immunity dynamics. The Meyers Lab at UT Austin is working directly with public health officials in the Texas cities of Austin, Dallas, El Paso, and Houston to create specific implementations of the <code>MetroFluSim</code> model tailored to each city.</p> <pre><code>flowchart TD\n    A[CLT Toolkit] --&gt;| create subclasses to specify compartments and structure | C{MetroFluSim}\n    C --&gt; | Austin-specific inputs, parameters, populations | D[Austin]\n    C --&gt; | ... | F[Dallas]\n    C --&gt; | ... | G[El Paso] \n    C --&gt; | Houston-specific inputs, parameters, populations | E[Houston]\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>The CLT Toolkit is written in Python 3.11.0.</p> <p>To download, build, and run the latest code release, run the following in Terminal: <pre><code>git clone https://github.com/LP-relaxation/CLT_BaseModel.git\n</code></pre></p> <p>In the package folder (<code>pyproject.toml</code> should be in this directory), run the following in Terminal: <pre><code>pip install -e .\n</code></pre> to install the package in editable mode. Note that some users may have to use <code>pip3 install -e .</code>, depending on their configuration.</p> <p>Packages required: <pre><code>numpy==1.24.3\npandas==1.5.3\npytest==8.3.3\npytorch==2.3.1\nsciris==3.2.0\n</code></pre></p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>We recommend </p> <ul> <li><code>flu_instances/examples/flu_demo.ipynb</code> for a Jupyter notebook tutorial on building subpopulation and metapopulation models, running random parameter sampling, and organizing large-scale output in experiments.</li> <li><code>flu_instances/examples/torch_calibration_demo.ipynb</code> for a Jupyter notebook tutorial on using <code>pytorch</code> autodifferentiate to solve least-squares on a deterministic functional implementation of the flu model to calibrate unknown parameters.</li> <li><code>SIHR_core/SIHR_components.py</code> for a thoroughly commented file explaining how to use the CLT Toolkit to create a customized model. </li> </ul>"},{"location":"#code-structure","title":"Code Structure","text":"Folder Description <code>clt_toolkit</code> CLT Toolkit abstract \"base\" classes. These provide reusable functionality for compartmental models, so users can run models without reimplementing simulation logic from scratch. <code>flu_core</code> Subclasses of <code>clt_base</code> that designate the compartments and structure of MetroFluSim, without specifying concrete inputs, parameters, or populations. <code>flu_instances</code> Stores data that specifies concrete inputs, parameters, and populations used to construct particular instances of <code>MetroFluSim</code> models (i.e. for particular cities). Contains scripts to simulate and calibrate these instances. <code>SIHR_core</code> Subclasses of <code>clt_base</code> that designate the compartments and structure of a simple S-I-H-R model, without specifying concrete inputs, parameters, or populations. Used as a tutorial example. <code>SIHR_instances</code> Stores data that specifies concrete inputs, parameters, and populations used to construct particular instances of the demo SIHR model in <code>SIHR_core</code>. <code>tests</code> \"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization.\" -- Gerald Weinberg"},{"location":"#toolkit-structure","title":"Toolkit Structure","text":"Folder File Description <code>clt_toolkit/</code> <code>base_components</code> Base classes for fundamental simulation objects, such as subpopulation models, metapopulation models, compartments, and transition variables that manage flow between compartments. <code>base_data_structures</code> Base dataclasses for storing compartment population values, epidemiological parameters, and simulation settings. <code>experiments</code> Tools for running many simulation replications of a model and managing the output. Can handle random sampling of parameters. <code>input_parsers</code> Helper functions for streamlining input reading and validation. <code>plotting</code> Plotting functions. <code>utils</code> Utility functions for convenience."},{"location":"#flu-core-structure","title":"Flu Core Structure","text":"<p>Subclasses for MetroFluSim.</p> Folder File Description <code>flu_core/</code> <code>flu_components</code> Subclasses of <code>clt_base</code> that define the compartments and corresponding logic of MetroFluSim. <code>flu_data_structures</code> Subclasses of dataclasses in <code>base_data_structures</code> that specify the exact fields (compartments, parameters, etc...) needed for MetroFluSim. <code>flu_torch_det_components</code> Deterministic, functional (non-object oriented) version of MetroFluSim that is autodifferentiable with PyTorch and optimized for performance. <code>flu_travel_functions</code> Computes exposure intensity due to local transmission within a subpopulation as well as travel between subpopulations."},{"location":"#flu-model-instances-structure","title":"Flu Model Instances Structure","text":"<p>Code for specific instances of the MetroFluSim model (e.g. for a specific city, with specific inputs, parameters, and populations).  </p> Folder Folder Description <code>flu_instances/</code> <code>calibration_research_input_files/</code> Input files for synthetic flu model instances used to evaluate calibration methods. <code>derived_inputs_computations/</code> Computations generating derived inputs (e.g. age-specific contact matrices). <code>examples/</code> Demo scripts showcasing CLT Toolkit and MetroFluSim functionality, including guides for calibration via optimization with automatic differentiation. <code>texas_flu_hosp_rate_20232024/</code> Publicly available Texas hospitalization data from 2023-2024 flu season. <code>texas_input_files/</code> Most up-to-date parameter values, derived from recent literature or within-host modeling. <p>Updated 08/14/2025. Toolkit and documentation are created by Linda Pei (\"LP\"), with feedback from R\u00e9my Pasco, Susan Ptak, Emily Javan, and other Meyers Lab members, and with supervision from Dave Morton and Lauren Meyers. Special thanks to Cary Murray for generous guidance on software engineering design. Special credit to Shuotao \"Sonny\" Diao for his ideas about updating compartments analogously to pushing flow on a graph and creating simulation logic that works for arbitrarily many compartments and transition variables. test</p>"},{"location":"flu_components_reference/","title":"Flu Core API Reference","text":"<p>Docstrings and references for <code>flu_core</code> module.</p>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.base_path","title":"<code>base_path = clt.utils.PROJECT_ROOT / 'flu_instances' / 'texas_input_files'</code>  <code>module-attribute</code>","text":""},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AbsoluteHumidity","title":"<code>AbsoluteHumidity</code>","text":"<p>               Bases: <code>Schedule</code></p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class AbsoluteHumidity(clt.Schedule):\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                must have columns \"date\" and \"absolute_humidity\" --\n                \"date\" entries must correspond to consecutive calendar days\n                and must either be strings with `\"YYYY-MM-DD\"` format or\n                `datetime.date` objects -- \"value\" entries correspond to\n                absolute humidity on those days. Identical to\n                `FluSubpopSchedules` field of same name.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self, params, current_date: datetime.date) -&gt; None:\n        self.current_val = self.timeseries_df.loc[\n            self.timeseries_df[\"date\"] == current_date, \"absolute_humidity\"].values[0]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AbsoluteHumidity.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: pd.DataFrame = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>must have columns \"date\" and \"absolute_humidity\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to absolute humidity on those days. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <code>None</code> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: pd.DataFrame = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            must have columns \"date\" and \"absolute_humidity\" --\n            \"date\" entries must correspond to consecutive calendar days\n            and must either be strings with `\"YYYY-MM-DD\"` format or\n            `datetime.date` objects -- \"value\" entries correspond to\n            absolute humidity on those days. Identical to\n            `FluSubpopSchedules` field of same name.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AsympToRecovered","title":"<code>AsympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IA\" to \"R\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class AsympToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IA\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.IA_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AsympToRecovered.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.IA_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.BetaReduce","title":"<code>BetaReduce</code>","text":"<p>               Bases: <code>DynamicVal</code></p> <p>\"Toy\" function representing staged-alert policy     that reduces transmission by 50% when more than 5%     of the total population is infected. Note: the     numbers are completely made up :) The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"     behavior where the staged-alert policy gets triggered     one day and then is off the next, and then is on the     day after, and so on... but as the name suggests,     it IS permanent. TODO: replace with realistic function.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class BetaReduce(clt.DynamicVal):\n    \"\"\"\n    \"Toy\" function representing staged-alert policy\n        that reduces transmission by 50% when more than 5%\n        of the total population is infected. Note: the\n        numbers are completely made up :)\n    The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"\n        behavior where the staged-alert policy gets triggered\n        one day and then is off the next, and then is on the\n        day after, and so on... but as the name suggests,\n        it IS permanent.\n    TODO: replace with realistic function.\n    \"\"\"\n\n    def __init__(self, init_val, is_enabled):\n        super().__init__(init_val, is_enabled)\n        self.permanent_lockdown = False\n\n    def update_current_val(self, state, params):\n        if np.sum(state.IS) / np.sum(params.total_pop_age_risk) &gt; 0.05:\n            self.current_val = .5\n            self.permanent_lockdown = True\n        else:\n            if not self.permanent_lockdown:\n                self.current_val = 0.0\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.DailyVaccines","title":"<code>DailyVaccines</code>","text":"<p>               Bases: <code>Schedule</code></p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class DailyVaccines(clt.Schedule):\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n                correspond to consecutive calendar days and must either\n                be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n                objects -- \"value\" entries correspond to historical\n                number vaccinated on those days. Identical to\n                `FluSubpopSchedules` field of same name.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self, params, current_date: datetime.date) -&gt; None:\n        self.current_val = self.timeseries_df.loc[\n            self.timeseries_df[\"date\"] == current_date, \"daily_vaccines\"].values[0]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.DailyVaccines.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: pd.DataFrame = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>must have \"date\" and \"daily_vaccines\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to historical number vaccinated on those days. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <code>None</code> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: pd.DataFrame = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n            correspond to consecutive calendar days and must either\n            be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n            objects -- \"value\" entries correspond to historical\n            number vaccinated on those days. Identical to\n            `FluSubpopSchedules` field of same name.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToAsymp","title":"<code>ExposedToAsymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IA\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToAsymp instance forms a TransitionVariableGroup with a corresponding ExposedToPresymp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class ExposedToAsymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IA\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToAsymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToPresymp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToAsymp.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.E_to_I_rate * params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToPresymp","title":"<code>ExposedToPresymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IP\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToPresymp instance forms a TransitionVariableGroup with a corresponding ExposedToAsymp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class ExposedToPresymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IP\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToPresymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToAsymp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * (1 - params.E_to_IA_prop))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToPresymp.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.E_to_I_rate * (1 - params.E_to_IA_prop))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluContactMatrix","title":"<code>FluContactMatrix</code>","text":"<p>               Bases: <code>Schedule</code></p> <p>Flu contact matrix.</p> <p>Attributes:</p> Name Type Description <code>timeseries_df</code> <code>DataFrame</code> <p>must have columns \"date\", \"is_school_day\", and \"is_work_day\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> object and \"is_school_day\" and \"is_work_day\" entries are Booleans indicating if that date is a school day or work day. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluContactMatrix(clt.Schedule):\n    \"\"\"\n    Flu contact matrix.\n\n    Attributes:\n        timeseries_df (pd.DataFrame):\n            must have columns \"date\", \"is_school_day\", and \"is_work_day\"\n            -- \"date\" entries must correspond to consecutive calendar\n            days and must either be strings with `\"YYYY-MM-DD\"` format\n            or `datetime.date` object and \"is_school_day\" and\n            \"is_work_day\" entries are Booleans indicating if that date is\n            a school day or work day. Identical to `FluSubpopSchedules` field\n            of same name.\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self,\n                           subpop_params: FluSubpopParams,\n                           current_date: datetime.date) -&gt; None:\n\n        df = self.timeseries_df\n\n        try:\n            current_row = df[df[\"date\"] == current_date].iloc[0]\n            self.current_val = subpop_params.total_contact_matrix - \\\n                               (1 - current_row[\"is_school_day\"]) * subpop_params.school_contact_matrix - \\\n                               (1 - current_row[\"is_work_day\"]) * subpop_params.work_contact_matrix\n        except IndexError:\n            # print(f\"Error: {current_date} is not in `timeseries_df`. Using total contact matrix.\")\n            self.current_val = subpop_params.total_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopParamsTensors","title":"<code>FluFullMetapopParamsTensors</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FluTravelParamsTensors</code></p> <p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from parameters on each location/subpopulation model, as well as from the metapopulation's associated <code>FluMixingParams</code> instance). Note that in contrast to <code>FluTravelParamsTensors</code>, ALL fields in <code>FluSubpopParams</code> are included -- this is for running the simulation via torch.</p> <p>Attributes:</p> Name Type Description <code>num_locations</code> <code>(Tensor, 0 - dimensional)</code> <p>number of locations (subpopulations) in the metapopulation model and therefore the travel model.</p> <code>travel_proportions</code> <code>Tensor</code> <p>L x L array, where L is the number of locations or subpopulations, where element i,j corresponds to the proportion of the population in location i who travels to location j (on average).</p> <p>See <code>FluSubpopParams</code> docstring for other attributes. Other fields are analogous except they are size (L, A, R) tensors or size 0 tensors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopParamsTensors(FluTravelParamsTensors):\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays that\n    contain data across all subpopulations (collected from parameters\n    on each location/subpopulation model, as well as from the\n    metapopulation's associated `FluMixingParams` instance).\n    Note that in contrast to `FluTravelParamsTensors`,\n    ALL fields in `FluSubpopParams` are included --\n    this is for running the simulation via torch.\n\n    Attributes:\n        num_locations (torch.Tensor, 0-dimensional):\n            number of locations (subpopulations) in the\n            metapopulation model and therefore the travel\n            model.\n        travel_proportions (torch.Tensor):\n            L x L array, where L is the number of locations\n            or subpopulations, where element i,j corresponds\n            to the proportion of the population in location i\n            who travels to location j (on average).\n\n    See `FluSubpopParams` docstring for other attributes.\n    Other fields are analogous except they are size (L, A, R)\n    tensors or size 0 tensors.\n    \"\"\"\n\n    beta_baseline: Optional[torch.Tensor] = None\n    total_pop_age_risk: Optional[torch.Tensor] = None\n    humidity_impact: Optional[torch.Tensor] = None\n\n    inf_induced_saturation: Optional[torch.Tensor] = None\n    inf_induced_immune_wane: Optional[torch.Tensor] = None\n    vax_induced_saturation: Optional[torch.Tensor] = None\n    vax_induced_immune_wane: Optional[torch.Tensor] = None\n    inf_induced_inf_risk_reduce: Optional[torch.Tensor] = None\n    inf_induced_hosp_risk_reduce: Optional[torch.Tensor] = None\n    inf_induced_death_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_inf_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_hosp_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_death_risk_reduce: Optional[torch.Tensor] = None\n\n    R_to_S_rate: Optional[torch.Tensor] = None\n    E_to_I_rate: Optional[torch.Tensor] = None\n    IP_to_IS_rate: Optional[torch.Tensor] = None\n    IS_to_R_rate: Optional[torch.Tensor] = None\n    IA_to_R_rate: Optional[torch.Tensor] = None\n    IS_to_H_rate: Optional[torch.Tensor] = None\n    H_to_R_rate: Optional[torch.Tensor] = None\n    H_to_D_rate: Optional[torch.Tensor] = None\n    E_to_IA_prop: Optional[torch.Tensor] = None\n\n    IS_to_H_adjusted_prop: Optional[torch.Tensor] = None\n    H_to_D_adjusted_prop: Optional[torch.Tensor] = None\n\n    IP_relative_inf: Optional[torch.Tensor] = None\n    IA_relative_inf: Optional[torch.Tensor] = None\n\n    relative_suscept: Optional[torch.Tensor] = None\n    mobility_modifier: Optional[torch.Tensor] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopScheduleTensors","title":"<code>FluFullMetapopScheduleTensors</code>  <code>dataclass</code>","text":"Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopScheduleTensors:\n\n    absolute_humidity: Optional[list[torch.tensor]] = None\n    is_school_day: Optional[list[torch.tensor]] = None\n    is_work_day: Optional[list[torch.tensor]] = None\n    daily_vaccines: Optional[list[torch.tensor]] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopStateTensors","title":"<code>FluFullMetapopStateTensors</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FluTravelStateTensors</code></p> <p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from each location/subpopulation model). In contrast to <code>FluTravelStateTensors</code>, ALL fields in <code>FluSubpopState</code> are included -- this is for running the simulation via torch.</p> <p>Attributes:</p> Name Type Description <code>flu_contact_matrix</code> <code>torch.Tensor of nonnegative integers</code> <p>contact matrix for location-age-risk groups -- the lth element holds current_val of <code>FluContactMatrix</code> <code>Schedule</code> for subpopulation l -- this value is a combination of the total contact matrix, the work contact matrix, and the school contact matrix (and the value is adjusted depending on whether the date is a work or school day)</p> <code>init_vals</code> <code>dict</code> <p>dictionary of torch.Tensor instances, where keys correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values correspond to their initial values for location-age-risk groups.</p> <p>See <code>FluSubpopState</code> and <code>FluTravelStateTensors</code> for other     attributes -- other attributes here correspond to     <code>FluSubpopState</code>, but are size (L, A, R) tensors for     location-age-risk or size 0 tensors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopStateTensors(FluTravelStateTensors):\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays that\n    contain data across all subpopulations (collected from each\n    location/subpopulation model). In contrast to `FluTravelStateTensors`,\n    ALL fields in `FluSubpopState` are included -- this is\n    for running the simulation via torch.\n\n    Attributes:\n        flu_contact_matrix (torch.Tensor of nonnegative integers):\n            contact matrix for location-age-risk groups -- the\n            lth element holds current_val of `FluContactMatrix`\n            `Schedule` for subpopulation l -- this value is a\n            combination of the total contact matrix, the\n            work contact matrix, and the school contact matrix\n            (and the value is adjusted depending on whether\n            the date is a work or school day)\n        init_vals (dict):\n            dictionary of torch.Tensor instances, where keys\n            correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values\n            correspond to their initial values for location-age-risk\n            groups.\n\n    See `FluSubpopState` and `FluTravelStateTensors` for other\n        attributes -- other attributes here correspond to\n        `FluSubpopState`, but are size (L, A, R) tensors for\n        location-age-risk or size 0 tensors.\n    \"\"\"\n\n    # `IP`, `IS`, `IA`, `H`, `flu_contact_matrix` already in\n    #   parent class\n    # Same with `init_vals`\n\n    S: Optional[torch.Tensor] = None\n    E: Optional[torch.Tensor] = None\n    R: Optional[torch.Tensor] = None\n    D: Optional[torch.Tensor] = None\n\n    M: Optional[torch.Tensor] = None\n    MV: Optional[torch.Tensor] = None\n\n    absolute_humidity: Optional[float] = None\n    daily_vaccines: Optional[torch.Tensor] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel","title":"<code>FluMetapopModel</code>","text":"<p>               Bases: <code>MetapopModel</code>, <code>ABC</code></p> <p>MetapopModel-derived class specific to flu model.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluMetapopModel(clt.MetapopModel, ABC):\n    \"\"\"\n    MetapopModel-derived class specific to flu model.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_models: list[dict],\n                 mixing_params: FluMixingParams,\n                 name: str = \"\"):\n\n        super().__init__(subpop_models,\n                         mixing_params,\n                         name)\n\n        # Confirm validity and consistency of `FluMixingParams`\n        try:\n            num_locations = mixing_params.num_locations\n        except KeyError:\n            raise FluMetapopModelError(\"'mixing_params' must contain the key 'num_locations'. \\n\"\n                                       \"Please specify it before continuing.\")\n        if num_locations != len(subpop_models):\n            raise FluMetapopModelError(\"'num_locations' should equal the number of items in \\n\"\n                                       \"'subpop_models'. Please amend before continuing.\")\n\n        self.travel_state_tensors = FluTravelStateTensors()\n        self.update_travel_state_tensors()\n\n        # `FluMixingParams` info is stored on `FluTravelParamsTensors` --\n        # this order of operations below is important, because\n        # `mixing_params` attribute must be defined before `update_travel_params_tensors()`\n        # is called.\n        self.mixing_params = mixing_params\n        self.travel_params_tensors = FluTravelParamsTensors()\n        self.update_travel_params_tensors()\n\n        total_pop_LAR_tensor = self.compute_total_pop_LAR_tensor()\n\n        self.precomputed = FluPrecomputedTensors(total_pop_LAR_tensor,\n                                                 self.travel_params_tensors)\n\n        # Generally not used unless using torch version\n        self._full_metapop_params_tensors = None\n        self._full_metapop_state_tensors = None\n        self._full_metapop_schedule_tensors = None\n\n    def modify_subpop_params(self,\n                             subpop_name: str,\n                             updates_dict: dict):\n        \"\"\"\n        This method lets users safely modify a single subpopulation\n        parameters field; the metapopulation-wide tensors are updated\n        automatically afterward.\n\n        In a `FluMetapopModel`, subpopulation parameters are combined into\n        (L, A, R) tensors across L subpopulations.`FluSubpopParams` is a frozen\n        dataclass to avoid users naively changing parameter values and getting\n        undesirable results -- thus, `FluSubpopParams` on a subpopulation\n        model cannot be updated directly.\n\n        Parameters:\n            subpop_name (str):\n               Value must match the `name` attribute of one of the\n               `FluSubpopModel` instances contained in this metapopulation\n                model's `subpop_models` attribute.\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`.\n        \"\"\"\n\n        # Since `FluSubpopParams` is frozen, we return a new instance\n        #   with the reflected updates\n        self.subpop_models[subpop_name].params = clt.updated_dataclass(\n            self.subpop_models[subpop_name].params, updates_dict\n        )\n\n        self.update_travel_params_tensors()\n\n        # Adding this for extra safety in case the user does not\n        # call `get_flu_torch_inputs` for accessing the\n        # `FullMetapopParams` instance.\n\n        # If this attribute is not `None`, it means we are using\n        # the `torch` implementation, and we should update the\n        # corresponding `FullMetapopParams` instance with the new\n        # `FluMixingParams` values.\n        if self._full_metapop_params_tensors:\n            self.update_full_metapop_params_tensors()\n\n    def modify_mixing_params(self,\n                             updates_dict: dict):\n        \"\"\"\n        This method lets users safely modify flu mixing parameters;\n        the metapopulation-wide tensors are updated automatically afterward.\n        `FluMixingParams` is a frozen dataclass to avoid users\n        naively changing parameter values and getting undesirable results --\n        thus, `FluMixingParams` cannot be updated directly.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`. \n        \"\"\"\n\n        self.mixing_params = clt.updated_dataclass(self.mixing_params, updates_dict)\n        self.update_travel_params_tensors()\n\n        nonlocal_travel_prop = self.travel_params_tensors.travel_proportions.clone().fill_diagonal_(0.0)\n\n        self.precomputed.sum_residents_nonlocal_travel_prop = nonlocal_travel_prop.sum(dim=1)\n\n        # Adding this for extra safety in case the user does not\n        # call `get_flu_torch_inputs` for accessing the\n        # `FullMetapopParams` instance.\n\n        # If this attribute is not `None`, it means we are using\n        # the `torch` implementation, and we should update the\n        # corresponding `FullMetapopParams` instance with the new\n        # `FluMixingParams` values.\n        if self._full_metapop_params_tensors:\n            self.update_full_metapop_params_tensors()\n\n    def compute_total_pop_LAR_tensor(self) -&gt; torch.tensor:\n        \"\"\"\n        For each subpopulation, sum initial values of population\n        in each compartment for age-risk groups. Store all information\n        as tensor and return tensor.\n\n        Returns:\n        --------\n        torch.tensor of size (L, A, R):\n            Total population (across all compartments) for\n            location-age-risk (l, a, r).\n        \"\"\"\n\n        # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n        #   to preserve correct index order in tensors!\n        #   See `update_travel_params_tensors` for detailed note.\n        subpop_models_ordered = self._subpop_models_ordered\n\n        total_pop_LAR_tensor = torch.zeros(self.travel_params_tensors.num_locations,\n                                           self.travel_params_tensors.num_age_groups,\n                                           self.travel_params_tensors.num_risk_groups)\n\n        # All subpop models should have the same compartments' keys\n        for name in subpop_models_ordered[0].compartments.keys():\n\n            metapop_vals = []\n\n            for model in subpop_models_ordered.values():\n                compartment = getattr(model.compartments, name)\n                metapop_vals.append(compartment.current_val)\n\n            total_pop_LAR_tensor = total_pop_LAR_tensor + torch.tensor(np.asarray(metapop_vals))\n\n        return total_pop_LAR_tensor\n\n    def update_state_tensors(self,\n                             target: FluTravelStateTensors) -&gt; None:\n        \"\"\"\n        Update `target` instance in-place with current simulation\n        values. Each field of `target` corresponds to a field in\n        `FluSubpopState`, and contains either a tensor of size\n        (L, A, R) or a tensor of size (L), where (l, a, r) refers to\n        location-age-risk.\n        \"\"\"\n\n        # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n        #   to preserve correct index order in tensors!\n        #   See `update_travel_params_tensors` for detailed note.\n        subpop_models_ordered = self._subpop_models_ordered\n\n        for field in fields(target):\n\n            name = field.name\n\n            # FluTravelStateTensors has an attribute\n            #   that is a dictionary called `init_vals` --\n            #   disregard, as this only used to store\n            #   initial values for resetting, but is not\n            #   used in the travel model computation\n            if name == \"init_vals\":\n                continue\n\n            metapop_vals = []\n\n            for model in subpop_models_ordered.values():\n                current_val = getattr(model.state, name)\n                metapop_vals.append(current_val)\n\n            # Probably want to update this to be cleaner...\n            # `SubpopState` fields that correspond to `Schedule` instances\n            # have initial values of `None` -- but we cannot build a tensor\n            # with `None` values, so we convert values to 0s.\n            if any(v is None for v in metapop_vals):\n                setattr(target, name, torch.tensor(np.full(np.shape(metapop_vals), 0.0)))\n            else:\n                setattr(target, name, torch.tensor(np.asarray(metapop_vals)))\n\n            # Only fields corresponding to `Schedule` instances can be\n            # size (L) -- this is because the schedule value may be scalar for\n            # each subpopulation. Other fields should all be size (L, A, R). \n\n    def update_travel_state_tensors(self) -&gt; None:\n        \"\"\"\n        Update `travel_state_tensors` attribute in-place.\n        `FluTravelStateTensors` only has fields corresponding\n        to state variables relevant for the travel model.\n        Converts subpopulation-specific state to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        self.update_state_tensors(self.travel_state_tensors)\n\n    def update_full_metapop_state_tensors(self) -&gt; None:\n        \"\"\"\n        Update `_full_metapop_state_tensors` attribute in-place.\n        `FluFullMetapopStateTensors` has fields corresponding\n        to all state variables in the simulation.\n        Converts subpopulation-specific state to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        if self._full_metapop_state_tensors is None:\n            self._full_metapop_state_tensors = FluFullMetapopStateTensors()\n        self.update_state_tensors(self._full_metapop_state_tensors)\n\n    def update_params_tensors(self,\n                              target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors:\n        \"\"\"\n        Update `target` in-place. Converts subpopulation-specific\n        parameters to tensors of size (L, A, R) for location-age-risk,\n        except for `num_locations` and `travel_proportions`, which\n        have size 1 and (L, L) respectively.\n        \"\"\"\n\n        # USE THE ORDERED DICTIONARY HERE FOR SAFETY!\n        #   AGAIN, ORDER MATTERS BECAUSE ORDER DETERMINES\n        #   THE SUBPOPULATION INDEX IN THE METAPOPULATION\n        #   TENSOR!\n        subpop_models_ordered = self._subpop_models_ordered\n\n        # Subpop models should have the same A, R so grab\n        #   from the first subpop model\n        A = subpop_models_ordered[0].params.num_age_groups\n        R = subpop_models_ordered[0].params.num_risk_groups\n\n        for field in fields(target):\n\n            name = field.name\n\n            metapop_vals = []\n\n            if name == \"num_locations\" or name == \"travel_proportions\":\n                setattr(target, name, torch.tensor(getattr(self.mixing_params, name)))\n\n            else:\n                for model in subpop_models_ordered.values():\n                    metapop_vals.append(getattr(model.params, name))\n\n                # If all values are equal to each other, then\n                #   simply store the first value (since its value is common\n                #   across metapopulations)\n                first_val = metapop_vals[0]\n                if all(np.allclose(x, first_val) for x in metapop_vals):\n                    metapop_vals = first_val\n\n                # Converting list of arrays to tensors is slow --\n                #   better to convert to array first\n                if isinstance(metapop_vals, list):\n                    metapop_vals = np.asarray(metapop_vals)\n                    # metapop_vals = np.stack([clt.to_AR_array(x, A, R) for x in metapop_vals])\n\n                setattr(target, name, torch.tensor(metapop_vals))\n\n        # Convert all tensors to correct size!\n        target.standardize_shapes()\n\n    def update_travel_params_tensors(self) -&gt; None:\n        \"\"\"\n        Update `travel_params_tensors` attribute in-place.\n        `FluTravelParamsTensors` only has fields corresponding\n        to parameters relevant for the travel model.\n        Converts subpopulation-specific parameters to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        self.update_params_tensors(target=self.travel_params_tensors)\n\n    def update_full_metapop_params_tensors(self) -&gt; None:\n        \"\"\"\n        Update `_full_metapop_params_tensors` attribute in-place.\n        `FluFullMetapopParamsTensors` has fields corresponding\n        to all parameters in the simulation. Converts subpopulation-specific\n        parameters to tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        if self._full_metapop_params_tensors is None:\n            self._full_metapop_params_tensors = FluFullMetapopParamsTensors()\n        self.update_params_tensors(target=self._full_metapop_params_tensors)\n\n    def apply_inter_subpop_updates(self) -&gt; None:\n        \"\"\"\n        Update the `FluTravelStateTensors` according to the simulation state\n        and compute the total mixing exposure, which includes across-subpopulation\n        mixing/travel. Update the `total_mixing_exposure` attribute on each\n        subpopulation's `SusceptibleToExposed` instance accordingly, so each\n        of these transition variables can compute its transition rate.\n\n        See `apply_inter_subpop_updates` on `MetapopModel` base class\n        for logic of how/when this is called in the simulation.\n        \"\"\"\n\n        self.update_travel_state_tensors()\n\n        total_mixing_exposure = compute_total_mixing_exposure(self.travel_state_tensors,\n                                                              self.travel_params_tensors,\n                                                              self.precomputed)\n\n        # Again, `self.subpop_models` is an ordered dictionary --\n        #   so iterating over the dictionary like this is well-defined\n        #   and responsible -- the order is important because it\n        #   determines the order (index) in any metapopulation tensors\n        subpop_models = self._subpop_models_ordered\n\n        # Updates `total_mixing_exposure` attribute on each `SusceptibleToExposed`\n        # instance -- this value captures across-population travel/mixing.\n        for i in range(len(subpop_models)):\n            subpop_models.values()[i].transition_variables.S_to_E.total_mixing_exposure = \\\n                total_mixing_exposure[i, :, :]\n\n    def setup_full_metapop_schedule_tensors(self):\n        \"\"\"\n        Creates `FluFullMetapopScheduleTensors` instance and assigns to\n        `_full_metapop_schedule_tensors` attribute.\n\n        For the metapopulation model's L locations/subpopulations, for each day,\n        each value-related column in each schedule is either a float or\n        array of size (A, R) for age-risk groups.\n\n        We aggregate and reformat this schedule information and put it\n        into a `FluFullMetapopScheduleTensors` instance, where fields\n        correspond to a schedule value, and values are lists of tensors of\n        size (L, A, R). The ith element of each list corresponds to the\n        ith simulation day.\n        \"\"\"\n\n        self._full_metapop_schedule_tensors = FluFullMetapopScheduleTensors()\n\n        L = self.precomputed.L\n        A = self.precomputed.A\n        R = self.precomputed.R\n\n        # Note: there is probably a more consistent way to do this,\n        # because now `flu_contact_matrix` has two values: \"is_school_day\"\n        # and \"is_work_day\" -- other schedules' dataframes only have one\n        # relevant column value rather than two\n        for item in [(\"absolute_humidity\", \"absolute_humidity\"),\n                     (\"flu_contact_matrix\", \"is_school_day\"),\n                     (\"flu_contact_matrix\", \"is_work_day\"),\n                     (\"daily_vaccines\", \"daily_vaccines\")]:\n\n            schedule_name = item[0]\n            values_column_name = item[1]\n\n            metapop_vals = []\n\n            for subpop_model in self._subpop_models_ordered.values():\n                df = subpop_model.schedules[schedule_name].timeseries_df\n\n                # Using the `start_real_date` specification given in subpop's `SimulationSettings`,\n                # extract the relevant part of the dataframe with dates &gt;= the simulation start date.\n                # Note that `start_real_date` should be the same for each subpopulation\n                start_date = datetime.datetime.strptime(subpop_model.simulation_settings.start_real_date, \"%Y-%m-%d\")\n                df[\"simulation_day\"] = (pd.to_datetime(df[\"date\"], format=\"%Y-%m-%d\") - start_date).dt.days\n                df = df[df[\"simulation_day\"] &gt;= 0]\n\n                # Make each day's value an A x R array\n                # Pandas complains about `SettingWithCopyWarning` so we work on a copy explicitly to stop it\n                #   from complaining...\n                df = df.copy()\n                df[values_column_name] = df[values_column_name].astype(object)\n                df.loc[:, values_column_name] = df[values_column_name].apply(\n                    lambda x, A=A, R=R: np.broadcast_to(np.asarray(x).reshape(1, 1), (A, R))\n                )\n\n                metapop_vals.append(np.asarray(df[values_column_name]))\n\n            # IMPORTANT: tedious array/tensor shape/size manipulation here\n            # metapop_vals: list of L arrays, each shape (num_days, A, R)\n            # We need to transpose this... to be a list of num_days tensors, of size L x A x R\n            num_items = metapop_vals[0].shape[0]\n\n            # This is ugly and inefficient -- but at least we only do this once, when we get the initial\n            #   state of a metapopulation model in tensor form\n            transposed_metapop_vals = [torch.tensor(np.array([metapop_vals[l][i] for l in range(L)])) for i in\n                                       range(num_items)]\n\n            setattr(self._full_metapop_schedule_tensors, values_column_name, transposed_metapop_vals)\n\n    def get_flu_torch_inputs(self) -&gt; dict:\n        \"\"\"\n        Prepares and returns metapopulation simulation data in tensor format\n        that can be directly used for `torch` implementation.\n\n        Returns:\n             d (dict):\n                Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\",\n                and \"precomputed\". Corresponds to `FluFullMetapopStateTensors`,\n                `FluFullMetapopParamsTensors`, `FluFullMetapopScheduleTensors`,\n                and `FluPrecomputedTensors` instances respectively.\n        \"\"\"\n\n        # Note: does not support dynamic variables (yet). If want to\n        #   run pytorch with dynamic variables, will need to create\n        #   a method similar to `setup_full_metapop_schedule_tensors`\n        #   but for dynamic variables. Also note that we cannot differentiate\n        #   with respect to dynamic variables that are discontinuous\n        #   (e.g. a 0-1 intervention) -- so we cannot optimize discontinuous\n        #   dynamic variables.\n\n        self.update_full_metapop_state_tensors()\n        self.update_full_metapop_params_tensors()\n        self._full_metapop_params_tensors.standardize_shapes()\n        self.setup_full_metapop_schedule_tensors()\n\n        d = {}\n\n        d[\"state_tensors\"] = copy.deepcopy(self._full_metapop_state_tensors)\n        d[\"params_tensors\"] = copy.deepcopy(self._full_metapop_params_tensors)\n        d[\"schedule_tensors\"] = copy.deepcopy(self._full_metapop_schedule_tensors)\n        d[\"precomputed\"] = copy.deepcopy(self.precomputed)\n\n        return d\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.apply_inter_subpop_updates","title":"<code>apply_inter_subpop_updates() -&gt; None</code>","text":"<p>Update the <code>FluTravelStateTensors</code> according to the simulation state and compute the total mixing exposure, which includes across-subpopulation mixing/travel. Update the <code>total_mixing_exposure</code> attribute on each subpopulation's <code>SusceptibleToExposed</code> instance accordingly, so each of these transition variables can compute its transition rate.</p> <p>See <code>apply_inter_subpop_updates</code> on <code>MetapopModel</code> base class for logic of how/when this is called in the simulation.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def apply_inter_subpop_updates(self) -&gt; None:\n    \"\"\"\n    Update the `FluTravelStateTensors` according to the simulation state\n    and compute the total mixing exposure, which includes across-subpopulation\n    mixing/travel. Update the `total_mixing_exposure` attribute on each\n    subpopulation's `SusceptibleToExposed` instance accordingly, so each\n    of these transition variables can compute its transition rate.\n\n    See `apply_inter_subpop_updates` on `MetapopModel` base class\n    for logic of how/when this is called in the simulation.\n    \"\"\"\n\n    self.update_travel_state_tensors()\n\n    total_mixing_exposure = compute_total_mixing_exposure(self.travel_state_tensors,\n                                                          self.travel_params_tensors,\n                                                          self.precomputed)\n\n    # Again, `self.subpop_models` is an ordered dictionary --\n    #   so iterating over the dictionary like this is well-defined\n    #   and responsible -- the order is important because it\n    #   determines the order (index) in any metapopulation tensors\n    subpop_models = self._subpop_models_ordered\n\n    # Updates `total_mixing_exposure` attribute on each `SusceptibleToExposed`\n    # instance -- this value captures across-population travel/mixing.\n    for i in range(len(subpop_models)):\n        subpop_models.values()[i].transition_variables.S_to_E.total_mixing_exposure = \\\n            total_mixing_exposure[i, :, :]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.compute_total_pop_LAR_tensor","title":"<code>compute_total_pop_LAR_tensor() -&gt; torch.tensor</code>","text":"<p>For each subpopulation, sum initial values of population in each compartment for age-risk groups. Store all information as tensor and return tensor.</p>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.compute_total_pop_LAR_tensor--returns","title":"Returns:","text":"<p>torch.tensor of size (L, A, R):     Total population (across all compartments) for     location-age-risk (l, a, r).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_total_pop_LAR_tensor(self) -&gt; torch.tensor:\n    \"\"\"\n    For each subpopulation, sum initial values of population\n    in each compartment for age-risk groups. Store all information\n    as tensor and return tensor.\n\n    Returns:\n    --------\n    torch.tensor of size (L, A, R):\n        Total population (across all compartments) for\n        location-age-risk (l, a, r).\n    \"\"\"\n\n    # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n    #   to preserve correct index order in tensors!\n    #   See `update_travel_params_tensors` for detailed note.\n    subpop_models_ordered = self._subpop_models_ordered\n\n    total_pop_LAR_tensor = torch.zeros(self.travel_params_tensors.num_locations,\n                                       self.travel_params_tensors.num_age_groups,\n                                       self.travel_params_tensors.num_risk_groups)\n\n    # All subpop models should have the same compartments' keys\n    for name in subpop_models_ordered[0].compartments.keys():\n\n        metapop_vals = []\n\n        for model in subpop_models_ordered.values():\n            compartment = getattr(model.compartments, name)\n            metapop_vals.append(compartment.current_val)\n\n        total_pop_LAR_tensor = total_pop_LAR_tensor + torch.tensor(np.asarray(metapop_vals))\n\n    return total_pop_LAR_tensor\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.get_flu_torch_inputs","title":"<code>get_flu_torch_inputs() -&gt; dict</code>","text":"<p>Prepares and returns metapopulation simulation data in tensor format that can be directly used for <code>torch</code> implementation.</p> <p>Returns:</p> Name Type Description <code>d</code> <code>dict</code> <p>Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\", and \"precomputed\". Corresponds to <code>FluFullMetapopStateTensors</code>, <code>FluFullMetapopParamsTensors</code>, <code>FluFullMetapopScheduleTensors</code>, and <code>FluPrecomputedTensors</code> instances respectively.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_flu_torch_inputs(self) -&gt; dict:\n    \"\"\"\n    Prepares and returns metapopulation simulation data in tensor format\n    that can be directly used for `torch` implementation.\n\n    Returns:\n         d (dict):\n            Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\",\n            and \"precomputed\". Corresponds to `FluFullMetapopStateTensors`,\n            `FluFullMetapopParamsTensors`, `FluFullMetapopScheduleTensors`,\n            and `FluPrecomputedTensors` instances respectively.\n    \"\"\"\n\n    # Note: does not support dynamic variables (yet). If want to\n    #   run pytorch with dynamic variables, will need to create\n    #   a method similar to `setup_full_metapop_schedule_tensors`\n    #   but for dynamic variables. Also note that we cannot differentiate\n    #   with respect to dynamic variables that are discontinuous\n    #   (e.g. a 0-1 intervention) -- so we cannot optimize discontinuous\n    #   dynamic variables.\n\n    self.update_full_metapop_state_tensors()\n    self.update_full_metapop_params_tensors()\n    self._full_metapop_params_tensors.standardize_shapes()\n    self.setup_full_metapop_schedule_tensors()\n\n    d = {}\n\n    d[\"state_tensors\"] = copy.deepcopy(self._full_metapop_state_tensors)\n    d[\"params_tensors\"] = copy.deepcopy(self._full_metapop_params_tensors)\n    d[\"schedule_tensors\"] = copy.deepcopy(self._full_metapop_schedule_tensors)\n    d[\"precomputed\"] = copy.deepcopy(self.precomputed)\n\n    return d\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.modify_mixing_params","title":"<code>modify_mixing_params(updates_dict: dict)</code>","text":"<p>This method lets users safely modify flu mixing parameters; the metapopulation-wide tensors are updated automatically afterward. <code>FluMixingParams</code> is a frozen dataclass to avoid users naively changing parameter values and getting undesirable results -- thus, <code>FluMixingParams</code> cannot be updated directly.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_mixing_params(self,\n                         updates_dict: dict):\n    \"\"\"\n    This method lets users safely modify flu mixing parameters;\n    the metapopulation-wide tensors are updated automatically afterward.\n    `FluMixingParams` is a frozen dataclass to avoid users\n    naively changing parameter values and getting undesirable results --\n    thus, `FluMixingParams` cannot be updated directly.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`. \n    \"\"\"\n\n    self.mixing_params = clt.updated_dataclass(self.mixing_params, updates_dict)\n    self.update_travel_params_tensors()\n\n    nonlocal_travel_prop = self.travel_params_tensors.travel_proportions.clone().fill_diagonal_(0.0)\n\n    self.precomputed.sum_residents_nonlocal_travel_prop = nonlocal_travel_prop.sum(dim=1)\n\n    # Adding this for extra safety in case the user does not\n    # call `get_flu_torch_inputs` for accessing the\n    # `FullMetapopParams` instance.\n\n    # If this attribute is not `None`, it means we are using\n    # the `torch` implementation, and we should update the\n    # corresponding `FullMetapopParams` instance with the new\n    # `FluMixingParams` values.\n    if self._full_metapop_params_tensors:\n        self.update_full_metapop_params_tensors()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.modify_subpop_params","title":"<code>modify_subpop_params(subpop_name: str, updates_dict: dict)</code>","text":"<p>This method lets users safely modify a single subpopulation parameters field; the metapopulation-wide tensors are updated automatically afterward.</p> <p>In a <code>FluMetapopModel</code>, subpopulation parameters are combined into (L, A, R) tensors across L subpopulations.<code>FluSubpopParams</code> is a frozen dataclass to avoid users naively changing parameter values and getting undesirable results -- thus, <code>FluSubpopParams</code> on a subpopulation model cannot be updated directly.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_name</code> <code>str</code> <p>Value must match the <code>name</code> attribute of one of the <code>FluSubpopModel</code> instances contained in this metapopulation model's <code>subpop_models</code> attribute.</p> required <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_subpop_params(self,\n                         subpop_name: str,\n                         updates_dict: dict):\n    \"\"\"\n    This method lets users safely modify a single subpopulation\n    parameters field; the metapopulation-wide tensors are updated\n    automatically afterward.\n\n    In a `FluMetapopModel`, subpopulation parameters are combined into\n    (L, A, R) tensors across L subpopulations.`FluSubpopParams` is a frozen\n    dataclass to avoid users naively changing parameter values and getting\n    undesirable results -- thus, `FluSubpopParams` on a subpopulation\n    model cannot be updated directly.\n\n    Parameters:\n        subpop_name (str):\n           Value must match the `name` attribute of one of the\n           `FluSubpopModel` instances contained in this metapopulation\n            model's `subpop_models` attribute.\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`.\n    \"\"\"\n\n    # Since `FluSubpopParams` is frozen, we return a new instance\n    #   with the reflected updates\n    self.subpop_models[subpop_name].params = clt.updated_dataclass(\n        self.subpop_models[subpop_name].params, updates_dict\n    )\n\n    self.update_travel_params_tensors()\n\n    # Adding this for extra safety in case the user does not\n    # call `get_flu_torch_inputs` for accessing the\n    # `FullMetapopParams` instance.\n\n    # If this attribute is not `None`, it means we are using\n    # the `torch` implementation, and we should update the\n    # corresponding `FullMetapopParams` instance with the new\n    # `FluMixingParams` values.\n    if self._full_metapop_params_tensors:\n        self.update_full_metapop_params_tensors()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.setup_full_metapop_schedule_tensors","title":"<code>setup_full_metapop_schedule_tensors()</code>","text":"<p>Creates <code>FluFullMetapopScheduleTensors</code> instance and assigns to <code>_full_metapop_schedule_tensors</code> attribute.</p> <p>For the metapopulation model's L locations/subpopulations, for each day, each value-related column in each schedule is either a float or array of size (A, R) for age-risk groups.</p> <p>We aggregate and reformat this schedule information and put it into a <code>FluFullMetapopScheduleTensors</code> instance, where fields correspond to a schedule value, and values are lists of tensors of size (L, A, R). The ith element of each list corresponds to the ith simulation day.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def setup_full_metapop_schedule_tensors(self):\n    \"\"\"\n    Creates `FluFullMetapopScheduleTensors` instance and assigns to\n    `_full_metapop_schedule_tensors` attribute.\n\n    For the metapopulation model's L locations/subpopulations, for each day,\n    each value-related column in each schedule is either a float or\n    array of size (A, R) for age-risk groups.\n\n    We aggregate and reformat this schedule information and put it\n    into a `FluFullMetapopScheduleTensors` instance, where fields\n    correspond to a schedule value, and values are lists of tensors of\n    size (L, A, R). The ith element of each list corresponds to the\n    ith simulation day.\n    \"\"\"\n\n    self._full_metapop_schedule_tensors = FluFullMetapopScheduleTensors()\n\n    L = self.precomputed.L\n    A = self.precomputed.A\n    R = self.precomputed.R\n\n    # Note: there is probably a more consistent way to do this,\n    # because now `flu_contact_matrix` has two values: \"is_school_day\"\n    # and \"is_work_day\" -- other schedules' dataframes only have one\n    # relevant column value rather than two\n    for item in [(\"absolute_humidity\", \"absolute_humidity\"),\n                 (\"flu_contact_matrix\", \"is_school_day\"),\n                 (\"flu_contact_matrix\", \"is_work_day\"),\n                 (\"daily_vaccines\", \"daily_vaccines\")]:\n\n        schedule_name = item[0]\n        values_column_name = item[1]\n\n        metapop_vals = []\n\n        for subpop_model in self._subpop_models_ordered.values():\n            df = subpop_model.schedules[schedule_name].timeseries_df\n\n            # Using the `start_real_date` specification given in subpop's `SimulationSettings`,\n            # extract the relevant part of the dataframe with dates &gt;= the simulation start date.\n            # Note that `start_real_date` should be the same for each subpopulation\n            start_date = datetime.datetime.strptime(subpop_model.simulation_settings.start_real_date, \"%Y-%m-%d\")\n            df[\"simulation_day\"] = (pd.to_datetime(df[\"date\"], format=\"%Y-%m-%d\") - start_date).dt.days\n            df = df[df[\"simulation_day\"] &gt;= 0]\n\n            # Make each day's value an A x R array\n            # Pandas complains about `SettingWithCopyWarning` so we work on a copy explicitly to stop it\n            #   from complaining...\n            df = df.copy()\n            df[values_column_name] = df[values_column_name].astype(object)\n            df.loc[:, values_column_name] = df[values_column_name].apply(\n                lambda x, A=A, R=R: np.broadcast_to(np.asarray(x).reshape(1, 1), (A, R))\n            )\n\n            metapop_vals.append(np.asarray(df[values_column_name]))\n\n        # IMPORTANT: tedious array/tensor shape/size manipulation here\n        # metapop_vals: list of L arrays, each shape (num_days, A, R)\n        # We need to transpose this... to be a list of num_days tensors, of size L x A x R\n        num_items = metapop_vals[0].shape[0]\n\n        # This is ugly and inefficient -- but at least we only do this once, when we get the initial\n        #   state of a metapopulation model in tensor form\n        transposed_metapop_vals = [torch.tensor(np.array([metapop_vals[l][i] for l in range(L)])) for i in\n                                   range(num_items)]\n\n        setattr(self._full_metapop_schedule_tensors, values_column_name, transposed_metapop_vals)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_full_metapop_params_tensors","title":"<code>update_full_metapop_params_tensors() -&gt; None</code>","text":"<p>Update <code>_full_metapop_params_tensors</code> attribute in-place. <code>FluFullMetapopParamsTensors</code> has fields corresponding to all parameters in the simulation. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_full_metapop_params_tensors(self) -&gt; None:\n    \"\"\"\n    Update `_full_metapop_params_tensors` attribute in-place.\n    `FluFullMetapopParamsTensors` has fields corresponding\n    to all parameters in the simulation. Converts subpopulation-specific\n    parameters to tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    if self._full_metapop_params_tensors is None:\n        self._full_metapop_params_tensors = FluFullMetapopParamsTensors()\n    self.update_params_tensors(target=self._full_metapop_params_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_full_metapop_state_tensors","title":"<code>update_full_metapop_state_tensors() -&gt; None</code>","text":"<p>Update <code>_full_metapop_state_tensors</code> attribute in-place. <code>FluFullMetapopStateTensors</code> has fields corresponding to all state variables in the simulation. Converts subpopulation-specific state to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_full_metapop_state_tensors(self) -&gt; None:\n    \"\"\"\n    Update `_full_metapop_state_tensors` attribute in-place.\n    `FluFullMetapopStateTensors` has fields corresponding\n    to all state variables in the simulation.\n    Converts subpopulation-specific state to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    if self._full_metapop_state_tensors is None:\n        self._full_metapop_state_tensors = FluFullMetapopStateTensors()\n    self.update_state_tensors(self._full_metapop_state_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_params_tensors","title":"<code>update_params_tensors(target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors</code>","text":"<p>Update <code>target</code> in-place. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk, except for <code>num_locations</code> and <code>travel_proportions</code>, which have size 1 and (L, L) respectively.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_params_tensors(self,\n                          target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors:\n    \"\"\"\n    Update `target` in-place. Converts subpopulation-specific\n    parameters to tensors of size (L, A, R) for location-age-risk,\n    except for `num_locations` and `travel_proportions`, which\n    have size 1 and (L, L) respectively.\n    \"\"\"\n\n    # USE THE ORDERED DICTIONARY HERE FOR SAFETY!\n    #   AGAIN, ORDER MATTERS BECAUSE ORDER DETERMINES\n    #   THE SUBPOPULATION INDEX IN THE METAPOPULATION\n    #   TENSOR!\n    subpop_models_ordered = self._subpop_models_ordered\n\n    # Subpop models should have the same A, R so grab\n    #   from the first subpop model\n    A = subpop_models_ordered[0].params.num_age_groups\n    R = subpop_models_ordered[0].params.num_risk_groups\n\n    for field in fields(target):\n\n        name = field.name\n\n        metapop_vals = []\n\n        if name == \"num_locations\" or name == \"travel_proportions\":\n            setattr(target, name, torch.tensor(getattr(self.mixing_params, name)))\n\n        else:\n            for model in subpop_models_ordered.values():\n                metapop_vals.append(getattr(model.params, name))\n\n            # If all values are equal to each other, then\n            #   simply store the first value (since its value is common\n            #   across metapopulations)\n            first_val = metapop_vals[0]\n            if all(np.allclose(x, first_val) for x in metapop_vals):\n                metapop_vals = first_val\n\n            # Converting list of arrays to tensors is slow --\n            #   better to convert to array first\n            if isinstance(metapop_vals, list):\n                metapop_vals = np.asarray(metapop_vals)\n                # metapop_vals = np.stack([clt.to_AR_array(x, A, R) for x in metapop_vals])\n\n            setattr(target, name, torch.tensor(metapop_vals))\n\n    # Convert all tensors to correct size!\n    target.standardize_shapes()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_state_tensors","title":"<code>update_state_tensors(target: FluTravelStateTensors) -&gt; None</code>","text":"<p>Update <code>target</code> instance in-place with current simulation values. Each field of <code>target</code> corresponds to a field in <code>FluSubpopState</code>, and contains either a tensor of size (L, A, R) or a tensor of size (L), where (l, a, r) refers to location-age-risk.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_state_tensors(self,\n                         target: FluTravelStateTensors) -&gt; None:\n    \"\"\"\n    Update `target` instance in-place with current simulation\n    values. Each field of `target` corresponds to a field in\n    `FluSubpopState`, and contains either a tensor of size\n    (L, A, R) or a tensor of size (L), where (l, a, r) refers to\n    location-age-risk.\n    \"\"\"\n\n    # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n    #   to preserve correct index order in tensors!\n    #   See `update_travel_params_tensors` for detailed note.\n    subpop_models_ordered = self._subpop_models_ordered\n\n    for field in fields(target):\n\n        name = field.name\n\n        # FluTravelStateTensors has an attribute\n        #   that is a dictionary called `init_vals` --\n        #   disregard, as this only used to store\n        #   initial values for resetting, but is not\n        #   used in the travel model computation\n        if name == \"init_vals\":\n            continue\n\n        metapop_vals = []\n\n        for model in subpop_models_ordered.values():\n            current_val = getattr(model.state, name)\n            metapop_vals.append(current_val)\n\n        # Probably want to update this to be cleaner...\n        # `SubpopState` fields that correspond to `Schedule` instances\n        # have initial values of `None` -- but we cannot build a tensor\n        # with `None` values, so we convert values to 0s.\n        if any(v is None for v in metapop_vals):\n            setattr(target, name, torch.tensor(np.full(np.shape(metapop_vals), 0.0)))\n        else:\n            setattr(target, name, torch.tensor(np.asarray(metapop_vals)))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_travel_params_tensors","title":"<code>update_travel_params_tensors() -&gt; None</code>","text":"<p>Update <code>travel_params_tensors</code> attribute in-place. <code>FluTravelParamsTensors</code> only has fields corresponding to parameters relevant for the travel model. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_travel_params_tensors(self) -&gt; None:\n    \"\"\"\n    Update `travel_params_tensors` attribute in-place.\n    `FluTravelParamsTensors` only has fields corresponding\n    to parameters relevant for the travel model.\n    Converts subpopulation-specific parameters to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    self.update_params_tensors(target=self.travel_params_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_travel_state_tensors","title":"<code>update_travel_state_tensors() -&gt; None</code>","text":"<p>Update <code>travel_state_tensors</code> attribute in-place. <code>FluTravelStateTensors</code> only has fields corresponding to state variables relevant for the travel model. Converts subpopulation-specific state to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_travel_state_tensors(self) -&gt; None:\n    \"\"\"\n    Update `travel_state_tensors` attribute in-place.\n    `FluTravelStateTensors` only has fields corresponding\n    to state variables relevant for the travel model.\n    Converts subpopulation-specific state to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    self.update_state_tensors(self.travel_state_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModelError","title":"<code>FluMetapopModelError</code>","text":"<p>               Bases: <code>MetapopModelError</code></p> <p>Custom exceptions for flu metapopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluMetapopModelError(clt.MetapopModelError):\n    \"\"\"Custom exceptions for flu metapopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMixingParams","title":"<code>FluMixingParams</code>  <code>dataclass</code>","text":"<p>Contains parameters corresponding to inter-subpopulation (metapopulation model) specifications: the number of subpopulations included, and the travel proportions between them.</p> <p>Parameters:</p> Name Type Description Default <code>num_locations</code> <code>int</code> <p>Number of locations (subpopulations) in the metapopulation model.</p> required <code>travel_proportions</code> <code>np.ndarray of shape (A, R</code> <p>L x L array of floats in [0,1], where L is the number of locations (subpopulations), and the i-jth element is the proportion of people in subpopulation i that travel to subpopulation j.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass FluMixingParams:\n    \"\"\"\n    Contains parameters corresponding to inter-subpopulation\n    (metapopulation model) specifications: the number of\n    subpopulations included, and the travel proportions between them.\n\n    Params:\n        num_locations (int):\n            Number of locations (subpopulations) in the\n            metapopulation model.\n        travel_proportions (np.ndarray of shape (A, R)):\n            L x L array of floats in [0,1], where L is the number\n            of locations (subpopulations), and the i-jth element\n            is the proportion of people in subpopulation i that\n            travel to subpopulation j.\n    \"\"\"\n\n    num_locations: Optional[int]\n    travel_proportions: Optional[np.ndarray]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluPrecomputedTensors","title":"<code>FluPrecomputedTensors</code>","text":"<p>Stores precomputed quantities that are repeatedly used, for computational efficiency.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>class FluPrecomputedTensors:\n    \"\"\"\n    Stores precomputed quantities that are repeatedly\n    used, for computational efficiency.\n    \"\"\"\n\n    def __init__(self,\n                 total_pop_LAR_tensor: torch.Tensor,\n                 params: FluTravelParamsTensors) -&gt; None:\n\n        self.total_pop_LAR_tensor = total_pop_LAR_tensor\n\n        self.L = int(params.num_locations.item())\n        self.A = int(params.num_age_groups.item())\n        self.R = int(params.num_risk_groups.item())\n\n        self.total_pop_LA = torch.sum(self.total_pop_LAR_tensor, dim=2)\n\n        # Remove the diagonal!\n        self.nonlocal_travel_prop = params.travel_proportions.clone().fill_diagonal_(0.0)\n\n        # We don't need einsum for residents traveling\n        #   -- Dave and Remy helped me check this\n        # \\sum_{k \\not = \\ell} v^{\\ell \\rightarrow k}\n        # Note we already have k \\not = \\ell because we set the diagonal of\n        #   nonlocal_travel_prop to 0\n        self.sum_residents_nonlocal_travel_prop = self.nonlocal_travel_prop.sum(dim=1)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel","title":"<code>FluSubpopModel</code>","text":"<p>               Bases: <code>SubpopModel</code></p> <p>Class for creating ImmunoSEIRS flu model with predetermined fixed structure -- initial values and epidemiological structure are populated by user-specified <code>JSON</code> files.</p> <p>Key method create_transmission_model returns a <code>SubpopModel</code> instance with S-E-I-H-R-D compartments and M and MV epi metrics.</p> The update structure is as follows <ul> <li>S &lt;- S + R_to_S - S_to_E</li> <li>E &lt;- E + S_to_E - E_to_IP - E_to_IA</li> <li>IA &lt;- IA + E_to_IA - IA_to_R </li> <li>IP &lt;- IP + E_to_IP - IP_to_IS</li> <li>IS &lt;- IS + IP_to_IS - IS_to_R - IS_to_H</li> <li>H &lt;- H + IS_to_H - H_to_R - H_to_D</li> <li>R &lt;- R + IS_to_R + H_to_R - R_to_S</li> <li>D &lt;- D + H_to_D</li> </ul> The following are TransitionVariable instances <ul> <li>R_to_S is a RecoveredToSusceptible instance</li> <li>S_to_E is a SusceptibleToExposed instance</li> <li>IP_to_IS is a PresympToSymp instance</li> <li>IS_to_H is a SympToHosp instance</li> <li>IS_to_R is a SympToRecovered instance</li> <li>H_to_R is a HospToRecovered instance</li> <li>H_to_D is a HospToDead instance</li> </ul> There are three TransitionVariableGroups <ul> <li>E_out (handles E_to_IP and E_to_IA)</li> <li>IS_out (handles IS_to_H and IS_to_R)</li> <li>H_out (handles H_to_R and H_to_D)</li> </ul> The following are EpiMetric instances <ul> <li>M is a InfInducedImmunity instance</li> <li>MV is a VaxInducedImmunity instance</li> </ul> <p>Transition rates and update formulas are specified in corresponding classes.</p> <p>See parent class <code>SubpopModel</code>'s docstring for additional attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluSubpopModel(clt.SubpopModel):\n    \"\"\"\n    Class for creating ImmunoSEIRS flu model with predetermined fixed\n    structure -- initial values and epidemiological structure are\n    populated by user-specified `JSON` files.\n\n    Key method create_transmission_model returns a `SubpopModel`\n    instance with S-E-I-H-R-D compartments and M\n    and MV epi metrics.\n\n    The update structure is as follows:\n        - S &lt;- S + R_to_S - S_to_E\n        - E &lt;- E + S_to_E - E_to_IP - E_to_IA\n        - IA &lt;- IA + E_to_IA - IA_to_R \n        - IP &lt;- IP + E_to_IP - IP_to_IS\n        - IS &lt;- IS + IP_to_IS - IS_to_R - IS_to_H\n        - H &lt;- H + IS_to_H - H_to_R - H_to_D\n        - R &lt;- R + IS_to_R + H_to_R - R_to_S\n        - D &lt;- D + H_to_D\n\n    The following are TransitionVariable instances:\n        - R_to_S is a RecoveredToSusceptible instance\n        - S_to_E is a SusceptibleToExposed instance\n        - IP_to_IS is a PresympToSymp instance\n        - IS_to_H is a SympToHosp instance\n        - IS_to_R is a SympToRecovered instance\n        - H_to_R is a HospToRecovered instance\n        - H_to_D is a HospToDead instance\n\n    There are three TransitionVariableGroups:\n        - E_out (handles E_to_IP and E_to_IA)\n        - IS_out (handles IS_to_H and IS_to_R)\n        - H_out (handles H_to_R and H_to_D)\n\n    The following are EpiMetric instances:\n        - M is a InfInducedImmunity instance\n        - MV is a VaxInducedImmunity instance\n\n    Transition rates and update formulas are specified in\n    corresponding classes.\n\n    See parent class `SubpopModel`'s docstring for additional attributes.\n    \"\"\"\n\n    def __init__(self,\n                 state: FluSubpopState,\n                 params: FluSubpopParams,\n                 simulation_settings: FluSubpopSchedules,\n                 RNG: np.random.Generator,\n                 schedules_spec: FluSubpopSchedules,\n                 name: str):\n        \"\"\"\n        Args:\n            state (FluSubpopState):\n                holds current simulation state information,\n                such as current values of epidemiological compartments\n                and epi metrics.\n            params (FluSubpopParams):\n                holds epidemiological parameter values.\n            simulation_settings (SimulationSettings):\n                holds simulation settings.\n            RNG (np.random.Generator):\n                numpy random generator object used to obtain\n                random numbers.\n            schedules_spec (FluSubpopSchedules):\n                holds dataframes that specify `Schedule` instances.\n            name (str):\n                unique name of MetapopModel instance.\n        \"\"\"\n\n        self.schedules_spec = schedules_spec\n\n        # IMPORTANT NOTE: as always, we must be careful with mutable objects\n        # and generally use deep copies to avoid modification of the same\n        # object. But in this function call, using deep copies is unnecessary\n        # (redundant) because the parent class `SubpopModel`'s `__init__`\n        # creates deep copies.\n        super().__init__(state, params, simulation_settings, RNG, name)\n\n    def create_compartments(self) -&gt; sc.objdict[str, clt.Compartment]:\n\n        # Create `Compartment` instances S-E-IA-IP-IS-H-R-D (7 compartments total)\n        # Save instances in `sc.objdict` and return objdict\n\n        compartments = sc.objdict()\n\n        for name in (\"S\", \"E\", \"IP\", \"IS\", \"IA\", \"H\", \"R\", \"D\"):\n            compartments[name] = clt.Compartment(getattr(self.state, name))\n\n        return compartments\n\n    def create_dynamic_vals(self) -&gt; sc.objdict[str, clt.DynamicVal]:\n        \"\"\"\n        Create all `DynamicVal` instances, save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        dynamic_vals = sc.objdict()\n\n        dynamic_vals[\"beta_reduce\"] = BetaReduce(init_val=0.0,\n                                                 is_enabled=False)\n\n        return dynamic_vals\n\n    def create_schedules(self) -&gt; sc.objdict[str, clt.Schedule]:\n        \"\"\"\n        Create all `Schedule` instances, save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        schedules = sc.objdict()\n\n        schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n        schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n        schedules[\"daily_vaccines\"] = DailyVaccines()\n\n        for field, df in asdict(self.schedules_spec).items():\n\n            try:\n                df[\"date\"] = pd.to_datetime(df[\"date\"], format='%Y-%m-%d').dt.date\n            except ValueError as e:\n                raise ValueError(\"Error: dates should be strings in YYYY-MM-DD format or \"\n                                 \"`date.datetime` objects.\") from e\n\n            schedules[field].timeseries_df = df\n\n        return schedules\n\n    def create_transition_variables(self) -&gt; sc.objdict[str, clt.TransitionVariable]:\n        \"\"\"\n        Create all `TransitionVariable` instances,\n        save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        # NOTE: see the parent class `SubpopModel`'s `__init__` --\n        # `create_transition_variables` is called after\n        # `simulation_settings` is assigned\n\n        transition_type = self.simulation_settings.transition_type\n\n        transition_variables = sc.objdict()\n\n        S = self.compartments.S\n        E = self.compartments.E\n        IP = self.compartments.IP\n        IS = self.compartments.IS\n        IA = self.compartments.IA\n        H = self.compartments.H\n        R = self.compartments.R\n        D = self.compartments.D\n\n        transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n        transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n        transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n        transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n        transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n        transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n        transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n        transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n        transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n        transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n        return transition_variables\n\n    def create_transition_variable_groups(self) -&gt; sc.objdict[str, clt.TransitionVariableGroup]:\n        \"\"\"\n        Create all transition variable groups described in docstring (2 transition\n        variable groups total), save in `sc.objdict`, return objdict\n        \"\"\"\n\n        # Shortcuts for attribute access\n        # NOTE: see the parent class `SubpopModel`'s `__init__` --\n        # `create_transition_variable_groups` is called after\n        # `simulation_settings` is assigned\n\n        transition_type = self.simulation_settings.transition_type\n\n        transition_variable_groups = sc.objdict()\n\n        transition_variable_groups.E_out = clt.TransitionVariableGroup(self.compartments.E,\n                                                                       transition_type,\n                                                                       (self.transition_variables.E_to_IP,\n                                                                        self.transition_variables.E_to_IA))\n\n        transition_variable_groups.IS_out = clt.TransitionVariableGroup(self.compartments.IS,\n                                                                        transition_type,\n                                                                        (self.transition_variables.IS_to_R,\n                                                                         self.transition_variables.IS_to_H))\n\n        transition_variable_groups.H_out = clt.TransitionVariableGroup(self.compartments.H,\n                                                                       transition_type,\n                                                                       (self.transition_variables.H_to_R,\n                                                                        self.transition_variables.H_to_D))\n\n        return transition_variable_groups\n\n    def create_epi_metrics(self) -&gt; sc.objdict[str, clt.EpiMetric]:\n        \"\"\"\n        Create all epi metric described in docstring (2 state\n        variables total), save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        epi_metrics = sc.objdict()\n\n        epi_metrics.M = \\\n            InfInducedImmunity(getattr(self.state, \"M\"),\n                               self.transition_variables.R_to_S)\n\n        epi_metrics.MV = \\\n            VaxInducedImmunity(getattr(self.state, \"MV\"))\n\n        return epi_metrics\n\n    def modify_subpop_params(self,\n                             updates_dict: dict):\n        \"\"\"\n        This method lets users safely modify a single subpopulation\n        parameters field; if this subpop model is associated with\n        a metapop model, the metapopulation-wide tensors are updated\n        automatically afterward. See also `modify_subpop_params` method on\n        `FluMetapopModel`.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`.\n        \"\"\"\n\n        # If associated with metapop model, run this method\n        #   on the metapop model itself to handle metapopulation-wide\n        #   tensor updating\n        if self.metapop_model:\n            self.metapop_model.modify_subpop_params(self.name,\n                                                    updates_dict)\n        else:\n            # Since `SubpopParams` is frozen, we return a new instance\n            #   with the reflected updates\n            self.params = clt.updated_dataclass(self.params, updates_dict)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.__init__","title":"<code>__init__(state: FluSubpopState, params: FluSubpopParams, simulation_settings: FluSubpopSchedules, RNG: np.random.Generator, schedules_spec: FluSubpopSchedules, name: str)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>FluSubpopState</code> <p>holds current simulation state information, such as current values of epidemiological compartments and epi metrics.</p> required <code>params</code> <code>FluSubpopParams</code> <p>holds epidemiological parameter values.</p> required <code>simulation_settings</code> <code>SimulationSettings</code> <p>holds simulation settings.</p> required <code>RNG</code> <code>Generator</code> <p>numpy random generator object used to obtain random numbers.</p> required <code>schedules_spec</code> <code>FluSubpopSchedules</code> <p>holds dataframes that specify <code>Schedule</code> instances.</p> required <code>name</code> <code>str</code> <p>unique name of MetapopModel instance.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             state: FluSubpopState,\n             params: FluSubpopParams,\n             simulation_settings: FluSubpopSchedules,\n             RNG: np.random.Generator,\n             schedules_spec: FluSubpopSchedules,\n             name: str):\n    \"\"\"\n    Args:\n        state (FluSubpopState):\n            holds current simulation state information,\n            such as current values of epidemiological compartments\n            and epi metrics.\n        params (FluSubpopParams):\n            holds epidemiological parameter values.\n        simulation_settings (SimulationSettings):\n            holds simulation settings.\n        RNG (np.random.Generator):\n            numpy random generator object used to obtain\n            random numbers.\n        schedules_spec (FluSubpopSchedules):\n            holds dataframes that specify `Schedule` instances.\n        name (str):\n            unique name of MetapopModel instance.\n    \"\"\"\n\n    self.schedules_spec = schedules_spec\n\n    # IMPORTANT NOTE: as always, we must be careful with mutable objects\n    # and generally use deep copies to avoid modification of the same\n    # object. But in this function call, using deep copies is unnecessary\n    # (redundant) because the parent class `SubpopModel`'s `__init__`\n    # creates deep copies.\n    super().__init__(state, params, simulation_settings, RNG, name)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_dynamic_vals","title":"<code>create_dynamic_vals() -&gt; sc.objdict[str, clt.DynamicVal]</code>","text":"<p>Create all <code>DynamicVal</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_dynamic_vals(self) -&gt; sc.objdict[str, clt.DynamicVal]:\n    \"\"\"\n    Create all `DynamicVal` instances, save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    dynamic_vals = sc.objdict()\n\n    dynamic_vals[\"beta_reduce\"] = BetaReduce(init_val=0.0,\n                                             is_enabled=False)\n\n    return dynamic_vals\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_epi_metrics","title":"<code>create_epi_metrics() -&gt; sc.objdict[str, clt.EpiMetric]</code>","text":"<p>Create all epi metric described in docstring (2 state variables total), save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_epi_metrics(self) -&gt; sc.objdict[str, clt.EpiMetric]:\n    \"\"\"\n    Create all epi metric described in docstring (2 state\n    variables total), save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    epi_metrics = sc.objdict()\n\n    epi_metrics.M = \\\n        InfInducedImmunity(getattr(self.state, \"M\"),\n                           self.transition_variables.R_to_S)\n\n    epi_metrics.MV = \\\n        VaxInducedImmunity(getattr(self.state, \"MV\"))\n\n    return epi_metrics\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_schedules","title":"<code>create_schedules() -&gt; sc.objdict[str, clt.Schedule]</code>","text":"<p>Create all <code>Schedule</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_schedules(self) -&gt; sc.objdict[str, clt.Schedule]:\n    \"\"\"\n    Create all `Schedule` instances, save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    schedules = sc.objdict()\n\n    schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n    schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n    schedules[\"daily_vaccines\"] = DailyVaccines()\n\n    for field, df in asdict(self.schedules_spec).items():\n\n        try:\n            df[\"date\"] = pd.to_datetime(df[\"date\"], format='%Y-%m-%d').dt.date\n        except ValueError as e:\n            raise ValueError(\"Error: dates should be strings in YYYY-MM-DD format or \"\n                             \"`date.datetime` objects.\") from e\n\n        schedules[field].timeseries_df = df\n\n    return schedules\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_transition_variable_groups","title":"<code>create_transition_variable_groups() -&gt; sc.objdict[str, clt.TransitionVariableGroup]</code>","text":"<p>Create all transition variable groups described in docstring (2 transition variable groups total), save in <code>sc.objdict</code>, return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_transition_variable_groups(self) -&gt; sc.objdict[str, clt.TransitionVariableGroup]:\n    \"\"\"\n    Create all transition variable groups described in docstring (2 transition\n    variable groups total), save in `sc.objdict`, return objdict\n    \"\"\"\n\n    # Shortcuts for attribute access\n    # NOTE: see the parent class `SubpopModel`'s `__init__` --\n    # `create_transition_variable_groups` is called after\n    # `simulation_settings` is assigned\n\n    transition_type = self.simulation_settings.transition_type\n\n    transition_variable_groups = sc.objdict()\n\n    transition_variable_groups.E_out = clt.TransitionVariableGroup(self.compartments.E,\n                                                                   transition_type,\n                                                                   (self.transition_variables.E_to_IP,\n                                                                    self.transition_variables.E_to_IA))\n\n    transition_variable_groups.IS_out = clt.TransitionVariableGroup(self.compartments.IS,\n                                                                    transition_type,\n                                                                    (self.transition_variables.IS_to_R,\n                                                                     self.transition_variables.IS_to_H))\n\n    transition_variable_groups.H_out = clt.TransitionVariableGroup(self.compartments.H,\n                                                                   transition_type,\n                                                                   (self.transition_variables.H_to_R,\n                                                                    self.transition_variables.H_to_D))\n\n    return transition_variable_groups\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_transition_variables","title":"<code>create_transition_variables() -&gt; sc.objdict[str, clt.TransitionVariable]</code>","text":"<p>Create all <code>TransitionVariable</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_transition_variables(self) -&gt; sc.objdict[str, clt.TransitionVariable]:\n    \"\"\"\n    Create all `TransitionVariable` instances,\n    save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    # NOTE: see the parent class `SubpopModel`'s `__init__` --\n    # `create_transition_variables` is called after\n    # `simulation_settings` is assigned\n\n    transition_type = self.simulation_settings.transition_type\n\n    transition_variables = sc.objdict()\n\n    S = self.compartments.S\n    E = self.compartments.E\n    IP = self.compartments.IP\n    IS = self.compartments.IS\n    IA = self.compartments.IA\n    H = self.compartments.H\n    R = self.compartments.R\n    D = self.compartments.D\n\n    transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n    transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n    transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n    transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n    transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n    transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n    transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n    transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n    transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n    transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n    return transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.modify_subpop_params","title":"<code>modify_subpop_params(updates_dict: dict)</code>","text":"<p>This method lets users safely modify a single subpopulation parameters field; if this subpop model is associated with a metapop model, the metapopulation-wide tensors are updated automatically afterward. See also <code>modify_subpop_params</code> method on <code>FluMetapopModel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_subpop_params(self,\n                         updates_dict: dict):\n    \"\"\"\n    This method lets users safely modify a single subpopulation\n    parameters field; if this subpop model is associated with\n    a metapop model, the metapopulation-wide tensors are updated\n    automatically afterward. See also `modify_subpop_params` method on\n    `FluMetapopModel`.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`.\n    \"\"\"\n\n    # If associated with metapop model, run this method\n    #   on the metapop model itself to handle metapopulation-wide\n    #   tensor updating\n    if self.metapop_model:\n        self.metapop_model.modify_subpop_params(self.name,\n                                                updates_dict)\n    else:\n        # Since `SubpopParams` is frozen, we return a new instance\n        #   with the reflected updates\n        self.params = clt.updated_dataclass(self.params, updates_dict)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModelError","title":"<code>FluSubpopModelError</code>","text":"<p>               Bases: <code>SubpopModelError</code></p> <p>Custom exceptions for flu subpopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluSubpopModelError(clt.SubpopModelError):\n    \"\"\"Custom exceptions for flu subpopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopParams","title":"<code>FluSubpopParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopParams</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in <code>FluSubpopModel</code>.</p> <p>Each field of datatype np.ndarray must be A x R, where A is the number of age groups and R is the number of risk groups. Note: this means all arrays should be 2D. See FluSubpopState docstring for important formatting note on 2D arrays.</p> <p>Note: the user does not have to specify <code>total_pop_age_risk</code> -- this is automatically computed when a <code>FluSubpopModel</code> is instantiated. This is to ensure that the total population (summed across all compartments) actually equals <code>total_pop_age_risk</code> -- and the user doesn't change one without updating the other.</p> <p>Attributes:</p> Name Type Description <code>num_age_groups</code> <code>positive int</code> <p>number of age groups.</p> <code>num_risk_groups</code> <code>positive int</code> <p>number of risk groups.</p> <code>beta_baseline</code> <code>positive float</code> <p>transmission rate.</p> <code>total_pop_age_risk</code> <code>np.ndarray of positive ints</code> <p>total number in population, summed across all age-risk groups.</p> <code>humidity_impact</code> <code>positive float</code> <p>coefficient that determines how much absolute humidity affects beta_baseline.</p> <code>inf_induced_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of infected individuals.</p> <code>inf_induced_immune_wane</code> <code>positive float</code> <p>rate at which infection-induced immunity against infection wanes.</p> <code>vax_induced_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of vaccinated individuals.</p> <code>vax_induced_immune_wane</code> <code>positive float</code> <p>rate at which vaccine-induced immunity against infection wanes.</p> <code>inf_induced_inf_risk_reduce</code> <code>positive float</code> <p>reduction in risk of getting infected after getting infected</p> <code>inf_induced_hosp_risk_reduce</code> <code>positive float</code> <p>reduction in risk of hospitalization after getting infected</p> <code>inf_induced_death_risk_reduce</code> <code>positive float</code> <p>reduction in risk of death after getting infected</p> <code>vax_induced_inf_risk_reduce</code> <code>positive float</code> <p>reduction in risk of getting infected after getting vaccinated</p> <code>vax_induced_hosp_risk_reduce</code> <code>positive float</code> <p>reduction in risk of hospitalization after getting vaccinated</p> <code>vax_induced_death_risk_reduce</code> <code>positive float</code> <p>reduction in risk of death after getting vaccinated</p> <code>R_to_S_rate</code> <code>positive float</code> <p>rate at which people in R move to S.</p> <code>E_to_I_rate</code> <code>positive float</code> <p>rate at which people in E move to I (both IP and IA, infected pre-symptomatic and infected asymptomatic)</p> <code>IP_to_IS_rate</code> <code>positive float</code> <p>rate a which people in IP (infected pre-symptomatic) move to IS (infected symptomatic)</p> <code>IS_to_R_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to R.</p> <code>IA_to_R_rate</code> <code>positive float</code> <p>rate at which people in IA (infected asymptomatic) move to R</p> <code>IS_to_H_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to H.</p> <code>H_to_R_rate</code> <code>positive float</code> <p>rate at which people in H move to R.</p> <code>H_to_D_rate</code> <code>positive float</code> <p>rate at which people in H move to D.</p> <code>E_to_IA_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>proportion exposed who are asymptomatic based on age-risk groups.</p> <code>IS_to_H_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion infected who are hospitalized based on age-risk groups.</p> <code>H_to_D_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion hospitalized who die based on age-risk groups.</p> <code>IP_relative_inf</code> <code>positive float</code> <p>relative infectiousness of pre-symptomatic to symptomatic people (IP to IS compartment).</p> <code>IA_relative_inf</code> <code>positive float</code> <p>relative infectiousness of asymptomatic to symptomatic people (IA to IS compartment).</p> <code>relative_suscept</code> <code>np.ndarray of positive floats in [0,1]</code> <p>relative susceptibility to infection by age group</p> <code>mobility_modifier</code> <code>np.ndarray of positive floats in [0,1]</code> <p>total proportion of time spent away from home by age group</p> <code>total_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has</p> <code>school_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at school -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> <code>work_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at work -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass FluSubpopParams(clt.SubpopParams):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in `FluSubpopModel`.\n\n    Each field of datatype np.ndarray must be A x R,\n    where A is the number of age groups and R is the number of\n    risk groups. Note: this means all arrays should be 2D.\n    See FluSubpopState docstring for important formatting note\n    on 2D arrays.\n\n    Note: the user does not have to specify `total_pop_age_risk` --\n    this is automatically computed when a `FluSubpopModel` is\n    instantiated. This is to ensure that the total population\n    (summed across all compartments) actually equals `total_pop_age_risk` --\n    and the user doesn't change one without updating the other.\n\n    Attributes:\n        num_age_groups (positive int):\n            number of age groups.\n        num_risk_groups (positive int):\n            number of risk groups.\n        beta_baseline (positive float): transmission rate.\n        total_pop_age_risk (np.ndarray of positive ints):\n            total number in population, summed across all\n            age-risk groups.\n        humidity_impact (positive float):\n            coefficient that determines how much absolute\n            humidity affects beta_baseline.\n        inf_induced_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of infected individuals.\n        inf_induced_immune_wane (positive float):\n            rate at which infection-induced immunity\n            against infection wanes.\n        vax_induced_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of vaccinated individuals.\n        vax_induced_immune_wane (positive float):\n            rate at which vaccine-induced immunity\n            against infection wanes.\n        inf_induced_inf_risk_reduce (positive float):\n            reduction in risk of getting infected\n            after getting infected\n        inf_induced_hosp_risk_reduce (positive float):\n            reduction in risk of hospitalization\n            after getting infected\n        inf_induced_death_risk_reduce (positive float):\n            reduction in risk of death\n            after getting infected\n        vax_induced_inf_risk_reduce (positive float):\n            reduction in risk of getting infected\n            after getting vaccinated\n        vax_induced_hosp_risk_reduce (positive float):\n            reduction in risk of hospitalization\n            after getting vaccinated\n        vax_induced_death_risk_reduce (positive float):\n            reduction in risk of death\n            after getting vaccinated\n        R_to_S_rate (positive float):\n            rate at which people in R move to S.\n        E_to_I_rate (positive float):\n            rate at which people in E move to I (both\n            IP and IA, infected pre-symptomatic and infected\n            asymptomatic)\n        IP_to_IS_rate (positive float):\n            rate a which people in IP (infected pre-symptomatic)\n            move to IS (infected symptomatic)\n        IS_to_R_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to R.\n        IA_to_R_rate (positive float):\n            rate at which people in IA (infected asymptomatic)\n            move to R\n        IS_to_H_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to H.\n        H_to_R_rate (positive float):\n            rate at which people in H move to R.\n        H_to_D_rate (positive float):\n            rate at which people in H move to D.\n        E_to_IA_prop (np.ndarray of positive floats in [0,1]):\n            proportion exposed who are asymptomatic based on\n            age-risk groups.\n        IS_to_H_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion infected who are hospitalized\n            based on age-risk groups.\n        H_to_D_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion hospitalized who die based on\n            age-risk groups.\n        IP_relative_inf (positive float):\n            relative infectiousness of pre-symptomatic to symptomatic\n            people (IP to IS compartment).\n        IA_relative_inf (positive float):\n            relative infectiousness of asymptomatic to symptomatic\n            people (IA to IS compartment).\n        relative_suscept (np.ndarray of positive floats in [0,1]):\n            relative susceptibility to infection by age group\n        mobility_modifier (np.ndarray of positive floats in [0,1]):\n            total proportion of time spent away from home by age group\n        total_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has\n        school_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at school -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n        work_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at work -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n    \"\"\"\n\n    num_age_groups: Optional[int] = None\n    num_risk_groups: Optional[int] = None\n    beta_baseline: Optional[float] = None\n    total_pop_age_risk: Optional[np.ndarray] = None\n    humidity_impact: Optional[float] = None\n\n    inf_induced_saturation: Optional[float] = None\n    inf_induced_immune_wane: Optional[float] = None\n    vax_induced_saturation: Optional[float] = None\n    vax_induced_immune_wane: Optional[float] = None\n    inf_induced_inf_risk_reduce: Optional[float] = None\n    inf_induced_hosp_risk_reduce: Optional[float] = None\n    inf_induced_death_risk_reduce: Optional[float] = None\n    vax_induced_inf_risk_reduce: Optional[float] = None\n    vax_induced_hosp_risk_reduce: Optional[float] = None\n    vax_induced_death_risk_reduce: Optional[float] = None\n\n    R_to_S_rate: Optional[float] = None\n    E_to_I_rate: Optional[float] = None\n    IP_to_IS_rate: Optional[float] = None\n    IS_to_R_rate: Optional[float] = None\n    IA_to_R_rate: Optional[float] = None\n    IS_to_H_rate: Optional[float] = None\n    H_to_R_rate: Optional[float] = None\n    H_to_D_rate: Optional[float] = None\n    E_to_IA_prop: Optional[np.ndarray] = None\n\n    IS_to_H_adjusted_prop: Optional[np.ndarray] = None\n    H_to_D_adjusted_prop: Optional[np.ndarray] = None\n\n    IP_relative_inf: Optional[float] = None\n    IA_relative_inf: Optional[float] = None\n\n    relative_suscept: Optional[np.ndarray] = None\n\n    mobility_modifier: Optional[np.ndarray] = None\n\n    total_contact_matrix: Optional[np.ndarray] = None\n    school_contact_matrix: Optional[np.ndarray] = None\n    work_contact_matrix: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopSchedules","title":"<code>FluSubpopSchedules</code>  <code>dataclass</code>","text":"<p>Data container for dataframes used to specify schedules for each <code>FluSubpopModel</code> instance.</p> <p>THE FORMAT FOR EACH DATAFRAME IS VERY IMPORTANT -- please read and implement carefully.</p> <p>Attributes:</p> Name Type Description <code>absolute_humidity</code> <code>DataFrame</code> <p>must have columns \"date\" and \"absolute_humidity\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to absolute humidity on those days</p> <code>flu_contact_matrix</code> <code>DataFrame</code> <p>must have columns \"date\", \"is_school_day\", and \"is_work_day\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> object and \"is_school_day\" and \"is_work_day\" entries are Booleans indicating if that date is a school day or work day</p> <code>daily_vaccines</code> <code>DataFrame</code> <p>must have \"date\" and \"daily_vaccines\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to historical number vaccinated on those days</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluSubpopSchedules:\n    \"\"\"\n    Data container for dataframes used to specify schedules\n    for each `FluSubpopModel` instance.\n\n    THE FORMAT FOR EACH DATAFRAME IS VERY IMPORTANT -- please\n    read and implement carefully.\n\n    Attributes:\n        absolute_humidity (pd.DataFrame):\n            must have columns \"date\" and \"absolute_humidity\" --\n            \"date\" entries must correspond to consecutive calendar days\n            and must either be strings with `\"YYYY-MM-DD\"` format or\n            `datetime.date` objects -- \"value\" entries correspond to\n            absolute humidity on those days\n        flu_contact_matrix (pd.DataFrame):\n            must have columns \"date\", \"is_school_day\", and \"is_work_day\"\n            -- \"date\" entries must correspond to consecutive calendar\n            days and must either be strings with `\"YYYY-MM-DD\"` format\n            or `datetime.date` object and \"is_school_day\" and\n            \"is_work_day\" entries are Booleans indicating if that date is\n            a school day or work day\n        daily_vaccines (pd.DataFrame):\n            must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n            correspond to consecutive calendar days and must either\n            be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n            objects -- \"value\" entries correspond to historical\n            number vaccinated on those days\n    \"\"\"\n\n    absolute_humidity: Optional[pd.DataFrame] = None\n    flu_contact_matrix: Optional[pd.DataFrame] = None\n    daily_vaccines: Optional[pd.DataFrame] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopState","title":"<code>FluSubpopState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopState</code></p> <p>Data container for pre-specified and fixed set of Compartment initial values and EpiMetric initial values for <code>FluSubpopModel</code>.</p> <p>Each field below should be A x R np.ndarray, where A is the number of age groups and R is the number of risk groups. Note: this means all arrays should be 2D. Even if there is 1 age group and 1 risk group (no group stratification), each array should be 1x1, which is two-dimensional. For example, np.array([[100]]) is correct -- np.array([100]) is wrong.</p> <p>Attributes:</p> Name Type Description <code>S</code> <code>np.ndarray of nonnegative integers</code> <p>susceptible compartment for age-risk groups -- (holds current_val of Compartment \"S\").</p> <code>E</code> <code>np.ndarray of nonnegative integers</code> <p>exposed compartment for age-risk groups -- (holds current_val of Compartment \"E\").</p> <code>IP</code> <code>np.ndarray of nonnegative integers</code> <p>infected pre-symptomatic compartment for age-risk groups (holds current_val of Compartment \"IP\").</p> <code>IS</code> <code>np.ndarray of nonnegative integers</code> <p>infected symptomatic compartment for age-risk groups (holds current_val of Compartment \"IS\").</p> <code>IA</code> <code>np.ndarray of nonnegative integers</code> <p>infected asymptomatic compartment for age-risk groups (holds current_val of Compartment \"IA\").</p> <code>H</code> <code>np.ndarray of nonnegative integers</code> <p>hospital compartment for age-risk groups (holds current_val of Compartment \"H\").</p> <code>R</code> <code>np.ndarray of nonnegative integers</code> <p>recovered compartment for age-risk groups (holds current_val of Compartment \"R\").</p> <code>D</code> <code>np.ndarray of nonnegative integers</code> <p>dead compartment for age-risk groups (holds current_val of Compartment \"D\").</p> <code>M</code> <code>np.ndarray of nonnegative floats</code> <p>infection-induced population-level immunity for age-risk groups (holds current_val of EpiMetric \"M\").</p> <code>MV</code> <code>np.ndarray of nonnegative floats</code> <p>vaccine-induced population-level immunity for age-risk groups (holds current_val of EpiMetric \"MV\").</p> <code>absolute_humidity</code> <code>positive float</code> <p>grams of water vapor per cubic meter g/m^3, used as seasonality parameter that influences transmission rate beta_baseline.</p> <code>flu_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A array, where A is the number of age groups -- element (a, a') corresponds to the number of contacts that a person in age group a has with people in age-risk group a'.</p> <code>beta_reduce</code> <code>float in [0, 1]</code> <p>starting value of DynamicVal \"beta_reduce\" on starting day of simulation -- this DynamicVal emulates a simple staged-alert policy</p> <code>daily_vaccines</code> <code>np.ndarray of positive ints</code> <p>holds current value of DailyVaccines instance, corresponding number of individuals who received influenza vaccine on that day, for given age-risk group (generally derived from historical data)</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluSubpopState(clt.SubpopState):\n    \"\"\"\n    Data container for pre-specified and fixed set of\n    Compartment initial values and EpiMetric initial values\n    for `FluSubpopModel`.\n\n    Each field below should be A x R np.ndarray, where\n    A is the number of age groups and R is the number of risk groups.\n    Note: this means all arrays should be 2D. Even if there is\n    1 age group and 1 risk group (no group stratification),\n    each array should be 1x1, which is two-dimensional.\n    For example, np.array([[100]]) is correct --\n    np.array([100]) is wrong.\n\n    Attributes:\n        S (np.ndarray of nonnegative integers):\n            susceptible compartment for age-risk groups --\n            (holds current_val of Compartment \"S\").\n        E (np.ndarray of nonnegative integers):\n            exposed compartment for age-risk groups --\n            (holds current_val of Compartment \"E\").\n        IP (np.ndarray of nonnegative integers):\n            infected pre-symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IP\").\n        IS (np.ndarray of nonnegative integers):\n            infected symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IS\").\n        IA (np.ndarray of nonnegative integers):\n            infected asymptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IA\").\n        H (np.ndarray of nonnegative integers):\n            hospital compartment for age-risk groups\n            (holds current_val of Compartment \"H\").\n        R (np.ndarray of nonnegative integers):\n            recovered compartment for age-risk groups\n            (holds current_val of Compartment \"R\").\n        D (np.ndarray of nonnegative integers):\n            dead compartment for age-risk groups\n            (holds current_val of Compartment \"D\").\n        M (np.ndarray of nonnegative floats):\n            infection-induced population-level immunity\n            for age-risk groups (holds current_val\n            of EpiMetric \"M\").\n        MV (np.ndarray of nonnegative floats):\n            vaccine-induced population-level immunity\n            for age-risk groups (holds current_val\n            of EpiMetric \"MV\").\n        absolute_humidity (positive float):\n            grams of water vapor per cubic meter g/m^3,\n            used as seasonality parameter that influences\n            transmission rate beta_baseline.\n        flu_contact_matrix (np.ndarray of positive floats):\n            A x A array, where A is the number of age\n            groups -- element (a, a') corresponds to the number\n            of contacts that a person in age group a\n            has with people in age-risk group a'.\n        beta_reduce (float in [0,1]):\n            starting value of DynamicVal \"beta_reduce\" on\n            starting day of simulation -- this DynamicVal\n            emulates a simple staged-alert policy\n        daily_vaccines (np.ndarray of positive ints):\n            holds current value of DailyVaccines instance,\n            corresponding number of individuals who received influenza\n            vaccine on that day, for given age-risk group\n            (generally derived from historical data)\n    \"\"\"\n\n    S: Optional[np.ndarray] = None\n    E: Optional[np.ndarray] = None\n    IP: Optional[np.ndarray] = None\n    IS: Optional[np.ndarray] = None\n    IA: Optional[np.ndarray] = None\n    H: Optional[np.ndarray] = None\n    R: Optional[np.ndarray] = None\n    D: Optional[np.ndarray] = None\n\n    M: Optional[np.ndarray] = None\n    MV: Optional[np.ndarray] = None\n\n    absolute_humidity: Optional[float] = None\n    flu_contact_matrix: Optional[np.ndarray] = None\n    beta_reduce: Optional[float] = 0.0\n\n    daily_vaccines: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelParamsTensors","title":"<code>FluTravelParamsTensors</code>  <code>dataclass</code>","text":"<p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from parameters on each location/subpopulation model, as well as from the metapopulation's associated <code>FluMixingParams</code> instance). Note that not all fields in <code>FluSubpopParams</code> are included -- we only include parameters needed for the travel model computation, for efficiency.</p> <p>Attributes:</p> Name Type Description <code>num_locations</code> <code>(Tensor, 0 - dimensional)</code> <p>number of locations (subpopulations) in the metapopulation model and therefore the travel model.</p> <code>travel_proportions</code> <code>Tensor</code> <p>L x L array, where L is the number of locations or subpopulations, where element i,j corresponds to the proportion of the population in location i who travels to location j (on average).</p> <p>See <code>FluSubpopParams</code> docstring for other attributes.</p> <p>Fields are analogous -- but (most) are size (L, A, R) for location-age-risk or size 0 tensors. Exceptions are <code>travel_proportions</code>, which is size (L, L), and any of the contact matrices, which are size (L, A, A).</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluTravelParamsTensors:\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays\n    that contain data across all subpopulations (collected from parameters\n    on each location/subpopulation model, as well as from the\n    metapopulation's associated `FluMixingParams` instance).\n    Note that not all fields in `FluSubpopParams` are included\n    -- we only include parameters needed for the travel model\n    computation, for efficiency.\n\n    Attributes:\n        num_locations (torch.Tensor, 0-dimensional):\n            number of locations (subpopulations) in the\n            metapopulation model and therefore the travel\n            model.\n        travel_proportions (torch.Tensor):\n            L x L array, where L is the number of locations\n            or subpopulations, where element i,j corresponds\n            to the proportion of the population in location i\n            who travels to location j (on average).\n\n    See `FluSubpopParams` docstring for other attributes.\n\n    Fields are analogous -- but (most) are size (L, A, R) for\n    location-age-risk or size 0 tensors. Exceptions are\n    `travel_proportions`, which is size (L, L),\n    and any of the contact matrices, which are size (L, A, A).\n    \"\"\"\n\n    num_locations: Optional[torch.tensor] = None\n    num_age_groups: Optional[torch.tensor] = None\n    num_risk_groups: Optional[torch.tensor] = None\n\n    travel_proportions: torch.Tensor = None\n\n    IP_relative_inf: torch.Tensor = None\n    IA_relative_inf: torch.Tensor = None\n\n    relative_suscept: torch.Tensor = None\n    mobility_modifier: torch.Tensor = None\n\n    total_contact_matrix: Optional[torch.Tensor] = None\n    school_contact_matrix: Optional[torch.Tensor] = None\n    work_contact_matrix: Optional[torch.Tensor] = None\n\n    def standardize_shapes(self) -&gt; None:\n        \"\"\"\n        If field is size (L, A, R) for location-age-risk or size 0 tensors,\n            or is not a special variable listed below, then apply dimension\n            expansion so that fields are size (L, A, R) tensors for tensor multiplication.\n\n        Exceptions are `travel_proportions`, which is size (L, L),\n        and any of the contact matrices, which are size (L, A, A).\n\n        Not all dimension combinations are considered not all make sense --\n        we assume that we only have risk IF we have age, for example.\n        \"\"\"\n\n        L = int(self.num_locations.item())\n        A = int(self.num_age_groups.item())\n        R = int(self.num_risk_groups.item())\n\n        error_str = \"Each SubpopParams field must have size (L, A, R) \" \\\n                    \"(for location-age-risk groups) or size 0 -- please check files \" \\\n                    \"and inputs, then try again.\"\n\n        for name, value in vars(self).items():\n\n            # Ignore the field that corresponds to a dictionary\n            if name == \"init_vals\":\n                continue\n\n            elif name == \"travel_proportions\":\n                if value.size() != torch.Size([L, L]):\n                    raise Exception(str(name) + error_str)\n\n            # `total_contact_matrix`, `school_contact_matrix`, `work_contact_matrix`\n            elif \"contact_matrix\" in name:\n                if value.size() == torch.Size([L, A, A]):\n                    continue\n                elif value.size() != torch.Size([A, A]):\n                    raise Exception(str(name) + error_str)\n                else:\n                    setattr(self, name, value.view(1, A, A).expand(L, A, A))\n\n            # If scalar or already L x A x R, do not need to adjust\n            #   dimensions\n            elif value.size() == torch.Size([]):\n                continue\n\n            elif value.size() == torch.Size([L, A, R]):\n                continue\n\n            elif value.size() == torch.Size([L]):\n                setattr(self, name, value.view(L, 1, 1).expand(L, A, R))\n\n            elif value.size() == torch.Size([A, R]):\n                setattr(self, name, value.view(1, A, R).expand(L, A, R))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelParamsTensors.standardize_shapes","title":"<code>standardize_shapes() -&gt; None</code>","text":"<p>If field is size (L, A, R) for location-age-risk or size 0 tensors,     or is not a special variable listed below, then apply dimension     expansion so that fields are size (L, A, R) tensors for tensor multiplication.</p> <p>Exceptions are <code>travel_proportions</code>, which is size (L, L), and any of the contact matrices, which are size (L, A, A).</p> <p>Not all dimension combinations are considered not all make sense -- we assume that we only have risk IF we have age, for example.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>def standardize_shapes(self) -&gt; None:\n    \"\"\"\n    If field is size (L, A, R) for location-age-risk or size 0 tensors,\n        or is not a special variable listed below, then apply dimension\n        expansion so that fields are size (L, A, R) tensors for tensor multiplication.\n\n    Exceptions are `travel_proportions`, which is size (L, L),\n    and any of the contact matrices, which are size (L, A, A).\n\n    Not all dimension combinations are considered not all make sense --\n    we assume that we only have risk IF we have age, for example.\n    \"\"\"\n\n    L = int(self.num_locations.item())\n    A = int(self.num_age_groups.item())\n    R = int(self.num_risk_groups.item())\n\n    error_str = \"Each SubpopParams field must have size (L, A, R) \" \\\n                \"(for location-age-risk groups) or size 0 -- please check files \" \\\n                \"and inputs, then try again.\"\n\n    for name, value in vars(self).items():\n\n        # Ignore the field that corresponds to a dictionary\n        if name == \"init_vals\":\n            continue\n\n        elif name == \"travel_proportions\":\n            if value.size() != torch.Size([L, L]):\n                raise Exception(str(name) + error_str)\n\n        # `total_contact_matrix`, `school_contact_matrix`, `work_contact_matrix`\n        elif \"contact_matrix\" in name:\n            if value.size() == torch.Size([L, A, A]):\n                continue\n            elif value.size() != torch.Size([A, A]):\n                raise Exception(str(name) + error_str)\n            else:\n                setattr(self, name, value.view(1, A, A).expand(L, A, A))\n\n        # If scalar or already L x A x R, do not need to adjust\n        #   dimensions\n        elif value.size() == torch.Size([]):\n            continue\n\n        elif value.size() == torch.Size([L, A, R]):\n            continue\n\n        elif value.size() == torch.Size([L]):\n            setattr(self, name, value.view(L, 1, 1).expand(L, A, R))\n\n        elif value.size() == torch.Size([A, R]):\n            setattr(self, name, value.view(1, A, R).expand(L, A, R))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelStateTensors","title":"<code>FluTravelStateTensors</code>  <code>dataclass</code>","text":"<p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from each location/subpopulation model). Note that not all fields in <code>FluSubpopState</code> are included -- we only include compartments needed for the travel model computation, for efficiency.</p> <p>Attributes:</p> Name Type Description <code>IP</code> <code>torch.Tensor of nonnegative integers</code> <p>presymptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IP\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>IS</code> <code>torch.Tensor of nonnegative integers</code> <p>symptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IS\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>IA</code> <code>torch.Tensor of nonnegative integers</code> <p>asymptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IA\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>H</code> <code>torch.Tensor of nonnegative integers</code> <p>hospital compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"H\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>flu_contact_matrix</code> <code>torch.Tensor of nonnegative integers</code> <p>contact matrix for location-age-risk groups -- the lth element holds current_val of <code>FluContactMatrix</code> <code>Schedule</code> for subpopulation l -- this value is a combination of the total contact matrix, the work contact matrix, and the school contact matrix (and the value is adjusted depending on whether the date is a work or school day)</p> <code>init_vals</code> <code>dict</code> <p>dictionary of torch.Tensor instances, where keys correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values correspond to their initial values for location-age-risk groups.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluTravelStateTensors:\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays\n    that contain data across all subpopulations (collected from each\n    location/subpopulation model). Note that not all fields in\n    `FluSubpopState` are included -- we only include compartments\n    needed for the travel model computation, for efficiency.\n\n    Attributes:\n        IP (torch.Tensor of nonnegative integers):\n            presymptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IP\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        IS (torch.Tensor of nonnegative integers):\n            symptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IS\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        IA (torch.Tensor of nonnegative integers):\n            asymptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IA\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        H (torch.Tensor of nonnegative integers):\n            hospital compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"H\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        flu_contact_matrix (torch.Tensor of nonnegative integers):\n            contact matrix for location-age-risk groups -- the\n            lth element holds current_val of `FluContactMatrix`\n            `Schedule` for subpopulation l -- this value is a\n            combination of the total contact matrix, the\n            work contact matrix, and the school contact matrix\n            (and the value is adjusted depending on whether\n            the date is a work or school day)\n        init_vals (dict):\n            dictionary of torch.Tensor instances, where keys\n            correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values\n            correspond to their initial values for location-age-risk\n            groups.\n    \"\"\"\n\n    IP: torch.Tensor = None\n    IS: torch.Tensor = None\n    IA: torch.Tensor = None\n    H: torch.Tensor = None\n\n    flu_contact_matrix: torch.Tensor = None\n\n    init_vals: dict = field(default_factory=dict)\n\n    # Note: `init_vals: dict = {}` does NOT work --\n    #   gives \"mutable default\" argument\n\n    def save_current_vals_as_init_vals(self):\n\n        for field in fields(self):\n            if field.name == \"init_vals\":\n                continue\n            self.init_vals[field.name] = getattr(self, field.name).clone()\n\n    def reset_to_init_vals(self):\n\n        for name, val in self.init_vals.items():\n            setattr(self, name, val.clone())\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospToDead","title":"<code>HospToDead</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"H\" to \"D\" compartment. The functional form is the same across subpopulations.</p> <p>Each HospToDead instance forms a TransitionVariableGroup with a corresponding HospToRecovered instance (these two transition variables are jointly distributed).</p> <p>The rate of HospToDead decreases as population-level immunity against hospitalization increases.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class HospToDead(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"H\" to \"D\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each HospToDead instance forms a TransitionVariableGroup with\n    a corresponding HospToRecovered instance (these two\n    transition variables are jointly distributed).\n\n    The rate of HospToDead decreases as population-level immunity\n    against hospitalization increases.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n        vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n        inf_induced_proportional_risk_reduce = \\\n            inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n        vax_induced_proportional_risk_reduce = \\\n            vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray(params.H_to_D_adjusted_prop * params.H_to_D_rate / immunity_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospToDead.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.asarray(params.H_to_D_adjusted_prop * params.H_to_D_rate / immunity_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospToRecovered","title":"<code>HospToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"H\" to \"R\" compartment. The functional form is the same across subpopulations.</p> <p>Each HospToRecovered instance forms a TransitionVariableGroup with a corresponding HospToDead instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class HospToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"H\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each HospToRecovered instance forms a TransitionVariableGroup with\n    a corresponding HospToDead instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n        vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n        inf_induced_proportional_risk_reduce = \\\n            inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n        vax_induced_proportional_risk_reduce = \\\n            vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       (1 - params.H_to_D_adjusted_prop / immunity_force) * params.H_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospToRecovered.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   (1 - params.H_to_D_adjusted_prop / immunity_force) * params.H_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.InfInducedImmunity","title":"<code>InfInducedImmunity</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for infection-induced population-level immunity.</p> <p>Population-level immunity increases as people move from \"R\" to \"S\" -- this is a design choice intended to avoid \"double-counting.\" People in \"R\" cannot be infected at all. People who move from \"R\" to \"S\" are susceptible again, but these recently-recovered people should have partial immunity. To handle this phenomenon, this epi metric increases as people move from \"R\" to \"S.\"</p> <p>Parameters:</p> Name Type Description Default <code>R_to_S</code> <code>RecoveredToSusceptible</code> <p>RecoveredToSusceptible TransitionVariable in the SubpopModel -- it is an attribute because the population-level immunity increases as people move from \"R\" to \"S\".</p> required <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class InfInducedImmunity(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for infection-induced\n    population-level immunity.\n\n    Population-level immunity increases as people move\n    from \"R\" to \"S\" -- this is a design choice intended\n    to avoid \"double-counting.\" People in \"R\" cannot be\n    infected at all. People who move from \"R\" to \"S\"\n    are susceptible again, but these recently-recovered people\n    should have partial immunity. To handle this phenomenon,\n    this epi metric increases as people move from \"R\" to \"S.\"\n\n    Params:\n        R_to_S (RecoveredToSusceptible):\n            RecoveredToSusceptible TransitionVariable\n            in the SubpopModel -- it is an attribute\n            because the population-level immunity\n            increases as people move from \"R\" to \"S\".\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self, init_val, R_to_S):\n        super().__init__(init_val)\n        self.R_to_S = R_to_S\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        # Note: the current values of transition variables already include\n        #   discretization (division by the number of timesteps) -- therefore,\n        #   we do not divide the first part of this equation by the number of\n        #   timesteps -- see `TransitionVariable` class's methods for getting\n        #   various realizations for more information\n\n        return (self.R_to_S.current_val / params.total_pop_age_risk) * \\\n               (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n               params.inf_induced_immune_wane * state.M / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.InfInducedImmunity.get_change_in_current_val","title":"<code>get_change_in_current_val(state: FluSubpopState, params: FluSubpopParams, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_change_in_current_val(self,\n                              state: FluSubpopState,\n                              params: FluSubpopParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # Note: the current values of transition variables already include\n    #   discretization (division by the number of timesteps) -- therefore,\n    #   we do not divide the first part of this equation by the number of\n    #   timesteps -- see `TransitionVariable` class's methods for getting\n    #   various realizations for more information\n\n    return (self.R_to_S.current_val / params.total_pop_age_risk) * \\\n           (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n           params.inf_induced_immune_wane * state.M / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.PresympToSymp","title":"<code>PresympToSymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IP\" to \"IS\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class PresympToSymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IP\" to \"IS\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.PresympToSymp.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.RecoveredToSusceptible","title":"<code>RecoveredToSusceptible</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"R\" to \"S\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class RecoveredToSusceptible(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"R\" to \"S\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.R_to_S_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.RecoveredToSusceptible.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.R_to_S_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SusceptibleToExposed","title":"<code>SusceptibleToExposed</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"S\" to \"E\" compartment. The functional form is the same across subpopulations.</p> <p>The rate depends on the corresponding subpopulation's contact matrix, transmission rate beta, number infected (symptomatic, asymptomatic, and pre-symptomatic), and population-level immunity against infection, among other parameters.</p> <p>This is the most complicated transition variable in the flu model. If using metapopulation model (travel model), then the rate depends on the <code>total_mixing_exposure</code> attribute, which is a function of other subpopulations' states and parameters, and travel between subpopulations.</p> <p>If there is no metapopulation model, the rate is much simpler.</p> <p>Attributes:</p> Name Type Description <code>total_mixing_exposure</code> <code>np.ndarray of positive floats</code> <p>weighted infectious count (exposure) from movement within home location, travel to other locations, and visitors from other locations</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SusceptibleToExposed(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"S\" to \"E\" compartment. The functional form is the same across\n    subpopulations.\n\n    The rate depends on the corresponding subpopulation's\n    contact matrix, transmission rate beta, number\n    infected (symptomatic, asymptomatic, and pre-symptomatic),\n    and population-level immunity against infection,\n    among other parameters.\n\n    This is the most complicated transition variable in the\n    flu model. If using metapopulation model (travel model), then\n    the rate depends on the `total_mixing_exposure` attribute,\n    which is a function of other subpopulations' states and\n    parameters, and travel between subpopulations.\n\n    If there is no metapopulation model, the rate\n    is much simpler.\n\n    Attributes:\n        total_mixing_exposure (np.ndarray of positive floats):\n            weighted infectious count (exposure) from movement\n            within home location, travel to other locations,\n            and visitors from other locations\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: clt.Compartment,\n                 destination: clt.Compartment,\n                 transition_type: clt.TransitionTypes,\n                 is_jointly_distributed: str = False):\n\n        super().__init__(origin,\n                         destination,\n                         transition_type,\n                         is_jointly_distributed)\n\n        self.total_mixing_exposure = None\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        # If `total_mixing_exposure` has not been updated,\n        #   then there is no travel model -- so, simulate\n        #   this subpopulation entirely independently and\n        #   use the simplified transition rate that does not\n        #   depend on travel dynamics\n\n        beta_adjusted = compute_beta_adjusted(state, params)\n\n        inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n        vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n        immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                        vax_induced_proportional_risk_reduce * state.MV)\n\n        if self.total_mixing_exposure is not None:\n\n            # Note here `self.total_mixing_exposure` includes\n            #   `suscept_by_age` -- see `compute_total_mixing_exposure_prop`\n            #   in `flu_travel_functions`\n\n            # Need to convert tensor into array because combining np.ndarrays and\n            #   tensors doesn't work, and everything else is an array\n            return np.asarray(beta_adjusted * self.total_mixing_exposure / immune_force)\n\n        else:\n            wtd_presymp_asymp_by_age = compute_wtd_presymp_asymp_by_age(state, params)\n\n            # Super confusing syntax... but this is the pain of having A x R,\n            #   but having the contact matrix (contact patterns) be for\n            #   ONLY age groups\n            wtd_infectious_prop = np.divide(np.sum(state.IS, axis=1, keepdims=True) + wtd_presymp_asymp_by_age,\n                                            compute_pop_by_age(params))\n\n            raw_total_exposure = np.matmul(state.flu_contact_matrix, wtd_infectious_prop)\n\n            # The total rate is only age-dependent -- it's the same rate across age groups\n            return params.relative_suscept * (beta_adjusted * raw_total_exposure / immune_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SusceptibleToExposed.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # If `total_mixing_exposure` has not been updated,\n    #   then there is no travel model -- so, simulate\n    #   this subpopulation entirely independently and\n    #   use the simplified transition rate that does not\n    #   depend on travel dynamics\n\n    beta_adjusted = compute_beta_adjusted(state, params)\n\n    inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n    vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n    immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                    vax_induced_proportional_risk_reduce * state.MV)\n\n    if self.total_mixing_exposure is not None:\n\n        # Note here `self.total_mixing_exposure` includes\n        #   `suscept_by_age` -- see `compute_total_mixing_exposure_prop`\n        #   in `flu_travel_functions`\n\n        # Need to convert tensor into array because combining np.ndarrays and\n        #   tensors doesn't work, and everything else is an array\n        return np.asarray(beta_adjusted * self.total_mixing_exposure / immune_force)\n\n    else:\n        wtd_presymp_asymp_by_age = compute_wtd_presymp_asymp_by_age(state, params)\n\n        # Super confusing syntax... but this is the pain of having A x R,\n        #   but having the contact matrix (contact patterns) be for\n        #   ONLY age groups\n        wtd_infectious_prop = np.divide(np.sum(state.IS, axis=1, keepdims=True) + wtd_presymp_asymp_by_age,\n                                        compute_pop_by_age(params))\n\n        raw_total_exposure = np.matmul(state.flu_contact_matrix, wtd_infectious_prop)\n\n        # The total rate is only age-dependent -- it's the same rate across age groups\n        return params.relative_suscept * (beta_adjusted * raw_total_exposure / immune_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympToHosp","title":"<code>SympToHosp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IS\" to \"H\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympToHosp instance forms a TransitionVariableGroup with a corresponding SympToRecovered instance (these two transition variables are jointly distributed).</p> <p>The rate of SympToHosp decreases as population-level immunity against hospitalization increases.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SympToHosp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IS\" to \"H\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympToHosp instance forms a TransitionVariableGroup with\n    a corresponding SympToRecovered instance (these two\n    transition variables are jointly distributed).\n\n    The rate of SympToHosp decreases as population-level immunity\n    against hospitalization increases.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n        vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray(params.IS_to_H_rate * params.IS_to_H_adjusted_prop / immunity_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympToHosp.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.asarray(params.IS_to_H_rate * params.IS_to_H_adjusted_prop / immunity_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympToRecovered","title":"<code>SympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IS\" to \"R\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympToRecovered instance forms a TransitionVariableGroup with a corresponding SympToHosp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SympToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IS\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympToRecovered instance forms a TransitionVariableGroup with\n    a corresponding SympToHosp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n        vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray((1 - params.IS_to_H_adjusted_prop / immunity_force) * params.IS_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympToRecovered.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.asarray((1 - params.IS_to_H_adjusted_prop / immunity_force) * params.IS_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.VaxInducedImmunity","title":"<code>VaxInducedImmunity</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for vaccine-induced population-level immunity.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class VaxInducedImmunity(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for vaccine-induced\n    population-level immunity.\n    \"\"\"\n\n    def __init__(self, init_val):\n        super().__init__(init_val)\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        # Note: `state.daily_vaccines` (based on the value of the `DailyVaccines`\n        #   `Schedule` is NOT divided by the number of timesteps -- so we need to\n        #   do this division in the equation here.\n\n        return state.daily_vaccines / (params.total_pop_age_risk * num_timesteps) - \\\n               params.vax_induced_immune_wane * state.MV / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.VaxInducedImmunity.get_change_in_current_val","title":"<code>get_change_in_current_val(state: FluSubpopState, params: FluSubpopParams, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_change_in_current_val(self,\n                              state: FluSubpopState,\n                              params: FluSubpopParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # Note: `state.daily_vaccines` (based on the value of the `DailyVaccines`\n    #   `Schedule` is NOT divided by the number of timesteps -- so we need to\n    #   do this division in the equation here.\n\n    return state.daily_vaccines / (params.total_pop_age_risk * num_timesteps) - \\\n           params.vax_induced_immune_wane * state.MV / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.accept_reject_admits","title":"<code>accept_reject_admits(metapop_model: FluMetapopModel, sampling_RNG: np.random.Generator, sampling_info: dict[str, dict[str, clt.UniformSamplingSpec]], total_daily_target_admits: list[np.ndarray], num_days: int = 50, target_accepted_reps: int = int(100.0), max_reps: int = int(1000.0), early_stop_percent: float = 0.5, target_rsquared: float = 0.75)</code>","text":"<p>Accept-reject sampler for a metapopulation model.</p> <p>This function repeatedly samples parameters from uniform distributions (as specified in <code>spec</code>) and simulates the model until the R-squared between simulated total admits and reference data exceeds <code>target_rsquared</code>. Accepted parameter sets and simulation states are saved as JSON files.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>FluMetapopModel</code> <p>The metapopulation model to simulate and sample parameters for.</p> required <code>sampling_RNG</code> <code>Generator</code> <p>Random number generator used for uniform sampling.</p> required <code>sampling_info</code> <code>dict[str, dict[str, UniformSamplingSpec]]</code> <p>See <code>clt_toolkit / sampling / sample_uniform_metapop_params / sampling_info</code> parameter for description.</p> required <code>total_daily_target_admits</code> <code>list[ndarray]</code> <p>\"Target\" time series of total admits (across subpopulations) for computing R-squared -- we would like parameters and sample paths that give simulated admits close to <code>total_daily_target_admits</code>. Must have length equal to <code>num_days</code>.</p> required <code>num_days</code> <code>int, default=50</code> <p>Total number of days to simulate for accepted parameter sets.</p> <code>50</code> <code>target_accepted_reps</code> <code>int, default=100</code> <p>Target number of accepted parameter sets (replicates) to collect.</p> <code>int(100.0)</code> <code>max_reps</code> <code>int, default=1000</code> <p>Maximum number of sampling attempts before stopping.</p> <code>int(1000.0)</code> <code>early_stop_percent</code> <code>float, default=0.5</code> <p>Fraction of <code>num_days</code> to simulate initially for early R-squared check.</p> <code>0.5</code> <code>target_rsquared</code> <code>float, default=0.75</code> <p>Minimum R-squared required between simulated and reference admits for acceptance.</p> <code>0.75</code> <p>Notes: - Early stopping is performed at <code>num_days * early_stop_percent</code> to     quickly reject poor parameter samples. - Accepted samples (and the state of the simulation at day     <code>num_days</code>) are saved to JSON files per subpopulation.     Note that for efficiency, NOT ALL PARAMETERS ARE SAVED!     Only the parameters that are randomly sampled (and thus are     different between replications). - Running this function can be slow -- test this function with a small     number of replications or simulation days to start.</p> Source code in <code>CLT_BaseModel/flu_core/flu_accept_reject.py</code> <pre><code>def accept_reject_admits(metapop_model: FluMetapopModel,\n                         sampling_RNG: np.random.Generator,\n                         sampling_info: dict[str, dict[str, clt.UniformSamplingSpec]],\n                         total_daily_target_admits: list[np.ndarray],\n                         num_days: int = 50,\n                         target_accepted_reps: int = int(1e2),\n                         max_reps: int = int(1e3),\n                         early_stop_percent: float = 0.5,\n                         target_rsquared: float = 0.75):\n    \"\"\"\n    Accept-reject sampler for a metapopulation model.\n\n    This function repeatedly samples parameters from uniform distributions\n    (as specified in `spec`) and simulates the model until the R-squared between\n    simulated total admits and reference data exceeds `target_rsquared`.\n    Accepted parameter sets and simulation states are saved as JSON files.\n\n    Parameters:\n        metapop_model (flu.FluMetapopModel):\n            The metapopulation model to simulate and sample parameters for.\n        sampling_RNG (np.random.Generator):\n            Random number generator used for uniform sampling.\n        sampling_info (dict[str, dict[str, clt.UniformSamplingSpec]]):\n            See `clt_toolkit / sampling / sample_uniform_metapop_params / sampling_info`\n            parameter for description.\n        total_daily_target_admits (list[np.ndarray]):\n            \"Target\" time series of total admits (across subpopulations)\n            for computing R-squared -- we would like parameters and\n            sample paths that give simulated admits close to\n            `total_daily_target_admits`. Must have length equal to `num_days`.\n        num_days (int, default=50):\n            Total number of days to simulate for accepted parameter sets.\n        target_accepted_reps (int, default=100):\n            Target number of accepted parameter sets (replicates) to collect.\n        max_reps (int, default=1000):\n            Maximum number of sampling attempts before stopping.\n        early_stop_percent (float, default=0.5):\n            Fraction of `num_days` to simulate initially for early R-squared check.\n        target_rsquared (float, default=0.75):\n            Minimum R-squared required between simulated and reference admits for acceptance.\n\n    Notes:\n    - Early stopping is performed at `num_days * early_stop_percent` to\n        quickly reject poor parameter samples.\n    - Accepted samples (and the state of the simulation at day\n        `num_days`) are saved to JSON files per subpopulation.\n        Note that for efficiency, NOT ALL PARAMETERS ARE SAVED!\n        Only the parameters that are randomly sampled (and thus are\n        different between replications).\n    - Running this function can be slow -- test this function with a small\n        number of replications or simulation days to start.\n    \"\"\"\n\n    if target_accepted_reps &gt; max_reps:\n        max_reps = 10 * target_accepted_reps\n\n    num_days_early_stop = int(num_days * early_stop_percent)\n\n    reps_counter = 0\n    accepted_reps_counter = 0\n\n    while reps_counter &lt; max_reps and accepted_reps_counter &lt; target_accepted_reps:\n\n        reps_counter += 1\n\n        metapop_model.reset_simulation()\n\n        param_samples = clt.sample_uniform_metapop_params(metapop_model,\n                                                          sampling_RNG,\n                                                          sampling_info)\n\n        # Save IS to H transition variable history\n        # But do not save daily (compartment) history for efficiency\n        for subpop_name, updates_dict in param_samples.items():\n            metapop_model.modify_subpop_params(subpop_name, updates_dict)\n            metapop_model.modify_simulation_settings({\"transition_variables_to_save\": [\"IS_to_H\"],\n                                                      \"save_daily_history\": False})\n\n        metapop_model.simulate_until_day(num_days_early_stop)\n        total_simulated_admits = clt.aggregate_daily_tvar_history(metapop_model, \"IS_to_H\")\n        current_rsquared = compute_rsquared(reference_timeseries=total_daily_target_admits[:num_days_early_stop],\n                                            simulated_timeseries=total_simulated_admits)\n        if current_rsquared &lt; target_rsquared:\n            continue\n\n        else:\n            metapop_model.simulate_until_day(num_days)\n            total_simulated_admits = clt.aggregate_daily_tvar_history(metapop_model, \"IS_to_H\")\n            current_rsquared = compute_rsquared(reference_timeseries=total_daily_target_admits,\n                                                simulated_timeseries=total_simulated_admits)\n            if current_rsquared &lt; target_rsquared:\n                continue\n            else:\n                accepted_reps_counter += 1\n\n                for subpop_name, subpop in metapop_model.subpop_models.items():\n                    with open(\"subpop_\" + str(subpop_name) + \"_rep_\" + str(accepted_reps_counter) +\n                              \"_accepted_sample_params.json\", \"w\") as f:\n                        json.dump(clt.serialize_dataclass(param_samples[subpop_name]), f, indent=4)\n                    with open(\"subpop_\" + str(subpop_name) + \"_rep_\" + str(accepted_reps_counter) +\n                              \"_accepted_state.json\", \"w\") as f:\n                        json.dump(clt.serialize_dataclass(subpop.state), f, indent=4)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.advance_timestep","title":"<code>advance_timestep(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float, save_calibration_targets: bool = False, save_tvar_history: bool = False) -&gt; Tuple[FluFullMetapopStateTensors, dict, dict]</code>","text":"<p>Advance the simulation one timestep, with length <code>dt</code>. Updates state corresponding to compartments and epidemiological metrics after computing transition variables and metric changes.</p> <p>Note that in this torch \"mean\" deterministic implementation... - We compute rates in the same way as the     <code>get_binom_deterministic_no_round</code>     transition type in the OOP code -- see     <code>TransitionVariables</code> class in     <code>clt_toolkit / base_components</code> for more details. - We also implement a \"mean\" deterministic analog     of the multinomial distribution to handle     multiple outflows from the same compartment - We do not round the transition variables - We also use <code>softplus</code>, a smooth approximation to the     ReLU function, to ensure that compartments are     nonnegative (which is not guaranteed using     the mean of a binomial/multinomial random variable     rather than sampling from those distributions).</p> <p>Returns:</p> Type Description <code>Tuple[FluFullMetapopStateTensors, dict, dict]</code> <p>New <code>FluFullMetapopStateTensors</code> with updated state, <code>dict</code> of calibration targets corresponding to state values or transition variable values used for calibration, and <code>dict</code> of transition variable values to save this history. If <code>save_calibration_targets</code> is <code>False</code>, then the corresponding <code>dict</code> is empty, and similarly with <code>save_tvar_history</code>.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def advance_timestep(state: FluFullMetapopStateTensors,\n                     params: FluFullMetapopParamsTensors,\n                     precomputed: FluPrecomputedTensors,\n                     dt: float,\n                     save_calibration_targets: bool=False,\n                     save_tvar_history: bool=False) -&gt; Tuple[FluFullMetapopStateTensors, dict, dict]:\n    \"\"\"\n    Advance the simulation one timestep, with length `dt`.\n    Updates state corresponding to compartments and\n    epidemiological metrics after computing transition variables\n    and metric changes.\n\n    Note that in this torch \"mean\" deterministic implementation...\n    - We compute rates in the same way as the\n        `get_binom_deterministic_no_round`\n        transition type in the OOP code -- see\n        `TransitionVariables` class in\n        `clt_toolkit / base_components` for more details.\n    - We also implement a \"mean\" deterministic analog\n        of the multinomial distribution to handle\n        multiple outflows from the same compartment\n    - We do not round the transition variables\n    - We also use `softplus`, a smooth approximation to the\n        ReLU function, to ensure that compartments are\n        nonnegative (which is not guaranteed using\n        the mean of a binomial/multinomial random variable\n        rather than sampling from those distributions).\n\n    Returns:\n        (Tuple[FluFullMetapopStateTensors, dict, dict]):\n            New `FluFullMetapopStateTensors` with updated state,\n            `dict` of calibration targets corresponding to state\n            values or transition variable values used for calibration,\n            and `dict` of transition variable values to save this\n            history. If `save_calibration_targets` is `False`,\n            then the corresponding `dict` is empty, and similarly with\n            `save_tvar_history`.\n    \"\"\"\n\n    S_to_E = compute_S_to_E(state, params, precomputed, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    E_to_IP_rate = compute_E_to_IP_rate(params)\n    E_to_IA_rate = compute_E_to_IA_rate(params)\n    E_outgoing_total_rate = E_to_IP_rate + E_to_IA_rate\n    E_to_IA = state.E * (E_to_IA_rate / E_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(E_outgoing_total_rate, dt)\n    E_to_IP = state.E * (E_to_IP_rate / E_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(E_outgoing_total_rate, dt)\n\n    IA_to_R = compute_IA_to_R(state, params, dt)\n\n    IP_to_IS = compute_IP_to_IS(state, params, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    IS_to_R_rate = compute_IS_to_R_rate(state, params)\n    IS_to_H_rate = compute_IS_to_H_rate(state, params)\n    IS_outgoing_total_rate = IS_to_R_rate + IS_to_H_rate\n    IS_to_R = state.IS * (IS_to_R_rate / IS_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(IS_outgoing_total_rate, dt)\n    IS_to_H = state.IS * (IS_to_H_rate / IS_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(IS_outgoing_total_rate, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    H_to_R_rate = compute_H_to_R_rate(state, params)\n    H_to_D_rate = compute_H_to_D_rate(state, params)\n    H_outgoing_total_rate = H_to_R_rate + H_to_D_rate\n    H_to_R = state.H * (H_to_R_rate / H_outgoing_total_rate) * torch_approx_binom_probability_from_rate(\n        H_outgoing_total_rate, dt)\n    H_to_D = state.H * (H_to_D_rate / H_outgoing_total_rate) * torch_approx_binom_probability_from_rate(\n        H_outgoing_total_rate, dt)\n\n    R_to_S = compute_R_to_S(state, params, dt)\n\n    # Make sure compartments are nonnegative\n    S_new = torch.nn.functional.softplus(state.S + R_to_S - S_to_E)\n    E_new = torch.nn.functional.softplus(state.E + S_to_E - E_to_IP - E_to_IA)\n    IP_new = torch.nn.functional.softplus(state.IP + E_to_IP - IP_to_IS)\n    IS_new = torch.nn.functional.softplus(state.IS + IP_to_IS - IS_to_R - IS_to_H)\n    IA_new = torch.nn.functional.softplus(state.IA + E_to_IA - IA_to_R)\n    H_new = torch.nn.functional.softplus(state.H + IS_to_H - H_to_R - H_to_D)\n    R_new = torch.nn.functional.softplus(state.R + IS_to_R + IA_to_R + H_to_R - R_to_S)\n    D_new = torch.nn.functional.softplus(state.D + H_to_D)\n\n    # Update immunity variables\n    M_change = compute_M_change(state, params, precomputed, dt)\n    MV_change = compute_MV_change(state, params, precomputed, dt)\n    M_new = state.M + M_change\n    MV_new = state.MV + MV_change\n\n    state_new = FluFullMetapopStateTensors(S=S_new,\n                                           E=E_new,\n                                           IP=IP_new,\n                                           IS=IS_new,\n                                           IA=IA_new,\n                                           H=H_new,\n                                           R=R_new,\n                                           D=D_new,\n                                           M=M_new,\n                                           MV=MV_new,\n                                           absolute_humidity=state.absolute_humidity,\n                                           daily_vaccines=state.daily_vaccines,\n                                           flu_contact_matrix=state.flu_contact_matrix)\n\n    calibration_targets = {}\n    if save_calibration_targets:\n        calibration_targets[\"IS_to_H\"] = IS_to_H\n\n    transition_variables = {}\n    if save_tvar_history:\n        transition_variables[\"S_to_E\"] = S_to_E\n        transition_variables[\"E_to_IP\"] = E_to_IP\n        transition_variables[\"E_to_IA\"] = E_to_IA\n        transition_variables[\"IA_to_R\"] = IA_to_R\n        transition_variables[\"IP_to_IS\"] = IP_to_IS\n        transition_variables[\"IS_to_R\"] = IS_to_R\n        transition_variables[\"IS_to_H\"] = IS_to_H\n        transition_variables[\"H_to_R\"] = H_to_R\n        transition_variables[\"H_to_D\"] = H_to_D\n        transition_variables[\"R_to_S\"] = R_to_S\n        transition_variables[\"M_change\"] = M_change\n        transition_variables[\"MV_change\"] = MV_change\n\n    return state_new, calibration_targets, transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_E_to_IA_rate","title":"<code>compute_E_to_IA_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_E_to_IA_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    return params.E_to_I_rate * params.E_to_IA_prop\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_E_to_IP_rate","title":"<code>compute_E_to_IP_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_E_to_IP_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    return params.E_to_I_rate * (1 - params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_H_to_D_rate","title":"<code>compute_H_to_D_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_H_to_D_rate(state: FluFullMetapopStateTensors,\n                        params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.H_to_D_rate * params.H_to_D_adjusted_prop / immunity_force\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_H_to_R_rate","title":"<code>compute_H_to_R_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_H_to_R_rate(state: FluFullMetapopStateTensors,\n                        params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.H_to_R_rate * (1 - params.H_to_D_adjusted_prop / immunity_force)\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IA_to_R","title":"<code>compute_IA_to_R(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IA_to_R(state: FluFullMetapopStateTensors,\n                    params: FluFullMetapopParamsTensors,\n                    dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.IA_to_R_rate\n\n    IA_to_R = state.IA * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return IA_to_R\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IP_to_IS","title":"<code>compute_IP_to_IS(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IP_to_IS(state: FluFullMetapopStateTensors,\n                     params: FluFullMetapopParamsTensors,\n                     dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.IP_to_IS_rate\n\n    IP_to_IS = state.IP * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return IP_to_IS\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IS_to_H_rate","title":"<code>compute_IS_to_H_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IS_to_H_rate(state: FluFullMetapopStateTensors,\n                         params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.IS_to_H_rate * params.IS_to_H_adjusted_prop / immunity_force\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IS_to_R_rate","title":"<code>compute_IS_to_R_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IS_to_R_rate(state: FluFullMetapopStateTensors,\n                         params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.IS_to_R_rate * (1 - params.IS_to_H_adjusted_prop / immunity_force)\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_MV_change","title":"<code>compute_MV_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_MV_change(state: FluFullMetapopStateTensors,\n                      params: FluFullMetapopParamsTensors,\n                      precomputed: FluPrecomputedTensors,\n                      dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    MV_change = state.daily_vaccines / precomputed.total_pop_LAR_tensor - \\\n                params.vax_induced_immune_wane * state.MV\n\n    return MV_change * dt\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_M_change","title":"<code>compute_M_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_M_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors,\n                     precomputed: FluPrecomputedTensors,\n                     dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    # Note: already includes dt\n    R_to_S = state.R * torch_approx_binom_probability_from_rate(params.R_to_S_rate, dt)\n\n    M_change = (R_to_S / precomputed.total_pop_LAR_tensor) * \\\n               (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n               params.inf_induced_immune_wane * state.M * dt\n\n    # Because R_to_S includes dt already, we do not return M_change * dt -- we only multiply\n    #   the last term in the expression above by dt\n    return M_change\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_R_to_S","title":"<code>compute_R_to_S(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_R_to_S(state: FluFullMetapopStateTensors,\n                   params: FluFullMetapopParamsTensors,\n                   dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.R_to_S_rate\n\n    R_to_S = state.R * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return R_to_S\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_S_to_E","title":"<code>compute_S_to_E(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_S_to_E(state: FluFullMetapopStateTensors,\n                   params: FluFullMetapopParamsTensors,\n                   precomputed: FluPrecomputedTensors,\n                   dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    # Needs flu_contact_matrix to be in state for this\n    total_mixing_exposure = compute_total_mixing_exposure(state, params, precomputed)\n\n    if total_mixing_exposure.size() != torch.Size([precomputed.L,\n                                                   precomputed.A,\n                                                   precomputed.R]):\n        raise Exception(\"force_of_infection must be L x A x R corresponding \\n\"\n                        \"to number of locations (subpopulations), age groups, \\n\"\n                        \"and risk groups.\")\n\n    beta_adjusted = compute_beta_adjusted(state, params)\n\n    inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n    vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n    immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                    vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = beta_adjusted * total_mixing_exposure / immune_force\n\n    S_to_E = state.S * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return S_to_E\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_active_pop_LAR","title":"<code>compute_active_pop_LAR(state: FluTravelStateTensors, _params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Compute the active population for location-age-risk (l, a, r) as a tensor. Used to compute the effective population in the travel model, which is the population size adjusted for incoming visitors, residents traveling, and assuming hospitalized individuals are not mobile enough to infect others.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A, R): Active population: those who are not hospitalized (i.e. those who are not too sick to move and travel regularly)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_active_pop_LAR(state: FluTravelStateTensors,\n                           _params: FluTravelParamsTensors,\n                           precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Compute the active population for location-age-risk\n    (l, a, r) as a tensor. Used to compute the\n    effective population in the travel model, which is\n    the population size adjusted for incoming visitors,\n    residents traveling, and assuming hospitalized\n    individuals are not mobile enough to infect others.\n\n    Returns:\n        torch.Tensor of size (L, A, R):\n            Active population: those who are not\n            hospitalized (i.e. those who are not too sick\n            to move and travel regularly)\n    \"\"\"\n\n    # _params is not used now -- but this is included for\n    #   function signature consistency with other\n    #   similar computation functions\n\n    return precomputed.total_pop_LAR_tensor - state.H\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_beta_adjusted","title":"<code>compute_beta_adjusted(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Computes beta-adjusted humidity.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_beta_adjusted(state: FluFullMetapopStateTensors,\n                          params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Computes beta-adjusted humidity.\n\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    absolute_humidity = state.absolute_humidity\n    beta_adjusted = params.beta_baseline * (1 + params.humidity_impact * np.exp(-180 * absolute_humidity))\n\n    return beta_adjusted\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_effective_pop_LA","title":"<code>compute_effective_pop_LA(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A): Effective population, summed over risk groups. See <code>compute_active_pop_LAR</code> docstring for more information.</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_effective_pop_LA(state: FluTravelStateTensors,\n                             params: FluTravelParamsTensors,\n                             precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, A):\n            Effective population, summed over risk groups.\n            See `compute_active_pop_LAR` docstring for more\n            information.\n    \"\"\"\n\n    active_pop_LAR = compute_active_pop_LAR(state, params, precomputed)\n\n    # Nonlocal travel proportions is L x L\n    # Active population LAR is L x A x R\n    outside_visitors_LAR = torch.einsum(\"kl,kar-&gt;lar\",\n                                        precomputed.nonlocal_travel_prop,\n                                        active_pop_LAR)\n\n    # This is correct -- Dave checked in meeting -- we don't need Einstein\n    #   notation here!\n    # In computation, broadcast sum_residents_nonlocal_travel_prop to be L x 1 x 1\n    traveling_residents_LAR = precomputed.sum_residents_nonlocal_travel_prop[:, None, None] * \\\n                              active_pop_LAR\n\n    mobility_modifier = params.mobility_modifier[0, :, 0]\n\n    effective_pop_LA = precomputed.total_pop_LA + mobility_modifier * \\\n                       torch.sum(outside_visitors_LAR + traveling_residents_LAR, dim=2)\n\n    return effective_pop_LA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_flu_contact_matrix","title":"<code>compute_flu_contact_matrix(params: FluFullMetapopParamsTensors, schedules: FluFullMetapopScheduleTensors, day_counter: int) -&gt; torch.Tensor</code>","text":"<p>Computes flu model contact matrix in tensor format -- makes adjustments based on whether day is school day or work day.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, A))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_flu_contact_matrix(params: FluFullMetapopParamsTensors,\n                               schedules: FluFullMetapopScheduleTensors,\n                               day_counter: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes flu model contact matrix in tensor format -- makes\n    adjustments based on whether day is school day or work day.\n\n    Returns:\n        (torch.Tensor of size (L, A, A))\n    \"\"\"\n\n    # Here, using schedules.is_school_day[day_counter][:,:,0] and similarly for\n    #   is_work_day because each contact matrix (as a metapop tensor) is L x A x A --\n    #   we don't use risk -- assume here that we do not have a different school/work-day\n    #   schedule based on risk, so just grab the first risk group\n    # But then we have to take (1 - schedules.is_school_day[day_counter][:, :, 0]), which is\n    #   L x A, and then make it L x A x 1 (unsqueeze the last dimension) to make the\n    #   broadcasting work (because this gets element-wise multiplied by params.school_contact_matrix)\n    flu_contact_matrix = \\\n        params.total_contact_matrix - \\\n        params.school_contact_matrix * (1 - schedules.is_school_day[day_counter][:, :, 0]).unsqueeze(dim=2) - \\\n        params.work_contact_matrix * (1 - schedules.is_work_day[day_counter][:, :, 0]).unsqueeze(dim=2)\n\n    return flu_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_local_to_local_exposure","title":"<code>compute_local_to_local_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, sum_residents_nonlocal_travel_prop: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, location_ix: int) -&gt; torch.Tensor</code>","text":"<p>Raw means that this is unnormalized by <code>relative_suscept</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A): For a given location (specified by <code>location_ix</code>), compute local transmission caused by residents traveling within their home location, summed over risk groups.</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_local_to_local_exposure(flu_contact_matrix: torch.Tensor,\n                                    mobility_modifier: torch.Tensor,\n                                    sum_residents_nonlocal_travel_prop: torch.Tensor,\n                                    wtd_infectious_ratio_LLA: torch.Tensor,\n                                    location_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Raw means that this is unnormalized by `relative_suscept`.\n    Excludes beta and population-level immunity adjustments --\n    those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A):\n            For a given location (specified by `location_ix`), compute\n            local transmission caused by residents traveling within their\n            home location, summed over risk groups.\n    \"\"\"\n\n    # WARNING: we assume `mobility_modifier` is input as (A, 1) --\n    # if this changes, we have to change the implementation.\n    # The risk dimension does not have unique values, so we just\n    # grab the first element of the risk dimension.\n    mobility_modifier = mobility_modifier[location_ix, :, 0]\n\n    result = (1 - mobility_modifier * sum_residents_nonlocal_travel_prop[location_ix]) * \\\n             torch.matmul(flu_contact_matrix[location_ix, :, :],\n                          wtd_infectious_ratio_LLA[location_ix, location_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_outside_visitors_exposure","title":"<code>compute_outside_visitors_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, travel_proportions: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, local_ix: int, visitors_ix: int) -&gt; torch.Tensor</code>","text":"<p>Computes raw (unnormalized by <code>relative_suscept</code>) transmission to <code>local_ix</code> due to outside visitors from <code>visitors_ix</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_outside_visitors_exposure(flu_contact_matrix: torch.Tensor,\n                                      mobility_modifier: torch.Tensor,\n                                      travel_proportions: torch.Tensor,\n                                      wtd_infectious_ratio_LLA: torch.Tensor,\n                                      local_ix: int,\n                                      visitors_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes raw (unnormalized by `relative_suscept`) transmission\n    to `local_ix` due to outside visitors from `visitors_ix`.\n    Excludes beta and population-level immunity adjustments --\n    those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A)\n    \"\"\"\n\n    # In location `local_ix`, we are looking at the visitors from\n    #   `visitors_ix` who come to `local_ix` (and infect folks in `local_ix`)\n\n    # See WARNING in `compute_local_to_local_exposure()`\n    mobility_modifier = mobility_modifier[visitors_ix, :, 0]\n\n    result = travel_proportions[visitors_ix, local_ix] * \\\n             torch.matmul(mobility_modifier * flu_contact_matrix[local_ix, :, :],\n                          wtd_infectious_ratio_LLA[visitors_ix, local_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_pop_by_age","title":"<code>compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A x 1 array -- where A is the number of age groups -- where ith element corresponds to total population (across all compartments, including \"D\", and across all risk groups) in age group i</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray:\n            A x 1 array -- where A is the number of age groups --\n            where ith element corresponds to total population\n            (across all compartments, including \"D\", and across all risk groups)\n            in age group i\n    \"\"\"\n\n    return np.sum(subpop_params.total_pop_age_risk, axis=1, keepdims=True)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_residents_traveling_exposure","title":"<code>compute_residents_traveling_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, travel_proportions: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, local_ix: int, dest_ix: int) -&gt; torch.Tensor</code>","text":"<p>Computes raw (unnormalized by <code>relative_suscept</code>) transmission to <code>local_ix</code>, due to residents of <code>local_ix</code> traveling to <code>dest_ix</code> and getting infected in <code>dest_ix</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_residents_traveling_exposure(flu_contact_matrix: torch.Tensor,\n                                         mobility_modifier: torch.Tensor,\n                                         travel_proportions: torch.Tensor,\n                                         wtd_infectious_ratio_LLA: torch.Tensor,\n                                         local_ix: int,\n                                         dest_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes raw (unnormalized by `relative_suscept`) transmission\n    to `local_ix`, due to residents of `local_ix` traveling to `dest_ix`\n    and getting infected in `dest_ix`. Excludes beta and population-level\n    immunity adjustments -- those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A)\n    \"\"\"\n\n    # See WARNING in `compute_local_to_local_exposure()`\n    mobility_modifier = mobility_modifier[local_ix, :, 0]\n\n    result = mobility_modifier * travel_proportions[local_ix, dest_ix] * \\\n             torch.matmul(flu_contact_matrix[local_ix, :, :],\n                          wtd_infectious_ratio_LLA[dest_ix, dest_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_rsquared","title":"<code>compute_rsquared(reference_timeseries: list[np.ndarray], simulated_timeseries: list[np.ndarray]) -&gt; float</code>","text":"Source code in <code>CLT_BaseModel/flu_core/flu_accept_reject.py</code> <pre><code>def compute_rsquared(reference_timeseries: list[np.ndarray],\n                     simulated_timeseries: list[np.ndarray]) -&gt; float:\n    if len(reference_timeseries) != len(simulated_timeseries):\n        raise ValueError(\"Reference time series and simulated time series \\n\"\n                         \"must have same length.\")\n\n    reference_timeseries = np.asarray(reference_timeseries)\n    simulated_timeseries = np.asarray(simulated_timeseries)\n\n    ybar = reference_timeseries.mean(axis=0)\n\n    ss_residual = np.sum(np.square(simulated_timeseries - reference_timeseries))\n    ss_total = np.sum(np.square(reference_timeseries - ybar))\n\n    return 1 - ss_residual / ss_total\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_total_mixing_exposure","title":"<code>compute_total_mixing_exposure(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Computes \"total mixing exposure\" for location-age-risk (l, a, r) -- the rate of exposure to infectious individuals, accounting for both local transmission, incoming visitors, and residents traveling. Normalized by <code>relative_suscept</code>!</p> <p>Combines subroutines <code>compute_local_to_local_exposure()</code>, <code>compute_outside_visitors_exposure()</code>, and <code>compute_residents_traveling_exposure()</code>. Note that these subroutines do not include relative susceptibility -- but this function includes relative susceptibility -- this is to avoid unnecessary repeated multiplication by relative susceptible in each subroutine.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_total_mixing_exposure(state: FluTravelStateTensors,\n                                  params: FluTravelParamsTensors,\n                                  precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Computes \"total mixing exposure\" for location-age-risk\n    (l, a, r) -- the rate of exposure to infectious individuals,\n    accounting for both local transmission, incoming visitors, and\n    residents traveling. **Normalized by `relative_suscept`!**\n\n    Combines subroutines `compute_local_to_local_exposure()`,\n    `compute_outside_visitors_exposure()`, and `compute_residents_traveling_exposure()`.\n    Note that these subroutines do not include relative susceptibility --\n    but this function includes relative susceptibility -- this is to avoid\n    unnecessary repeated multiplication by relative susceptible in each subroutine.\n\n    Returns:\n        torch.Tensor of size (L, A, R)\n    \"\"\"\n\n    L, A, R = precomputed.L, precomputed.A, precomputed.R\n\n    mobility_modifier = params.mobility_modifier\n    flu_contact_matrix = state.flu_contact_matrix\n    travel_proportions = params.travel_proportions\n    sum_residents_nonlocal_travel_prop = precomputed.sum_residents_nonlocal_travel_prop\n    wtd_infectious_ratio_LLA = compute_wtd_infectious_ratio_LLA(state, params, precomputed)\n\n    relative_suscept = params.relative_suscept[0, :, 0]\n\n    total_mixing_exposure = torch.tensor(np.zeros((L, A, R)))\n\n    # Couldn't figure out how to do this without two for-loops ;)\n    # Welcoming any efficiency improvements!\n    for l in np.arange(L):\n\n        raw_total_mixing_exposure = torch.tensor(np.zeros(A))\n\n        raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                    compute_local_to_local_exposure(flu_contact_matrix,\n                                                                    mobility_modifier,\n                                                                    sum_residents_nonlocal_travel_prop,\n                                                                    wtd_infectious_ratio_LLA,\n                                                                    l)\n\n        for k in np.arange(L):\n            raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                        compute_outside_visitors_exposure(\n                                            flu_contact_matrix,\n                                            mobility_modifier,\n                                            travel_proportions,\n                                            wtd_infectious_ratio_LLA,\n                                            l,\n                                            k)\n\n            raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                        compute_residents_traveling_exposure(\n                                            flu_contact_matrix,\n                                            mobility_modifier,\n                                            travel_proportions,\n                                            wtd_infectious_ratio_LLA,\n                                            l,\n                                            k)\n\n        normalized_total_mixing_exposure = relative_suscept * raw_total_mixing_exposure\n\n        total_mixing_exposure[l, :, :] = normalized_total_mixing_exposure.view(A, 1).expand((A, R))\n\n    return total_mixing_exposure\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_infectious_LA","title":"<code>compute_wtd_infectious_LA(state: FluTravelStateTensors, params: FluTravelParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A): Weighted infectious, summed over risk groups: includes presymptomatic, asymptomatic, and symptomatic, weighted by relative infectiousness</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_wtd_infectious_LA(state: FluTravelStateTensors,\n                              params: FluTravelParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, A):\n            Weighted infectious, summed over risk groups:\n            includes presymptomatic, asymptomatic, and symptomatic,\n            weighted by relative infectiousness\n    \"\"\"\n\n    # Einstein notation here means sum over risk groups\n    IS = torch.einsum(\"lar-&gt;la\", state.IS)\n    wtd_IP = \\\n        params.IP_relative_inf * torch.einsum(\"lar-&gt;la\", state.IP)\n    wtd_IA = \\\n        params.IA_relative_inf * torch.einsum(\"lar-&gt;la\", state.IA)\n\n    return IS + wtd_IP + wtd_IA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_infectious_ratio_LLA","title":"<code>compute_wtd_infectious_ratio_LLA(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, L, A): Element i,j,a corresponds to ratio of weighted infectious people in location i, age group a (summed over risk groups) to the effective population in location j (summed over risk groups)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_wtd_infectious_ratio_LLA(state: FluTravelStateTensors,\n                                     params: FluTravelParamsTensors,\n                                     precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, L, A):\n            Element i,j,a corresponds to ratio of weighted infectious people\n            in location i, age group a (summed over risk groups) to the effective\n            population in location j (summed over risk groups)\n    \"\"\"\n\n    wtd_infectious_LA = compute_wtd_infectious_LA(state, params)\n\n    effective_pop_LA = compute_effective_pop_LA(state, params, precomputed)\n\n    prop_wtd_infectious = torch.einsum(\"ka,la-&gt;kla\",\n                                       wtd_infectious_LA,\n                                       1 / effective_pop_LA)\n\n    return prop_wtd_infectious\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_presymp_asymp_by_age","title":"<code>compute_wtd_presymp_asymp_by_age(subpop_state: FluSubpopState, subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns weighted sum of IP and IA compartment for     subpopulation with given state and parameters.     IP and IA are weighted by their relative infectiousness     respectively, and then summed over risk groups.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_wtd_presymp_asymp_by_age(subpop_state: FluSubpopState,\n                                     subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns weighted sum of IP and IA compartment for\n        subpopulation with given state and parameters.\n        IP and IA are weighted by their relative infectiousness\n        respectively, and then summed over risk groups.\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # sum over risk groups\n    wtd_IP = \\\n        subpop_params.IP_relative_inf * np.sum(subpop_state.IP, axis=1, keepdims=True)\n    wtd_IA = \\\n        subpop_params.IA_relative_inf * np.sum(subpop_state.IA, axis=1, keepdims=True)\n\n    return wtd_IP + wtd_IA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.create_dict_of_tensors","title":"<code>create_dict_of_tensors(d: dict, requires_grad: bool = True) -&gt; dict</code>","text":"<p>Converts dictionary entries to <code>tensor</code> (of type <code>torch.float32</code>) and if <code>requires_grad</code> is <code>True</code>, turns on gradient tracking for each entry -- returns new dictionary.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def create_dict_of_tensors(d: dict,\n                           requires_grad: bool = True) -&gt; dict:\n    \"\"\"\n    Converts dictionary entries to `tensor` (of type `torch.float32`)\n    and if `requires_grad` is `True`, turns on gradient tracking for\n    each entry -- returns new dictionary.\n    \"\"\"\n\n    def to_tensor(k, v):\n        if v is None:\n            return None\n        else:\n            return torch.tensor(v, dtype=torch.float32, requires_grad=requires_grad)\n\n    return {k: to_tensor(k, v) for k, v in d.items()}\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_approx_binom_probability_from_rate","title":"<code>torch_approx_binom_probability_from_rate(rate, dt)</code>","text":"<p>Torch-compatible implementation of converting a rate into a probability. See analogous numpy implementation <code>base_components/approx_binom_probability_from_rate()</code> docstring for details.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_approx_binom_probability_from_rate(rate, dt):\n    \"\"\"\n    Torch-compatible implementation of converting a\n    rate into a probability. See analogous numpy implementation\n    `base_components/approx_binom_probability_from_rate()` docstring\n    for details.\n    \"\"\"\n\n    return 1 - torch.exp(-rate * dt)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_simulate_full_history","title":"<code>torch_simulate_full_history(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, schedules: FluFullMetapopScheduleTensors, num_days: int, timesteps_per_day: int) -&gt; Tuple[dict, dict]</code>","text":"<p>Simulates the flu model with a differentiable torch implementation that carries out <code>binom_deterministic_no_round</code> transition types -- returns hospital admits for calibration use.</p> <p>See subroutine <code>advance_timestep</code> for additional details.</p> <p>Returns:</p> Type Description <code>Tuple[dict, dict]</code> <p>Returns hospital admits (the IS to H transition variable value) for day, location, age, risk, in tensor format.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_simulate_full_history(state: FluFullMetapopStateTensors,\n                                params: FluFullMetapopParamsTensors,\n                                precomputed: FluPrecomputedTensors,\n                                schedules: FluFullMetapopScheduleTensors,\n                                num_days: int,\n                                timesteps_per_day: int) -&gt; Tuple[dict, dict]:\n    \"\"\"\n    Simulates the flu model with a differentiable torch implementation\n    that carries out `binom_deterministic_no_round` transition types --\n    returns hospital admits for calibration use.\n\n    See subroutine `advance_timestep` for additional details.\n\n    Returns:\n        (Tuple[dict, dict]):\n            Returns hospital admits (the IS to H transition variable value)\n            for day, location, age, risk, in tensor format.\n    \"\"\"\n\n    dt = 1 / float(timesteps_per_day)\n\n    state_history_dict = defaultdict(list)\n    tvar_history_dict = defaultdict(list)\n\n    # This could probably be written better so we don't have\n    #   unused variables \"_\" that grab `advance_timestep` output?\n\n    for day in range(num_days):\n        state = update_state_with_schedules(state, params, schedules, day)\n\n        for timestep in range(timesteps_per_day):\n            if timestep == timesteps_per_day-1:\n                state, _, tvar_history = \\\n                    advance_timestep(state, params, precomputed, dt, save_tvar_history=True)\n                for key in tvar_history:\n                    tvar_history_dict[key].append(tvar_history[key])\n            else:\n                state, _, _ = \\\n                    advance_timestep(state, params, precomputed, dt, save_tvar_history=False)\n\n        for field in fields(state):\n            if field.name == \"init_vals\":\n                continue\n            state_history_dict[str(field.name)].append(getattr(state, field.name).clone())\n\n    return state_history_dict, tvar_history_dict\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_simulate_hospital_admits","title":"<code>torch_simulate_hospital_admits(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, schedules: FluFullMetapopScheduleTensors, num_days: int, timesteps_per_day: int) -&gt; torch.Tensor</code>","text":"<p>Analogous to <code>torch_simulate_full_history</code> but only saves and returns hospital admits for calibration use.</p> <p>Returns:</p> Type Description <code>torch.Tensor of size (num_days, L, A, R)</code> <p>Returns hospital admits (the IS to H transition variable value) for day, location, age, risk, in tensor format.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_simulate_hospital_admits(state: FluFullMetapopStateTensors,\n                                     params: FluFullMetapopParamsTensors,\n                                     precomputed: FluPrecomputedTensors,\n                                     schedules: FluFullMetapopScheduleTensors,\n                                     num_days: int,\n                                     timesteps_per_day: int) -&gt; torch.Tensor:\n    \"\"\"\n    Analogous to `torch_simulate_full_history` but only saves and\n    returns hospital admits for calibration use.\n\n    Returns:\n        (torch.Tensor of size (num_days, L, A, R)):\n            Returns hospital admits (the IS to H transition variable value)\n            for day, location, age, risk, in tensor format.\n    \"\"\"\n\n    hospital_admits_history = []\n\n    dt = 1 / float(timesteps_per_day)\n\n    for day in range(num_days):\n        state = update_state_with_schedules(state, params, schedules, day)\n        for timestep in range(timesteps_per_day):\n            state, calibration_targets, _ = advance_timestep(state, params, precomputed, day, dt)\n        hospital_admits_history.append(calibration_targets[\"IS_to_H\"].clone())\n\n    return torch.stack(hospital_admits_history)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.update_state_with_schedules","title":"<code>update_state_with_schedules(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, schedules: FluFullMetapopScheduleTensors, day_counter: int) -&gt; FluFullMetapopStateTensors</code>","text":"<p>Returns new dataclass formed by copying the current <code>state</code> and updating specific values according to <code>schedules</code> and the simulation's current <code>day_counter</code>.</p> <p>Returns:</p> Type Description <code>FluFullMetapopStateTensors</code> <p>New state with updated schedule-related values:   - <code>flu_contact_matrix</code>   - <code>absolute_humidity</code>   - <code>daily_vaccines</code> All other fields remain unchanged from the input <code>state</code>.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def update_state_with_schedules(state: FluFullMetapopStateTensors,\n                                params: FluFullMetapopParamsTensors,\n                                schedules: FluFullMetapopScheduleTensors,\n                                day_counter: int) -&gt; FluFullMetapopStateTensors:\n    \"\"\"\n    Returns new dataclass formed by copying the current `state`\n    and updating specific values according to `schedules` and\n    the simulation's current `day_counter`.\n\n    Returns:\n        (FluFullMetapopStateTensors):\n            New state with updated schedule-related values:\n              - `flu_contact_matrix`\n              - `absolute_humidity`\n              - `daily_vaccines`\n            All other fields remain unchanged from the input `state`.\n    \"\"\"\n\n    flu_contact_matrix = compute_flu_contact_matrix(params, schedules, day_counter)\n    absolute_humidity = schedules.absolute_humidity[day_counter]\n    daily_vaccines = schedules.daily_vaccines[day_counter]\n\n    state_new = FluFullMetapopStateTensors(\n        S=state.S,\n        E=state.E,\n        IP=state.IP,\n        IS=state.IS,\n        IA=state.IA,\n        H=state.H,\n        R=state.R,\n        D=state.D,\n        M=state.M,\n        MV=state.MV,\n        absolute_humidity=absolute_humidity,\n        daily_vaccines=daily_vaccines,\n        flu_contact_matrix=flu_contact_matrix\n    )\n\n    return state_new\n</code></pre>"},{"location":"flu_input_requirements/","title":"Math-to-Code Input Mappings","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) \\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow IS}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a,r}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) </p> <p>Here, we provide mappings between the mathematical variables in the mathematical formulation and input variable names in the code. For users to customize the values (not the structure) of the flu model given in <code>flu_components.py</code>, they must abide by certain input specifications.</p> <p>Recall that the class <code>FluSubpopModel</code> simulates the flu model given by this mathematical formulation for a specific subpopulation. Multiple <code>FluSubpopModel</code> instances can be combined as input into a <code>FluMetapopModel</code> instance to simulate multiple subpopulations and travel between these subpopulations. To implement a concrete <code>FluSubpopModel</code> instance requires user-specified inputs, including demographics, epidemiological parameters, and simulation settings.</p>"},{"location":"flu_input_requirements/#flusubpopstate","title":"<code>FluSubpopState</code>","text":"<p>Note that there is one <code>FluSubpopState</code> for each <code>SubpopModel</code> instance. The following matrices are for a specific subpopulation. But here we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. </p> Dataclass Field Name Math Variable Dimension <code>S</code> \\(\\boldsymbol{S}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>E</code> \\(\\boldsymbol{E}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IP</code> \\(\\boldsymbol{IP}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IS</code> \\(\\boldsymbol{IS}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IA</code> \\(\\boldsymbol{IA}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>H</code> \\(\\boldsymbol{H}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>R</code> \\(\\boldsymbol{R}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>D</code> \\(\\boldsymbol{D}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>M</code> \\(\\boldsymbol{M}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>MV</code> \\(\\boldsymbol{MV}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\)"},{"location":"flu_input_requirements/#flusubpopparams","title":"<code>FluSubpopParams</code>","text":"<p>This dataclass specifies the subpopulation's epidemiological parameters -- it specifies values such as transition rates as well as number of age groups and risk groups. We assume that these values do not change throughout the course of the simulation.  </p> <p>The following variables are for a specific subpopulation, although many of these variables will be the same across subpopulations in practice. Here in the table below we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. Variables that are positive floats can be generalized to be age-risk dependent.</p> Dataclass Field Name Math Variable Dimension <code>num_age_groups</code> \\(\\lvert \\mathcal A \\rvert\\) positive <code>int</code> <code>num_risk_groups</code> \\(\\lvert \\mathcal R \\rvert\\) positive <code>int</code> <code>beta_baseline</code> \\(\\beta_0\\) positive <code>float</code> <code>total_pop_age_risk</code> \\(\\boldsymbol{N}\\) \\(\\lvert \\mathcal A \\rvert \\times  \\lvert \\mathcal R \\rvert\\) <code>humidity_impact</code> \\(\\xi\\) <code>float</code> <code>inf_induced_saturation</code> \\(o\\) nonnegative <code>float</code> <code>vax_induced_saturation</code> \\(o_v\\) nonnegative <code>float</code> <code>inf_induced_immune_wane</code> \\(w\\) nonnegative <code>float</code> <code>vax_induced_immune_wane</code> \\(w_v\\) nonnegative <code>float</code> <code>inf_induced_inf_risk_reduce</code> \\(k^I\\) <code>float</code> in \\([0,1)\\) <code>inf_induced_hosp_risk_reduce</code> \\(k^H\\) <code>float</code> in \\([0,1)\\) <code>inf_induced_death_risk_reduce</code> \\(k^D\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_inf_risk_reduce</code> \\(k^I_v\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_hosp_risk_reduce</code> \\(k^H_v\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_death_risk_reduce</code> \\(k^D_v\\) <code>float</code> in \\([0,1)\\) <code>R_to_S_rate</code> \\(\\rateRtoS\\) positive <code>float</code> <code>E_to_I_rate</code> \\(\\rateEtoI\\) positive <code>float</code> <code>IP_to_IS_rate</code> \\(\\rateIPtoIS\\) positive <code>float</code> <code>IS_to_R_rate</code> \\(\\rateIStoR\\) positive <code>float</code> <code>IA_to_R_rate</code> \\(\\rateIAtoR\\) positive <code>float</code> <code>IS_to_H_rate</code> \\(\\rateIStoH\\) positive <code>float</code> <code>H_to_R_rate</code> \\(\\rateHtoR\\) positive <code>float</code> <code>H_to_D_rate</code> \\(\\rateHtoD\\) positive <code>float</code> <code>E_to_IA_prop</code> \\(\\propIA\\) <code>float</code> in \\([0,1]\\) <code>H_to_D_adjusted_prop</code> \\(\\boldsymbol{\\adjustedpropD}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IS_to_H_adjusted_prop</code> \\(\\boldsymbol{\\adjustedpropH}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IP_relative_inf</code> \\(r_{IP}\\) positive <code>float</code> <code>IA_relative_inf</code> \\(r_{IA}\\) positive <code>float</code> <code>relative_suscept</code> \\(\\psi\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>mobility_modifier</code> \\(m\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>total_contact_matrix</code> \\(\\phi^{(\\ell), \\text{total}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>school_contact_matrix</code> \\(\\phi^{(\\ell), \\text{work}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>work_contact_matrix</code> \\(\\phi^{(\\ell), \\text{school}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <p>See the next section on <code>FluSubpopSchedules</code> for how \\(d_{\\text{work}}(t)\\) and \\(d_{\\text{school}}(t)\\) are defined.</p>"},{"location":"flu_input_requirements/#flusubpopschedules","title":"<code>FluSubpopSchedules</code>","text":"Dataclass Field Name Column Name Math Variable Dimension <code>absolute_humidity</code> <code>absolute_humidity</code> \\(h(t)\\) positive <code>float</code> <code>flu_contact_matrix</code> <code>is_school_day</code> \\(d_{\\text{work}}(t)\\) <code>bool</code> <code>flu_contact_matrix</code> <code>is_work_day</code> \\(d_{\\text{school}}(t)\\) <code>bool</code> <code>daily_vaccines</code> <code>daily_vaccines</code> \\(V^{(\\ell)}_{a, r}(t)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\)"},{"location":"flu_input_requirements/#flumixingparams","title":"<code>FluMixingParams</code>","text":"Dataclass Field Name Math Variable Dimension <code>num_locations</code> \\(\\lvert \\mathcal A \\rvert\\) positive <code>int</code> <code>travel_proportions</code> \\(p^{\\ell \\rightarrow k}\\) \\(\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert\\)"},{"location":"flu_input_requirements/#simulationsettings","title":"<code>SimulationSettings</code>","text":"<p>The field <code>timesteps_per_day</code> is the number of timesteps to take per day, which equals \\(1/(\\Delta t)\\), where \\(\\Delta t\\) is the discretization interval. The field <code>transition_type</code> determines the distribution used for transitions between compartments (see page on transitions). The field <code>start_real_date</code> is the real-world date in string format <code>\"YYYY-MM-DD\"</code> corresponding to the start of the simulation. </p> <p>See <code>SimulationSettings</code> docstring for other fields (those are not directly related to the mathematical formulation and only specify how simulation output is saved).</p> <p>Updated 08/29/2025. Written by LP, edited by Susan Ptak.</p>"},{"location":"math_flu_components/","title":"MetroFluSim Mathematical Formulation","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) \\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow IS}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) \\(\\def\\proptravelelltok{p^{\\ell \\rightarrow k}}\\) \\(\\def\\propdaytravelktoell{p^{k \\rightarrow \\ell}}\\) \\(\\def\\LambdaIlocagerisktime{\\Lambda^{(\\ell), I}_{a,r}(t)}\\) \\(\\def\\LambdaHlocagerisktime{\\Lambda^{(\\ell), H}_{a,r}(t)}\\) \\(\\def\\LambdaDlocagerisktime{\\Lambda^{(\\ell), D}_{a,r}(t)}\\) \\(\\def\\locationell{^{(\\ell)}}\\) \\(\\def\\locationk{^{(k)}}\\) \\(\\def\\locagerisk{\\locationell_{a, r}}\\) \\(\\def\\locagerisktime{\\locagerisk(t)}\\) \\(\\def\\agetime{_a(t)}\\) \\(\\def\\agerisk{_{a, r}}\\) \\(\\def\\agerisktime{_{a, r}(t)}\\) \\(\\def\\ageprimeriskprime{_{a^\\prime, r^\\prime}}\\) \\(\\def\\locageprimeriskprime{\\locationell_{a^\\prime, r^\\prime}}\\) \\(\\def\\Nlocagerisk{N\\locationell_{a,r}}\\) \\(\\def\\effectiveNlocagerisktime{\\tilde{N}\\locationell_{a,r}(t)}\\) \\(\\def\\effectiveNlocageprimeriskprimetime{\\tilde{N}\\locationell_{a^\\prime,r^\\prime}(t)}\\) \\(\\def\\multipliersymptom{h_{\\text{symp}}}\\) \\(\\def\\tvarloc{y^{(\\ell)}}\\) \\(\\def\\jointtvarloc{y^{(\\ell) *}}\\) \\(\\def\\simstate{\\boldsymbol{\\Xi}_t}\\) \\(\\def\\agegroups{\\mathcal A}\\) \\(\\def\\riskgroups{\\mathcal R}\\) \\(\\def\\numagegroups{\\lvert \\agegroups \\rvert}\\) \\(\\def\\numriskgroups{\\lvert \\riskgroups \\rvert}\\) \\(\\def\\poik{\\text{POI}(k)}\\) \\(\\def\\poiell{\\text{POI}(\\ell)}\\) </p> <p>The mathematical framework is inspired by the immunoSEIRS model of the Meyers Lab (see Bi and Bandekar et al. 2023, Bi et al. 2022 and Bouchnita et al. 2021 for some related recent publications).</p> <p>Please note that the MetroFluSim model requires extensive notation -- please review the entirety of each section for provided definitions.</p>"},{"location":"math_flu_components/#flu-model-diagram","title":"Flu model: diagram","text":""},{"location":"math_flu_components/#flu-model-deterministic-differential-equations","title":"Flu model: deterministic differential equations","text":"<p>We start off with common indices and arguments: - \\(t \\in \\mathbb N\\): current simulation day - \\(\\ell\\): location, i.e. subpopulation, \\(\\mathcal L\\): set of all locations/subpopulations - \\(a\\): age group, \\(\\agegroups\\): set of all age groups - \\(r\\): risk group, \\(\\riskgroups\\): set of all risk groups - \\(i\\): type of immunity-inducing event, \\(\\mathcal{I} := \\left\\{\\text{infection}, \\text{vaccine}\\right\\}\\): the set of all types of immunity-inducing events: infection and vaccination, respectively.</p>"},{"location":"math_flu_components/#population-level-immunity","title":"Population-level immunity","text":"<p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\):</p> \\[\\begin{align*} \\frac{dM\\locationell\\agerisktime}{dt} &amp;= \\frac{\\rateRtoS(t) R\\locagerisktime}{N\\locationell_{a, r}} \\cdot (1 - oM\\locationell\\agerisktime - o_v MV\\locationell\\agerisktime) - wM\\locationell\\agerisktime \\tag{M1} \\\\ \\frac{dMV\\locationell\\agerisktime}{dt} &amp;= \\frac{V\\locationell\\agerisk(t - \\delta)}{N\\locationell\\agerisk} - w_v MV\\locationell\\agerisktime \\tag{M2} \\end{align*}\\] <p>where</p> <ul> <li>\\(\\rateRtoS\\): rate at which recovered individuals become susceptible, so that \\(1/\\rateRtoS\\) is the average number of days a person is totally immune from reinfection until being susceptible again.</li> <li>\\(V\\locationell\\agerisktime\\): number of vaccine doses administered at time \\(t\\) to individuals residing in location \\(\\ell \\in \\mathcal L\\) in age-risk group \\(a\\), \\(r\\).</li> <li>\\(o\\), \\(o_v\\): positive constants modeling the saturation of antibody production in individuals who have infection-induced immunity and vaccination-induced immunity, respectively.</li> <li>\\(\\delta\\): number of days after dose for vaccine to become effective.</li> <li>\\(w\\): rate at which infection-induced immunity wanes.</li> <li>\\(w_V\\): rate at which vaccine-induced immunity wanes.</li> </ul>"},{"location":"math_flu_components/#compartment-equations","title":"Compartment equations","text":"<p>Note that the following are all \\(\\numagegroups \\times \\numriskgroups \\times \\lvert \\mathcal I \\rvert\\) matrices:</p> <ul> <li>\\(\\boldsymbol{K}^I = [\\boldsymbol{K}^I, \\boldsymbol{K}^I_{V}]\\): reduction in infection risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^{H} = [\\boldsymbol{K}^H, \\boldsymbol{K}^H_{V}]\\): reduction in hospitalization risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^D = [\\boldsymbol{K}^D, \\boldsymbol{K}^D_{V}]\\): reduction in death risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{M}\\locationell = \\boldsymbol{M}\\locationell(t) = [\\boldsymbol{M}\\locationell(t), \\boldsymbol{M}\\locationell_{V}(t)]\\): location \\(\\ell \\in \\mathcal L\\) population-level immunity.  </li> </ul> <p>To simplify notation, we have the following terms that characterize the effect of population-level immunities for a given subpopulation \\(\\ell\\), age \\(a\\), and risk \\(r\\):</p> \\[\\begin{align*} \\LambdaIlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{I}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{I}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I1} \\\\ \\LambdaHlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{H}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{H}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I2} \\\\ \\LambdaDlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{D}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{D}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I3} \\end{align*}\\] <p>where \\(\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1}\\) is an \\(\\lvert \\mathcal L \\rvert \\times 1\\) vector of \\(1\\)'s and the fraction notation indicates element-wise division. </p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\), we have the following equations that characterize transitions between compartments:</p> \\[\\begin{align} \\frac{dS\\locagerisktime}{dt} &amp;= \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}}  -\\underbrace{S\\locagerisktime \\frac{\\beta\\locationell(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIlocagerisktime\\right)}}_{\\text{$S$ to $E$}} \\tag{C1} \\\\[1.5em] \\frac{dE\\locagerisktime}{dt} &amp;= \\underbrace{S\\locagerisktime \\frac{\\beta\\locationell(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIlocagerisktime\\right)}}_{\\text{$S$ to $E$}} - \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}} - \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}} \\tag{C2} \\\\[1.5em] \\frac{dIP\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}} - \\underbrace{\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $IS$}} \\tag{C3} \\\\[1.5em] \\frac{dIS\\locagerisktime}{dt} &amp;= \\underbrace{\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $IS$}}  - \\underbrace{\\left(1-\\frac{\\adjustedpropH_{a, r}}{1 + \\LambdaHlocagerisktime}\\right)\\rateIStoR IS\\locagerisktime}_{\\text{$IS$ to $R$}} - \\underbrace{\\frac{\\rateIStoH \\adjustedpropH_{a, r} IS\\locagerisktime}{1 + \\LambdaHlocagerisktime}}_{\\text{$IS$ to $H$}} \\tag{C4} \\\\[1.5em] \\frac{dIA\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}}  - \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}} \\tag{C5} \\\\[1.5em] \\frac{dH\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\rateIStoH \\adjustedpropH_{a, r} IS\\locagerisktime}{1 + \\LambdaHlocagerisktime}}_{\\text{$IS$ to $H$}} - \\underbrace{\\left(1-\\frac{\\adjustedpropD_{a, r}}{1 + \\LambdaDlocagerisktime}\\right)\\rateHtoR H\\locagerisktime}_{\\text{$H$ to $R$}}  - \\underbrace{\\frac{\\rateHtoD \\adjustedpropD_{a, r} H\\locagerisktime}{1 + \\LambdaDlocagerisktime}}_{\\text{$H$ to $D$}} \\tag{C6} \\\\[1.5em] \\frac{dR\\locagerisktime}{dt} &amp;= \\underbrace{\\left(1-\\frac{\\adjustedpropH_{a, r}}{1 + \\LambdaHlocagerisktime}\\right) \\rateIStoR IS\\locagerisktime}_{\\text{$IS$ to $R$}} + \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}}  \\\\[1em] &amp;\\quad\\quad\\quad + \\underbrace{\\left(1-\\frac{\\adjustedpropD_{a, r}}{1 + \\LambdaDlocagerisktime}\\right)\\rateHtoR H\\locagerisktime}_{\\text{$H$ to $R$}}  - \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}} \\tag{C7} \\\\[1.5em] \\frac{dD\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\rateHtoD \\adjustedpropD_{a, r} H\\locagerisktime}{1 + \\LambdaDlocagerisktime}}_{\\text{$H$ to $D$}}. \\tag{C8} \\end{align}\\] <p>where</p> <ul> <li>The \\(\\lambda\\)-terms are location/subpopulation mixing terms that we define in the next section on the travel model. </li> <li>\\(\\boldsymbol{N}\\locationell\\): \\(\\numagegroups \\times \\numriskgroups\\) matrix corresponding to total population in location \\(\\ell \\in \\mathcal L\\), where element \\(N\\locagerisk\\) is the total population of age group \\(a\\) and risk group \\(\\ell\\) in location \\(\\ell\\).</li> <li>\\(\\beta\\locationell(t) = \\beta\\locationell_0 (1 + q(t))\\): time-dependent transmission rate per day for individuals residing in location \\(\\ell \\in \\mathcal L\\). </li> <li>\\(q(t) = \\xi \\cdot \\exp^{-180 * h(t)}\\): humidity adjustment, where \\(\\xi\\) is the humidity impact factor and \\(h(t)\\) is absolute humidity. This formula is taken from this paper.</li> <li>\\(\\propIA\\): proportion exposed who are completely asymptomatic when infectious.</li> <li>\\(r_{IP}\\), \\(r_{IA}\\): relative infectiousness (compared to infected symptomatic people) of infected presymptomatic and infected asymptomatic people respectively. </li> <li>\\(\\rateIStoR, \\rateHtoR, \\rateIAtoR\\): recovery rates for infected symptomatic (\\(IS\\)),  hospital (\\(H\\)), and infected asymptomatic (\\(IA\\)) compartments respectively, so that \\(1/\\gamma\\) is the average number of days it takes for an infected person not in the hospital to recover, and \\(1/\\rateHtoR\\) is analogous, but for an infected person in the hospital. </li> <li>\\(\\rateEtoI\\): infection rate (both exposed to infected presymptomatic transition rate and exposed to infected asymptomatic transition rate), so that \\(1/\\rateEtoI\\) is the average number of days after exposure before a person becomes infectious.</li> <li>\\(\\rateIPtoIS\\): infected presymptomatic to infected symptomatic transition rate, so that \\(1/\\rateIPtoIS\\) is the average number of days that an infected person is presymptomatic before becoming symptomatic. </li> <li>\\(\\rateIStoH\\): hospitalization rate (infected to hospital transition rate), so that \\(1/\\rateIStoH\\) is the average number of days a person is infected before going to the hospital.</li> <li>\\(\\rateHtoD\\): death rate from hospital, so that \\(1/\\rateHtoD\\) is the average number of days a person spends in the hospital before dying.</li> <li>\\(\\boldsymbol{\\adjustedpropH}\\), where \\(\\adjustedpropH_{a, r} = \\frac{\\propH_{a, r}\\rateIStoR}{\\rateIStoH - \\propH_{a, r}(\\rateIStoH-\\rateIStoR)}\\): adjusted proportion hospitalized based on age-risk group \\(a, r\\) group actually used in model -- this adjustment is necessary to ensure actual proportion hospitalized recapitulates \\([\\propH_{a, r}]\\).</li> <li>\\(\\boldsymbol{\\propH}\\): \\(\\numagegroups \\times \\numriskgroups\\) proportion hospitalized based on age-risk group \\(a, r\\).</li> <li>\\(\\boldsymbol{\\adjustedpropD}\\), where \\(\\adjustedpropD_{a, r} = \\frac{\\propD_{a, r} \\rateHtoR}{\\rateHtoD - \\propD_{a, r} (\\rateHtoD-\\rateHtoR)}\\): adjusted in-hospital mortality rate (as in, proportion who die in the hospital based on age group) actually used in model -- this adjustment is necessary to ensure actual proportion who die in the hospital recapitulates \\([\\propD_{a, r} ]\\).</li> <li>\\(\\boldsymbol{\\propD}\\): \\(\\numagegroups \\times \\numriskgroups\\) in-hospital mortality rate (proportion who die based on age-risk group \\(a, r\\)).</li> </ul>"},{"location":"math_flu_components/#flu-model-travel-model","title":"Flu model: travel model","text":""},{"location":"math_flu_components/#exposure-intensity","title":"Exposure intensity","text":"<p>For each \\(\\ell \\in \\mathcal L\\), \\(k \\in \\mathcal L \\setminus \\{\\ell\\}\\), \\(a \\in \\agegroups\\), we have</p> \\[ \\totalforceofinfection = \\lambda^{(\\ell), \\text{local}}\\agetime + \\lambda^{(\\ell), \\text{visitors}}\\agetime + \\lambda^{(\\ell), \\text{residents traveling}}\\agetime. \\tag{T1} \\] <p>This can loosely can be interpreted as exposure intensity: the (weighted) proportion of the population that interacts with \\(\\ell,a\\) individuals that are infectious. </p> <p>The decompositions model the following phenomenon:</p> <ul> <li>\\(\\lambda^{(\\ell), \\text{local}}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(\\ell\\) (this contact occurs in location \\(\\ell\\)).</li> <li>\\(\\lambda^{(\\ell), \\text{visitors from } k}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\) but travel to location \\(\\ell\\) (this contact occurs in location \\(\\ell\\)).</li> <li>\\(\\lambda^{(\\ell), \\text{residents traveling to } k}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\), due to individuals who live in location \\(\\ell\\) traveling to location \\(k\\) (this contact occurs in location \\(k\\)).</li> </ul> <p>Note that we assume this exposure intensity is the same for a given age group regardless of risk group, so we do not have the \\(r\\)-subscript here.</p> <p>Specifically, we have</p> \\[\\begin{align*} \\lambda^{(\\ell), \\text{local}}\\agetime &amp;= \\psi_a \\left(1 - m_a \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok \\right) \\cdot \\sum \\limits_{a^\\prime \\in \\agegroups} \\phi\\locationell_{a,a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationell_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime} \\tag{T2} \\\\[1.5em] \\lambda^{(\\ell), \\text{visitors}}\\agetime &amp;= \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\underbrace{\\left(\\psi_a \\cdot \\propdaytravelktoell \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} m_{a^\\prime}(t) \\cdot \\phi\\locationell_{a, a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationk_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime}\\right)}_{\\text{Each summand: } \\lambda^{(\\ell), \\text{visitors from } k}\\agetime} \\tag{T3} \\\\[1.5em] \\lambda_{a,r}^{(\\ell), \\text{residents traveling}}(t) &amp;= \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}}  \\underbrace{\\left(\\psi_a \\cdot \\proptravelelltok  \\cdot m_a \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} \\phi\\locationell_{a, a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationk_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\tilde{N}^{(k)}_{a^\\prime, r^\\prime} (t)}\\right)}_{\\text{Each summand: } \\lambda\\agerisk^{(\\ell), \\text{residents traveling to } k}(t)} \\tag{T4} \\end{align*}\\] <p>where</p> \\[ \\texttt{I_weighted}\\locationell_{a^\\prime}(t) := \\sum_{r^\\prime \\in \\riskgroups} \\left[IS\\locationell\\ageprimeriskprime(t) + r_{IP} IP\\locationell\\ageprimeriskprime(t) + r_{IA} IA\\locationell\\ageprimeriskprime(t)\\right] \\tag{T5} \\] <p>and where</p> \\[\\begin{align*} \\effectiveNlocagerisktime &amp;= \\Nlocagerisk + m_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\propdaytravelktoell \\cdot (N^{(k)}_{a, r} - H^{(k)}_{a,r}(t)) \\\\ &amp;\\quad\\quad\\quad - m_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok  \\cdot (N\\locagerisk - H\\locationell_{a,r}(t)) \\tag{T6} \\end{align*}\\] <p>is the effective population in location \\(\\ell \\in \\mathcal L\\) and age-risk group \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\) at time \\(t\\).</p>"},{"location":"math_flu_components/#contact-matrix","title":"Contact matrix","text":"<p>The contact matrix is defined as</p> <ul> <li>\\(\\phi_{a, a^\\prime}\\locationell(t)\\): the number of contacts that individuals in age group \\(a \\in \\agegroups\\) residing in location \\(\\ell \\in \\mathcal L\\) have with other individuals (regardless of location) in age group \\(a^\\prime \\in \\agegroups\\) on day \\(t\\).</li> </ul> <p>Let \\(\\phi^{(\\ell), \\text{total}}\\), \\(\\phi^{(\\ell), \\text{work}}\\), and \\(\\phi^{(\\ell), \\text{school}}\\) represent the total contact matrix, school contact matrix, and work contact matrix, respectively for subpopulation \\(\\ell\\).</p> <p>Then the contact matrix for the subpopulation at time \\(t\\) is $$ \\phi^{(\\ell)}(t) := \\phi^{(\\ell), \\text{total}} - (1 - d_{\\text{work}}(t)) \\phi^{(\\ell), \\text{work}} - (1 - d_{\\text{school}}(t)) \\phi^{(\\ell), \\text{school}} $$ where \\(d_{\\text{work}}(t)\\) is \\(1\\) if the real-world date corresponding to simulation time \\(t\\) is a work day and \\(0\\) otherwise, and \\(d_{\\text{school}}(t)\\) is defined analogously, but for school days.</p>"},{"location":"math_flu_components/#other-travel-parameters","title":"Other travel parameters","text":"<p>We have</p> <ul> <li>\\(\\psi_a \\in [0, 1]\\): relative susceptibility of individuals in age group \\(a \\in \\agegroups\\).</li> <li>\\(m_a\\): a positive scalar modifying travel intensity depending on age \\(a\\).</li> <li>\\(\\propdaytravelktoell\\): (on average) proportion of the day that a resident of \\(k\\) spends traveling to location \\(\\ell \\in \\mathcal L\\).</li> </ul> <p>Note that the arrows in \\(\\propdaytravelktoell\\) correspond to direction of travel (e.g. \\(k \\rightarrow \\ell\\) represents residents of location \\(k\\) traveling to location \\(\\ell\\)). The \\(\\propdaytravelktoell\\) values are calculated from mobility data, corresponding to</p> \\[ \\propdaytravelktoell := \\sum_{\\poiell} c^{\\poiell} \\cdot v^{k \\rightarrow \\poiell} \\tag{T7} \\] <p>where</p> <ul> <li>\\(c^{\\poiell}\\): average proportion of a day spent at \\(\\poiell\\).</li> <li>\\(v^{k \\rightarrow \\poiell}\\): average number of visits per day per resident of \\(k\\) to \\(\\poiell\\).</li> </ul>"},{"location":"math_flu_components/#flu-model-discretized-stochastic-implementation","title":"Flu model: discretized stochastic implementation","text":"<p>To actually implement/simulate this compartmental model, we discretize the deterministic differential equations and treat transitions between compartments as stochastic to model uncertainty. We extend the notation from the deterministic differential equations to capture the stochastic elements.</p> <p>Let \\(\\boldsymbol{\\mathcal X}(t) = \\left\\{\\boldsymbol{S}(t), \\boldsymbol{E}(t), \\boldsymbol{IA}(t), \\boldsymbol{IP}(t), \\boldsymbol{IS}(t), \\boldsymbol{H}(t), \\boldsymbol{R}(t), \\boldsymbol{D}(t), \\boldsymbol{M}(t), \\boldsymbol{MV}(t), q(t), \\boldsymbol{\\phi}(t), V\\locationell(t)\\right\\}\\) be the \"simulation state\" at time \\(t\\). \\(\\boldsymbol{\\mathcal X}(t)\\) is a set of matrices. </p> <p>Let \\(\\boldsymbol{\\Theta}\\) be the set of fixed parameters. </p> <p>Then given initial state \\(\\boldsymbol{\\mathcal X}_0 = \\boldsymbol{\\mathcal X}(0)\\), we can formulate our discretized stochastic implementation as</p> \\[ \\boldsymbol{\\mathcal X}(t + \\Delta t) = \\boldsymbol{\\mathcal X}(t) + f\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega; \\boldsymbol{\\Theta}\\right) \\quad \\text{for} \\quad t \\ge 0, \\] <p>where \\(f\\) is parametrized by \\(\\boldsymbol{\\Theta}\\), and depends on the step size of discretization \\(\\Delta t\\) and a sample path \\(\\omega\\). We assume that each sample path \\(\\omega\\) is realized from a random process that does not depend on \\(\\boldsymbol{\\mathcal X}(t)\\) or \\(\\Delta t\\) for each \\(t\\). When we are discussing a single model with a fixed set of parameters \\(\\boldsymbol{\\Theta}\\), we drop the \\(\\boldsymbol{\\Theta}\\) notation for simplicity.  </p> <p>Now we formulate how we implement discretized stochastic transitions. We assume that \\(q(t)\\), \\(\\boldsymbol{\\phi}(t)\\), and \\(V\\locationell(t)\\)  are updated deterministically according to some \"schedule.\"  </p> <p>We model stochastic transitions between compartments using \"transition variables.\" Transition variables correspond to incoming and outgoing flows of epidemiological compartments (see the compartment equations above). </p> <p>Below we formulate the discretized stochastic transitions. Note that the population-level immunity variables behave as aggregate epidemiological metrics. They are deterministic functions of the simulation state and transitions between compartments.</p> <p>IMPORTANT NOTE_: all \\(y\\) and \\(y^*\\)-variables depend on \\(\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). For notation simplicity, we define \\(\\simstate := \\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and write \\(y\\) and \\(y^*\\)-variables as functions of \\(\\simstate\\).</p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), and \\(r \\in \\riskgroups\\):</p> \\[\\begin{align} M_{a, r}\\locationell(t + \\Delta t) &amp;= M\\locationell\\agerisktime + \\frac{dM\\locationell\\agerisktime}{dt} \\cdot \\Delta t \\\\ MV_{a,r}\\locationell(t + \\Delta t) &amp;= MV\\agerisktime\\locationell + \\frac{dMV\\agerisktime\\locationell}{dt} \\cdot \\Delta t \\\\ S\\locagerisk(t + \\Delta t) &amp;= S_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} - \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} \\\\ E\\locagerisk(t + \\Delta t) &amp;= E_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} \\\\ IP\\locagerisk(t + \\Delta t) &amp;= IP\\locagerisktime + \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\tvarloc_{IP \\rightarrow IS, a, r}(\\Xi_t)}_{\\text{$IP$ to $IS$}} \\\\ IA_{a, r}\\locationell(t + \\Delta t) &amp;= IA_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} - \\underbrace{\\tvarloc_{IA \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IA$ to $R$}} \\\\ IS\\locagerisk(t + \\Delta t) &amp;= IS_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{E \\rightarrow IS, a, r}(\\Xi_t)}_{\\text{$E$ to $IS$}} - \\underbrace{\\jointtvarloc_{IS \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IS$ to $R$}} - \\underbrace{\\jointtvarloc_{IS \\rightarrow H, a, r}(\\Xi_t)}_{\\text{$IS$ to $H$}} \\\\ H\\locagerisk(t + \\Delta t) &amp;= H_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{IS \\rightarrow H, a, r}(\\Xi_t)}_{\\text{$IS$ to $H$}} - \\underbrace{\\jointtvarloc_{H\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$H$ to $R$}} - \\underbrace{\\jointtvarloc_{H\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$H$ to $D$}} \\\\ R\\locagerisk(t + \\Delta t) &amp;= R_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{IA \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IA$ to $R$}} + \\underbrace{\\jointtvarloc_{IS \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IS$ to $R$}} + \\underbrace{\\jointtvarloc_{H\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$H$ to $R$}} - \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} \\\\ D\\locagerisk(t + \\Delta t) &amp;= D_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{H\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$H$ to $D$}}.  \\end{align}\\] <p>IMPORTANT NOTE: the \"\\(*\\)\" superscript indicates that the transition variable has a joint distribution with another transition variable. In general, if a compartment has more than one outgoing transition variable, these transition variables must be modeled jointly. </p> <p>Consider the two transitions out of the infected symptomatic compartment, for example. Given that a patient is infected and symptomatic, exactly one outcome occurs: they recover (from home) or they go to the hospital. Since one and only one of these outcomes must occur, we must model these two transition variables jointly. Joint distribution derivation details are provided in the next section on transition types.</p> <p>Each transition variable depends on a \"base count\" and a \"rate\" (which both depend on the current state of the system). This decomposition is displayed in the table below. Note that these transitions are for a given location \\(\\ell \\in \\mathcal L\\).</p> Transition Transition variable Base count Rate \\(R\\) to \\(S\\) \\(\\tvarloc_{R \\rightarrow S, a, r}(\\simstate)\\) \\(R_{a, r}\\locationell(t)\\) \\(\\rateRtoS\\) \\(S\\) to \\(E\\) \\(\\tvarloc_{S \\rightarrow E, a, r}(\\simstate)\\) \\(S_{a, r}\\locationell(t)\\) \\(\\frac{\\beta(t) \\totalforceofinfection}{1 + \\LambdaIlocagerisktime}\\) \\(E\\) to \\(IP\\) \\(\\jointtvarloc_{E \\rightarrow IP, a, r}(\\simstate)\\) \\(E_{a, r}\\locationell(t)\\) \\(\\rateEtoI (1 - \\propIA)\\) \\(E\\) to \\(IA\\) \\(\\jointtvarloc_{E \\rightarrow IA, a, r}(\\simstate)\\) \\(E_{a, r}\\locationell(t)\\) \\(\\rateEtoI \\propIA\\) \\(IP\\) to \\(IS\\) \\(\\tvarloc_{IP \\rightarrow IS, a, r}(\\simstate)\\) \\(IP_{a, r}\\locationell(t)\\) \\(\\rateIPtoIS\\) \\(IS\\) to \\(R\\) \\(\\jointtvarloc_{IS \\rightarrow R, a, r}(\\simstate)\\) \\(IS_{a, r}\\locationell(t)\\) \\(\\left(1-\\frac{\\adjustedpropH_{a,r}}{1 + \\LambdaHlocagerisktime}\\right)\\gamma^{IS\\rightarrow R}\\) \\(IS\\) to \\(H\\) \\(\\jointtvarloc_{IS \\rightarrow H, a, r}(\\simstate)\\) \\(IS_{a, r}\\locationell(t)\\) \\(\\frac{\\rateIStoH \\adjustedpropH_{a,r}}{1 + \\LambdaHlocagerisktime}\\) \\(IA\\) to \\(R\\) \\(\\tvarloc_{IA \\rightarrow R, a, r}(\\simstate)\\) \\(IA_{a, r}\\locationell(t)\\) \\(\\rateIAtoR\\) \\(H\\) to \\(R\\) \\(\\jointtvarloc_{H \\rightarrow R, a, r}(\\simstate)\\) \\(H_{a, r}\\locationell(t)\\) \\(\\left(1-\\frac{\\adjustedpropD_{a,r}}{1 + \\LambdaDlocagerisktime}\\right)\\rateHtoR\\) \\(H\\) to \\(D\\) \\(\\jointtvarloc_{H \\rightarrow D, a, r}(\\simstate)\\) \\(H_{a, r}\\locationell(t)\\) \\(\\frac{\\rateHtoD \\adjustedpropD_{a,r}}{1 + \\LambdaHlocagerisktime}\\) <p>The base count and rate of a transition variable parameterize the distribution that defines its realization. </p> <p>See this page for mathematical formulations of marginal and joint stochastic transitions between compartments. </p>"},{"location":"math_flu_components/#general-model-discretized-stochastic-implementation","title":"General model: discretized stochastic implementation","text":"<p>We make the important note that the flu model's discretized stochastic implementation can be generalized to models with different structures. More broadly, we let \\(\\boldsymbol{\\mathcal C}(t)\\) be a model's set of epidemiological compartments, \\(\\boldsymbol{\\mathcal M}(t)\\) its set of aggregate epidemiological metrics, and \\(\\boldsymbol{S (t)}\\) its set of schedule-dependent (time-dependent) deterministic values. Then the above formulation still holds.</p> <p>In fact, in our code, we model \\(\\boldsymbol{\\mathcal C(t)}\\) using an <code>Compartment</code> class, \\(\\boldsymbol{\\mathcal M}(t)\\) using an <code>EpiMetric</code> class, and \\(\\boldsymbol{\\mathcal S(t)}\\) using a <code>Schedule</code> class. We handle stochastic transitions using <code>TransitionVariable</code> and <code>TransitionVariableGroup</code> classes. These classes form some of the building blocks of the base model code. </p> <p>Updated 08/15/2025. Documentation written by LP, mathematical notation by LP (advised by Lauren Meyers and Dave Morton, edited by Susan Ptak, Meyers Lab, and Shiyuan Liang), travel model conceptualized by R\u00e9my Pasco and Susan Ptak, immunity formulation by Anass Bouchnita.</p>"},{"location":"math_transitions/","title":"Stochastic Transitions","text":"<p>Written by LP, updated 01/30/2025 </p>"},{"location":"math_transitions/#marginal-transition-types","title":"Marginal transition types","text":"<p>Our codebase currently implements six types of transitions: three stochastic transitions and three deterministic counterparts.</p> <p>First we consider marginal (not joint) transition variables. For the following table, consider \\(y_{\\texttt{C}\\rightarrow\\texttt{C}^\\prime, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) from compartment \\(\\texttt{C}\\) to \\(\\texttt{C}^\\prime\\). Let \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t)\\) be its current value of its base count and \\(\\texttt{r} = \\texttt{r}_{a, \\ell}(t)\\) be its current value of its rate. Then depending on its transition type, its distribution (or deterministic value) is given below.</p> <p>Note that \\(\\alpha\\) is a function that converts a \"rate\" into a probability. It is given by: $$ \\alpha(\\texttt{r}, \\Delta t) = 1 - \\exp(-\\texttt{r} \\cdot \\Delta t) $$ and corresponds to the probability that a Poisson process with rate \\(\\texttt{r}\\) produces at least one event in an interval of length \\(\\Delta t\\). </p> <p>The following table provides the mathematical distribution or deterministic output for each transition type. </p> Output Binomial \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\alpha(\\texttt{r}, \\Delta t)\\right)\\) Binomial  Taylor Approx \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\texttt{r} \\cdot \\Delta t\\right)\\) Poisson \\(\\sim \\text{Poisson}\\left(\\lambda = \\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\right)\\) Binomial Deterministic \\(\\texttt{b} \\cdot \\alpha(\\texttt{r}, \\Delta t)\\) Binomial Taylor Approx Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\) Poisson Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\)"},{"location":"math_transitions/#joint-transition-types","title":"Joint transition types","text":"<p>Here we describe joint transition variables. For the following table, consider a compartment \\(\\texttt{C}_0\\) with two outgoing compartments, \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). We describe \\(2\\) transition variables: \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). They respectively correspond to the number of people that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_1\\) and the number that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_2\\) at a given simulate state. Let their rates be \\(\\texttt{r}_1\\) and \\(\\texttt{r}_2\\) respectively.  </p> <p>We can also write the number that remain in \\(\\texttt{C}_0\\) explicitly as  \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) = \\texttt{C}_{0, a, \\ell}(t) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). Note that this quantity is purely for parametrizing multinomial distributions (which needs to have its probability parameters sum to \\(1\\)) and does not need to be literally modeled as a transition variable either mathematically or in code. </p> <p>Let \\(\\alpha\\) be defined as in the previous section on marginal transition types.</p> <p>The following table gives the parameters for multinomial transitions when \\(\\texttt{C}_0\\) has two outgoing compartments \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). The values \\([y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)]\\) are sampled jointly, using \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t) = \\texttt{C}_{0, a, \\ell}(t)\\) as the \"number of trials\" parameter \\(n\\) in a multinomial distribution.</p> Transition  Variable Group (Jointly Sampled) Multinomial Probability Parameter Multinomial with Taylor Approx Probability Parameter \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_1}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_1 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_2}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_2 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(1 - \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(1 - (\\texttt{r}_1 + \\texttt{r}_2) \\Delta t\\)"},{"location":"math_transitions/#important-notes","title":"Important notes","text":"<ul> <li> <p>The transition variable group table formulas generalize to an arbitrary number of outgoing compartments -- however, this is not shown here.</p> </li> <li> <p>Note that Poisson is not included in the above table. Recall the splitting property of Poisson processes. If the total outflow (going to either compartment, \\(\\texttt{C}_1\\) or \\(\\texttt{C}_2\\)) is Poisson, we can split the process into two independent Poisson processes. So joint sampling is not actually needed. </p> </li> <li> <p>In contrast, the binomial distribution does not have such a splitting property. If the total outflow is binomial with parameters \\(n\\) and \\(p\\), then we cannot use a similar Poisson splitting technique to create two independent binomial random variables with the same number of trial parameters \\(n\\). Thus, joint sampling is needed. </p> </li> <li> <p>An advantage of binomial/multinomial transition variables (with joint sampling when there are multiple outflows from a compartment) is that we cannot have more people leaving the origin compartment than are actually in the compartment. We set the \"number of trials\" parameter in the multinomial distribution to be the current number of people in the compartment. This is NOT the case for Poisson transition variables, which are unbounded! Thus, we recommend using binomial/multinomial transition types.</p> </li> <li> <p>See <code>update_compartments</code> method in <code>clt_toolkit / base_components.py / MetapopModel</code> for details on how we adjust compartment values for deterministic implementations. Note that the stochastic transitions have realizations that are always integer, and due to multinomial sampling (see previous point), the compartments are always nonnegative. With any of our deterministic transitions, our transitions are not guaranteed to be integer, and our compartments are not guaranteed to be nonnegative. With deterministic transitions, we apply a \"softplus\" function (a smooth approximation to the ReLU function) to all compartment values of all compartments. This makes compartments nonnegative. </p> </li> <li> <p>For the binomial/multinomial Taylor approximation transition type, if the simulation discretization parameter \\(\\Delta t\\) is too large, then it is possible for the \"probability parameter\" to be nonsensical. For example, in the table above, it is possible for \\(r_1 \\Delta t &gt; 1\\) or \\(r_2 \\Delta t &gt; 1\\) if \\(\\Delta t\\) is not sufficiently small. Similarly, it is possible for \\(1 - (r_1 + r_2) \\Delta t &lt; 0\\) if \\(\\Delta t\\) is not sufficiently small. Thus, we cannot use these values as probabilities input for the binomial distribution. As a result, we recommend using the binomial transition type with no Taylor approximation. This transition type converts rates into probabilities that are always between \\([0,1]\\) and thus always well-defined to be input as a probability parameter in a binomial distribution.</p> </li> </ul>"}]}