{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This website provides code documentation, including tutorials and API references, for the CLT Toolkit. In addition, this website provides code and mathematical formulation documentation for MetroFluSim.</p> <p>The CLT Toolkit is a modular Python codebase for scalable compartmental models of respiratory virus transmission in a city. This effort is spearheaded by the Meyers Lab and epiENGAGE center under a CDC-funded effort to provide high quality technical tools for modeling. This toolkit takes care of fundamental simulation mechanics, allowing users to efficiently build and adapt multiple stochastic models without reimplementing common operations from scratch. This toolkit streamlines the construction of granular metapopulation models -- heterogenous regions can be easily modeled as distinct locations or subpopulations with age and risk groups, all integrated within a single metapopulation framework. </p> <p>The toolkit is used to create MetroFluSim, a high fidelity city-level influenza model that captures population-level immunity dynamics. The Meyers Lab at UT Austin is working directly with public health officials in the Texas cities of Austin, Dallas, El Paso, and Houston to create specific implementations of the <code>MetroFluSim</code> model tailored to each city.</p> <pre><code>flowchart TD\n    A[CLT Toolkit] --&gt;| create subclasses to specify compartments and structure | C{MetroFluSim}\n    C --&gt; | Austin-specific inputs, parameters, populations | D[Austin]\n    C --&gt; | ... | F[Dallas]\n    C --&gt; | ... | G[El Paso] \n    C --&gt; | Houston-specific inputs, parameters, populations | E[Houston]\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>The CLT Toolkit is written in Python 3.11.0.</p> <p>To download, build, and run the latest code release, run the following in Terminal: <pre><code>git clone https://github.com/LP-relaxation/CLT_BaseModel.git\n</code></pre></p> <p>In the package folder (<code>pyproject.toml</code> should be in this directory), run the following in Terminal: <pre><code>pip install -e .\n</code></pre> to install the package in editable mode. Note that some users may have to use <code>pip3 install -e .</code>, depending on their configuration.</p> <p>Packages required: <pre><code>numpy==1.24.3\npandas==1.5.3\npytest==8.3.3\npytorch==2.3.1\nsciris==3.2.0\n</code></pre></p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>We recommend </p> <ul> <li><code>flu_instances/examples/flu_demo.ipynb</code> for a Jupyter notebook tutorial on building subpopulation and metapopulation models, running random parameter sampling, and organizing large-scale output in experiments.</li> <li><code>flu_instances/examples/torch_calibration_demo.ipynb</code> for a Jupyter notebook tutorial on using <code>pytorch</code> autodifferentiate to solve least-squares on a deterministic functional implementation of the flu model to calibrate unknown parameters.</li> <li><code>SIHR_core/SIHR_components.py</code> for a thoroughly commented file explaining how to use the CLT Toolkit to create a customized model. </li> </ul>"},{"location":"#code-structure","title":"Code Structure","text":"Folder Description <code>clt_toolkit</code> CLT Toolkit abstract \"base\" classes. These provide reusable functionality for compartmental models, so users can run models without reimplementing simulation logic from scratch. <code>flu_core</code> Subclasses of <code>clt_base</code> that designate the compartments and structure of MetroFluSim, without specifying concrete inputs, parameters, or populations. <code>flu_instances</code> Stores data that specifies concrete inputs, parameters, and populations used to construct particular instances of <code>MetroFluSim</code> models (i.e. for particular cities). Contains scripts to simulate and calibrate these instances. <code>SIHR_core</code> Subclasses of <code>clt_base</code> that designate the compartments and structure of a simple S-I-H-R model, without specifying concrete inputs, parameters, or populations. Used as a tutorial example. <code>SIHR_instances</code> Stores data that specifies concrete inputs, parameters, and populations used to construct particular instances of the demo SIHR model in <code>SIHR_core</code>. <code>tests</code> \"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization.\" -- Gerald Weinberg"},{"location":"#toolkit-structure","title":"Toolkit Structure","text":"Folder File Description <code>clt_toolkit/</code> <code>base_components</code> Base classes for fundamental simulation objects, such as subpopulation models, metapopulation models, compartments, and transition variables that manage flow between compartments. <code>base_data_structures</code> Base dataclasses for storing compartment population values, epidemiological parameters, and simulation settings. <code>experiments</code> Tools for running many simulation replications of a model and managing the output. Can handle random sampling of parameters. <code>input_parsers</code> Helper functions for streamlining input reading and validation. <code>plotting</code> Plotting functions. <code>utils</code> Utility functions for convenience."},{"location":"#flu-core-structure","title":"Flu Core Structure","text":"<p>Subclasses for MetroFluSim.</p> Folder File Description <code>flu_core/</code> <code>flu_components</code> Subclasses of <code>clt_base</code> that define the compartments and corresponding logic of MetroFluSim. <code>flu_data_structures</code> Subclasses of dataclasses in <code>base_data_structures</code> that specify the exact fields (compartments, parameters, etc...) needed for MetroFluSim. <code>flu_torch_det_components</code> Deterministic, functional (non-object oriented) version of MetroFluSim that is autodifferentiable with PyTorch and optimized for performance. <code>flu_travel_functions</code> Computes exposure intensity due to local transmission within a subpopulation as well as travel between subpopulations."},{"location":"#flu-model-instances-structure","title":"Flu Model Instances Structure","text":"<p>Code for specific instances of the MetroFluSim model (e.g. for a specific city, with specific inputs, parameters, and populations).  </p> Folder Folder Description <code>flu_instances/</code> <code>calibration_research_input_files/</code> Input files for synthetic flu model instances used to evaluate calibration methods. <code>derived_inputs_computations/</code> Computations generating derived inputs (e.g. age-specific contact matrices). <code>examples/</code> Demo scripts showcasing CLT Toolkit and MetroFluSim functionality, including guides for calibration via optimization with automatic differentiation. <code>texas_flu_hosp_rate_20232024/</code> Publicly available Texas hospitalization data from 2023-2024 flu season. <code>texas_input_files/</code> Most up-to-date parameter values, derived from recent literature or within-host modeling. <p>Updated 08/14/2025. Toolkit and documentation are created by Linda Pei (\"LP\"), with feedback from R\u00e9my Pasco, Susan Ptak, Emily Javan, and other Meyers Lab members, and with supervision from Dave Morton and Lauren Meyers. Special thanks to Cary Murray for generous guidance on software engineering design. Special credit to Shuotao \"Sonny\" Diao for his ideas about updating compartments analogously to pushing flow on a graph and creating simulation logic that works for arbitrarily many compartments and transition variables. </p>"},{"location":"clt_base_package_reference/","title":"CLT Toolkit API Reference","text":"<p>Docstrings and references for <code>clt_toolkit</code> package.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.PROJECT_ROOT","title":"<code>PROJECT_ROOT = Path(__file__).resolve().parent.parent</code>  <code>module-attribute</code>","text":""},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment","title":"<code>Compartment</code>","text":"<p>               Bases: <code>StateVariable</code></p> <p>Class for epidemiological compartments (e.g. Susceptible,     Exposed, Infected, etc...).</p> <p>Attributes:</p> Name Type Description <code>current_inflow</code> <code>np.ndarray of shape (A, R</code> <p>Used to sum up all  transition variable realizations incoming to this compartment for age-risk groups.</p> <code>current_outflow</code> <code>np.ndarray of shape (A, R</code> <p>Used to sum up all transition variable realizations outgoing from this compartment for age-risk groups.</p> <p>See <code>StateVariable</code> docstring for additional attributes     and A, R definitions.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class Compartment(StateVariable):\n    \"\"\"\n    Class for epidemiological compartments (e.g. Susceptible,\n        Exposed, Infected, etc...).\n\n    Attributes:\n        current_inflow (np.ndarray of shape (A, R)):\n            Used to sum up all  transition variable realizations\n            incoming to this compartment for age-risk groups.\n        current_outflow (np.ndarray of shape (A, R)):\n            Used to sum up all transition variable realizations\n            outgoing from this compartment for age-risk groups.\n\n    See `StateVariable` docstring for additional attributes\n        and A, R definitions.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        super().__init__(np.asarray(init_val, dtype=float))\n\n        self.current_inflow = np.zeros(np.shape(init_val))\n        self.current_outflow = np.zeros(np.shape(init_val))\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Updates `current_val` attribute in-place by adding\n            `current_inflow` (sum of all incoming transition variables'\n            realizations) and subtracting current outflow (sum of all\n            outgoing transition variables' realizations).\n        \"\"\"\n        self.current_val = self.current_val + self.current_inflow - self.current_outflow\n\n    def reset_inflow(self) -&gt; None:\n        \"\"\"\n        Resets `current_inflow` attribute to zero array.\n        \"\"\"\n        self.current_inflow = np.zeros(np.shape(self.current_inflow))\n\n    def reset_outflow(self) -&gt; None:\n        \"\"\"\n        Resets `current_outflow` attribute to zero array.\n        \"\"\"\n        self.current_outflow = np.zeros(np.shape(self.current_outflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment.reset_inflow","title":"<code>reset_inflow() -&gt; None</code>","text":"<p>Resets <code>current_inflow</code> attribute to zero array.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_inflow(self) -&gt; None:\n    \"\"\"\n    Resets `current_inflow` attribute to zero array.\n    \"\"\"\n    self.current_inflow = np.zeros(np.shape(self.current_inflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment.reset_outflow","title":"<code>reset_outflow() -&gt; None</code>","text":"<p>Resets <code>current_outflow</code> attribute to zero array.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_outflow(self) -&gt; None:\n    \"\"\"\n    Resets `current_outflow` attribute to zero array.\n    \"\"\"\n    self.current_outflow = np.zeros(np.shape(self.current_outflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment.update_current_val","title":"<code>update_current_val() -&gt; None</code>","text":"<p>Updates <code>current_val</code> attribute in-place by adding     <code>current_inflow</code> (sum of all incoming transition variables'     realizations) and subtracting current outflow (sum of all     outgoing transition variables' realizations).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Updates `current_val` attribute in-place by adding\n        `current_inflow` (sum of all incoming transition variables'\n        realizations) and subtracting current outflow (sum of all\n        outgoing transition variables' realizations).\n    \"\"\"\n    self.current_val = self.current_val + self.current_inflow - self.current_outflow\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DataClassProtocol","title":"<code>DataClassProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>class DataClassProtocol(Protocol):\n    __dataclass_fields__: dict\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DynamicVal","title":"<code>DynamicVal</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that dynamically adjust their values based the current values of other <code>StateVariable</code> instances.</p> <p>This class should model social distancing (and more broadly, staged-alert policies). For example, if we consider a case where transmission rates decrease when number infected increase above a certain level, we can create a subclass of DynamicVal that models a coefficient that modifies transmission rates, depending on the epi compartments corresponding to infected individuals.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class DynamicVal(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that dynamically adjust\n    their values based the current values of other `StateVariable`\n    instances.\n\n    This class should model social distancing (and more broadly,\n    staged-alert policies). For example, if we consider a\n    case where transmission rates decrease when number infected\n    increase above a certain level, we can create a subclass of\n    DynamicVal that models a coefficient that modifies transmission\n    rates, depending on the epi compartments corresponding to\n    infected individuals.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 is_enabled: Optional[bool] = False):\n        \"\"\"\n\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation.\n            is_enabled (Optional[bool]):\n                if `False`, this dynamic value does not get updated\n                during the simulation and defaults to its `init_val`.\n                This is designed to allow easy toggling of\n                simulations with or without staged alert policies\n                and other interventions.\n        \"\"\"\n\n        super().__init__(init_val)\n        self.is_enabled = is_enabled\n\n    @abstractmethod\n    def update_current_val(self,\n                           state: SubpopState,\n                           params: SubpopParams) -&gt; None:\n        \"\"\"\n        Args:\n            state (SubpopState):\n                holds subpopulation simulation state (current values of\n                `StateVariable` instances).\n            params (SubpopParams):\n                holds values of epidemiological parameters.\n        \"\"\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DynamicVal.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, is_enabled: Optional[bool] = False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation.</p> <code>None</code> <code>is_enabled</code> <code>Optional[bool]</code> <p>if <code>False</code>, this dynamic value does not get updated during the simulation and defaults to its <code>init_val</code>. This is designed to allow easy toggling of simulations with or without staged alert policies and other interventions.</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             is_enabled: Optional[bool] = False):\n    \"\"\"\n\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation.\n        is_enabled (Optional[bool]):\n            if `False`, this dynamic value does not get updated\n            during the simulation and defaults to its `init_val`.\n            This is designed to allow easy toggling of\n            simulations with or without staged alert policies\n            and other interventions.\n    \"\"\"\n\n    super().__init__(init_val)\n    self.is_enabled = is_enabled\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DynamicVal.update_current_val","title":"<code>update_current_val(state: SubpopState, params: SubpopParams) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>holds values of epidemiological parameters.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       state: SubpopState,\n                       params: SubpopParams) -&gt; None:\n    \"\"\"\n    Args:\n        state (SubpopState):\n            holds subpopulation simulation state (current values of\n            `StateVariable` instances).\n        params (SubpopParams):\n            holds values of epidemiological parameters.\n    \"\"\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric","title":"<code>EpiMetric</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for epi metrics in epidemiological model.</p> <p>This is intended for variables that are aggregate deterministic functions of the <code>SubpopState</code> (including <code>Compartment</code> <code>current_val</code>'s, other parameters, and time.)</p> <p>For example, population-level immunity variables should be modeled as a <code>EpiMetric</code> subclass, with a concrete implementation of the abstract method <code>get_change_in_current_val</code>.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>Attributes:</p> Name Type Description <code>current_val</code> <code>np.ndarray of shape (A, R</code> <p>same size as init_val, holds current value of <code>StateVariable</code> for age-risk groups.</p> <code>change_in_current_val</code> <p>(np.ndarray of shape (A, R)): initialized to None, but during simulation holds change in current value of <code>EpiMetric</code> for age-risk groups (size A x R, where A is the number of risk groups and R is number of age groups).</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class EpiMetric(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for epi metrics in epidemiological model.\n\n    This is intended for variables that are aggregate deterministic functions of\n    the `SubpopState` (including `Compartment` `current_val`'s, other parameters,\n    and time.)\n\n    For example, population-level immunity variables should be\n    modeled as a `EpiMetric` subclass, with a concrete\n    implementation of the abstract method `get_change_in_current_val`.\n\n    Inherits attributes from `StateVariable`.\n\n    Attributes:\n        current_val (np.ndarray of shape (A, R)):\n            same size as init_val, holds current value of `StateVariable`\n            for age-risk groups.\n        change_in_current_val : (np.ndarray of shape (A, R)):\n            initialized to None, but during simulation holds change in\n            current value of `EpiMetric` for age-risk groups\n            (size A x R, where A is the number of risk groups and R is number\n            of age groups).\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        \"\"\"\n        Args:\n            init_val (np.ndarray of shape (A, R)):\n                2D array that contains nonnegative floats,\n                corresponding to initial value of dynamic val,\n                where i,jth entry corresponds to age group i and\n                risk group j.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.change_in_current_val = None\n\n    @abstractmethod\n    def get_change_in_current_val(self,\n                                  state: SubpopState,\n                                  params: SubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns change in current value of dynamic val,\n        based on current state of the simulation and epidemiological parameters.\n\n        NOTE:\n            OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n\n        Output should be a numpy array of size A x R, where A\n        is number of age groups and R is number of risk groups.\n\n        Args:\n            state (SubpopState):\n                holds subpopulation simulation state (current values of\n                `StateVariable` instances).\n            params (SubpopParams):\n                holds values of epidemiological parameters.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                size A x R, where A is the number of age groups and\n                R is number of risk groups.\n        \"\"\"\n        pass\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Adds `change_in_current_val` attribute to\n        `current_val` attribute in-place.\n        \"\"\"\n\n        self.current_val += self.change_in_current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric.__init__","title":"<code>__init__(init_val)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>np.ndarray of shape (A, R</code> <p>2D array that contains nonnegative floats, corresponding to initial value of dynamic val, where i,jth entry corresponds to age group i and risk group j.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             init_val):\n    \"\"\"\n    Args:\n        init_val (np.ndarray of shape (A, R)):\n            2D array that contains nonnegative floats,\n            corresponding to initial value of dynamic val,\n            where i,jth entry corresponds to age group i and\n            risk group j.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.change_in_current_val = None\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric.get_change_in_current_val","title":"<code>get_change_in_current_val(state: SubpopState, params: SubpopParams, num_timesteps: int) -&gt; np.ndarray</code>  <code>abstractmethod</code>","text":"<p>Computes and returns change in current value of dynamic val, based on current state of the simulation and epidemiological parameters.</p> NOTE <p>OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.</p> <p>Output should be a numpy array of size A x R, where A is number of age groups and R is number of risk groups.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>holds values of epidemiological parameters.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) size A x R, where A is the number of age groups and R is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef get_change_in_current_val(self,\n                              state: SubpopState,\n                              params: SubpopParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns change in current value of dynamic val,\n    based on current state of the simulation and epidemiological parameters.\n\n    NOTE:\n        OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n\n    Output should be a numpy array of size A x R, where A\n    is number of age groups and R is number of risk groups.\n\n    Args:\n        state (SubpopState):\n            holds subpopulation simulation state (current values of\n            `StateVariable` instances).\n        params (SubpopParams):\n            holds values of epidemiological parameters.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            size A x R, where A is the number of age groups and\n            R is number of risk groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric.update_current_val","title":"<code>update_current_val() -&gt; None</code>","text":"<p>Adds <code>change_in_current_val</code> attribute to <code>current_val</code> attribute in-place.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Adds `change_in_current_val` attribute to\n    `current_val` attribute in-place.\n    \"\"\"\n\n    self.current_val += self.change_in_current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment","title":"<code>Experiment</code>","text":"<p>Class to manage running multiple simulation replications on a <code>SubpopModel</code> or <code>MetapopModel</code> instance and query its results.</p> <p>Also allows running a batch of simulation replications on a deterministic sequence of values for a given input (for example, to see how output changes as a function of a given input).</p> <p>Also handles random sampling of inputs from a uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_subpop_models</code> <code>tuple</code> <p>tuple of <code>SubpopModel</code> instances associated with the <code>Experiment</code>. If the <code>Experiment</code> is for a <code>MetapopModel</code>, then this tuple contains all the associated <code>SubpopModel</code> instances that comprise that <code>MetapopModel.</code> If the <code>Experiment</code> is for a <code>SubpopModel</code> only, then this tuple contains only that particular <code>SubpopModel</code>.</p> required <code>results_df</code> <code>DataFrame</code> <p>DataFrame holding simulation results from each <code>simulation</code> replication</p> required <code>has_been_run</code> <code>bool</code> <p>indicates if <code>self.run_static_inputs</code> has been executed.</p> required <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>class Experiment:\n    \"\"\"\n    Class to manage running multiple simulation replications\n    on a `SubpopModel` or `MetapopModel` instance and query its results.\n\n    Also allows running a batch of simulation replications on a\n    deterministic sequence of values for a given input\n    (for example, to see how output changes as a function of\n    a given input).\n\n    Also handles random sampling of inputs from a uniform\n    distribution.\n\n    Params:\n        experiment_subpop_models (tuple):\n            tuple of `SubpopModel` instances associated with the `Experiment`.\n            If the `Experiment` is for a `MetapopModel`, then this tuple\n            contains all the associated `SubpopModel` instances\n            that comprise that `MetapopModel.` If the `Experiment` is for\n            a `SubpopModel` only, then this tuple contains only that\n            particular `SubpopModel`.\n        results_df (pd.DataFrame):\n            DataFrame holding simulation results from each\n            `simulation` replication\n        has_been_run (bool):\n            indicates if `self.run_static_inputs` has been executed.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 model: SubpopModel | MetapopModel,\n                 state_variables_to_record: list,\n                 database_filename: str):\n\n        \"\"\"\n        Params:\n            model (SubpopModel | MetapopModel):\n                SubpopModel or MetapopModel instance on which to\n                run multiple replications.\n            state_variables_to_record (list[str]):\n                list or list-like of strings corresponding to\n                state variables to record -- each string must match\n                a state variable name on each SubpopModel in\n                the MetapopModel.\n            database_filename (str):\n                must be valid filename with suffix \".db\" --\n                experiment results are saved to this SQL database\n        \"\"\"\n\n        self.model = model\n        self.state_variables_to_record = state_variables_to_record\n        self.database_filename = database_filename\n\n        self.has_been_run = False\n\n        # Create experiment_subpop_models tuple\n        # If model is MetapopModel instance, then this tuple is a list\n        #   of all associated SubpopModel instances\n        # If model is a SubpopModel instance, then this tuple\n        #   only contains that SubpopModel.\n        if isinstance(model, MetapopModel):\n            experiment_subpop_models = tuple(model.subpop_models.values())\n        elif isinstance(model, SubpopModel):\n            experiment_subpop_models = (model,)\n        else:\n            raise ExperimentError(\"\\\"model\\\" argument must be an instance of SubpopModel \"\n                                  \"or MetapopModel class.\")\n        self.experiment_subpop_models = experiment_subpop_models\n\n        # Initialize results_df attribute -- this will store\n        #   results of experiment run\n        self.results_df = None\n\n        # Make sure the state variables to record are valid -- the names\n        #   of the state variables to record must match actual state variables\n        #   on each SubpopModel\n        for subpop_model in self.experiment_subpop_models:\n            if not check_is_subset_list(state_variables_to_record,\n                                        subpop_model.all_state_variables.keys()):\n                raise ExperimentError(\n                    f\"\\\"state_variables_to_record\\\" list is not a subset \"\n                    \"of the state variables on SubpopModel \\\"{subpop_name}\\\" -- \"\n                    \"modify \\\"state_variables_to_record\\\" and re-initialize experiment.\")\n\n    def run_static_inputs(self,\n                          num_reps: int,\n                          simulation_end_day: int,\n                          days_between_save_history: int = 1,\n                          results_filename: str = None):\n        \"\"\"\n        Runs the associated `SubpopModel` or `MetapopModel` for a\n        given number of independent replications until `simulation_end_day`.\n        Parameter values and initial values are the same across\n        simulation replications. User can specify how often to save the\n        history and a CSV file in which to store this history.\n\n        Params:\n            num_reps (positive int):\n                number of independent simulation replications\n                to run in an experiment.\n            simulation_end_day (positive int):\n                stop simulation at simulation_end_day (i.e. exclusive,\n                simulate up to but not including simulation_end_day).\n            days_between_save_history (positive int):\n                indicates how often to save simulation results.\n            results_filename (str):\n                if specified, must be valid filename with suffix \".csv\" --\n                experiment results are saved to this CSV file.\n        \"\"\"\n\n        if self.has_been_run:\n            raise ExperimentError(\"Experiment has already been run. \"\n                                  \"Create a new Experiment instance to simulate \"\n                                  \"more replications.\")\n\n        else:\n            self.has_been_run = True\n\n            self.create_results_sql_table()\n\n            self.simulate_reps_and_save_results(reps=num_reps,\n                                                end_day=simulation_end_day,\n                                                days_per_save=days_between_save_history,\n                                                inputs_are_static=True,\n                                                filename=results_filename)\n\n    def get_state_var_df(self,\n                         state_var_name: str,\n                         subpop_name: str = None,\n                         age_group: int = None,\n                         risk_group: int = None,\n                         results_filename: str = None) -&gt; pd.DataFrame:\n        \"\"\"\n        Get pandas DataFrame of recorded values of `StateVariable` given by\n        `state_var_name`, in the `SubpopModel` given by `subpop_name`,\n        for the age-risk group given by `age_group` and `risk_group`.\n        If `subpop_name` is not specified, then values are summed across all\n        associated subpopulations. Similarly, if `age_group` (or `risk_group`)\n        is not specified, then values are summed across all age groups\n        (or risk groups).\n\n        Args:\n            state_var_name (str):\n                Name of the `StateVariable` to retrieve.\n            subpop_name (Optional[str]):\n                The name of the `SubpopModel` for filtering. If None, values are\n                summed across all `SubpopModel` instances.\n            age_group (Optional[int]):\n                The age group to select. If None, values are summed across\n                all age groups.\n            risk_group (Optional[int]):\n                The risk group to select. If None, values are summed across\n                all risk groups.\n            results_filename (Optional[str]):\n                If provided, saves the resulting DataFrame as a CSV.\n\n        Returns:\n            A pandas DataFrame where rows represent the replication and columns indicate the\n            simulation day (timepoint) of recording. DataFrame values are the `StateVariable`'s\n            current_val or the sum of the `StateVariable`'s current_val across subpopulations,\n            age groups, or risk groups (the combination of what is summed over is\n            specified by the user -- details are in the part of this docstring describing\n            this function's parameters).\n        \"\"\"\n\n        if state_var_name not in self.state_variables_to_record:\n            raise ExperimentError(\"\\\"state_var_name\\\" is not in \\\"self.state_variables_to_record\\\" --\"\n                                  \"function call is invalid.\")\n\n        conn = sqlite3.connect(self.database_filename)\n\n        # Query all results table entries where state_var_name matches\n        # This will return results across all subpopulations, age groups,\n        #   and risk groups\n        df = get_sql_table_as_df(conn,\n                                 \"SELECT * FROM results WHERE state_var_name = ?\",\n                                 chunk_size=int(1e4),\n                                 sql_query_params=(state_var_name,))\n\n        conn.close()\n\n        # Define filter conditions\n        filters = {\n            \"subpop_name\": subpop_name,\n            \"age_group\": age_group,\n            \"risk_group\": risk_group\n        }\n\n        # Filter DataFrame based on user-specified conditions\n        #   (for example, if user specifies subpop_name, return subset of\n        #   DataFrame where subpop_name matches)\n        conditions = [(df[col] == value) for col, value in filters.items() if value is not None]\n        df_filtered = df if not conditions else df[np.logical_and.reduce(conditions)]\n\n        # Group DataFrame based on unique combinations of \"rep\" and \"timepoint\" columns\n        # Then sum (numeric values only), return the \"value\" column, and reset the index\n        #   so that \"rep\" and \"timepoint\" become regular columns and are not the index\n        df_aggregated = \\\n            df_filtered.groupby([\"rep\",\n                                 \"timepoint\"]).sum(numeric_only=True)[\"value\"].reset_index()\n\n        # Use pivot() function to reshape the DataFrame for its final form\n        # The \"timepoint\" values are spread across new columns\n        #   (creating a column for each unique timepoint).\n        # The \"value\" column populates the corresponding cells.\n        df_final = df_aggregated.pivot(index=\"rep\",\n                                       columns=\"timepoint\",\n                                       values=\"value\")\n\n        if results_filename:\n            df_final.to_csv(results_filename)\n\n        return df_final\n\n    def log_current_vals_to_sql(self,\n                                rep_counter: int,\n                                experiment_cursor: sqlite3.Cursor) -&gt; None:\n        \"\"\"\n        For each subpopulation and state variable to record\n        associated with this `Experiment`, save current values to\n        \"results\" table in SQL database specified by `experiment_cursor`.\n\n        Params:\n            rep_counter (int):\n                Current replication ID.\n            experiment_cursor (sqlite3.Cursor):\n                Cursor object connected to the database\n                where results should be inserted.\n        \"\"\"\n\n        for subpop_model in self.experiment_subpop_models:\n            for state_var_name in self.state_variables_to_record:\n                data = format_current_val_for_sql(subpop_model,\n                                                  state_var_name,\n                                                  rep_counter)\n                experiment_cursor.executemany(\n                    \"INSERT INTO results VALUES (?, ?, ?, ?, ?, ?, ?)\", data)\n\n    def log_inputs_to_sql(self,\n                          experiment_cursor: sqlite3.Cursor):\n        \"\"\"\n        For each subpopulation, add a new table to SQL\n        database specified by `experiment_cursor`. Each table\n        contains information on inputs that vary across\n        replications (either due to random sampling or\n        user-specified deterministic sequence). Each table\n        contains inputs information from `Experiment` attribute\n        `self.inputs_realizations` for a given subpopulation.\n\n        Params:\n            experiment_cursor (sqlite3.Cursor):\n                Cursor object connected to the database\n                where results should be inserted.\n        \"\"\"\n\n        for subpop_model in self.experiment_subpop_models:\n            table_name = f'\"{subpop_model.name}_inputs\"'\n\n            # Get the column names (dynamically, based on table)\n            experiment_cursor.execute(f\"PRAGMA table_info({table_name})\")\n\n            # Extract column names from the table info\n            # But exclude the column name \"rep\"\n            columns_info = experiment_cursor.fetchall()\n            column_names = [col[1] for col in columns_info if col[1] != \"rep\"]\n\n            # Create a placeholder string for the dynamic query\n            placeholders = \", \".join([\"?\" for _ in column_names])  # Number of placeholders matches number of columns\n\n            # Create the dynamic INSERT statement\n            sql_statement = f\"INSERT INTO {table_name} ({', '.join(column_names)}) VALUES ({placeholders})\"\n\n            # Create list of lists -- each nested list contains a sequence of values\n            #   for that particular input\n            subpop_inputs_realizations = self.inputs_realizations[subpop_model.name]\n            inputs_vals_over_reps_list = \\\n                [np.array(subpop_inputs_realizations[input_name]).reshape(-1,1) for input_name in column_names]\n            inputs_vals_over_reps_list = np.hstack(inputs_vals_over_reps_list)\n\n            experiment_cursor.executemany(sql_statement, inputs_vals_over_reps_list)\n\n    def simulate_reps_and_save_results(self,\n                                       reps: int,\n                                       end_day: int,\n                                       days_per_save: int,\n                                       inputs_are_static: bool,\n                                       filename: str = None):\n        \"\"\"\n        Helper function that executes main loop over\n        replications in `Experiment` and saves results.\n\n        Params:\n            reps (int):\n                number of independent simulation replications\n                to run in an experiment.\n            end_day (int):\n                stop simulation at end_day (i.e. exclusive,\n                simulate up to but not including end_day).\n            days_per_save (int):\n                indicates how often to save simulation results.\n            inputs_are_static (bool):\n                indicates if inputs are same across replications.\n            filename (str):\n                if specified, must be valid filename with suffix \".csv\" --\n                experiment results are saved to this CSV file.\n        \"\"\"\n\n        # Override each subpop simulation_settings's save_daily_history attribute --\n        #   set it to False -- because we will manually save history\n        #   to results database according to user-defined\n        #   days_between_save_history for all subpops\n        for subpop_model in self.experiment_subpop_models:\n            subpop_model.simulation_settings = \\\n                updated_dataclass(subpop_model.simulation_settings, {\"save_daily_history\": False})\n\n        model = self.model\n\n        # Connect to SQL database\n        conn = sqlite3.connect(self.database_filename)\n        cursor = conn.cursor()\n\n        # Loop through replications\n        for rep in range(reps):\n\n            # Reset model and clear its history\n            model.reset_simulation()\n\n            # Simulate model and save results every `days_per_save` days\n            while model.current_simulation_day &lt; end_day:\n                model.simulate_until_day(min(model.current_simulation_day + days_per_save,\n                                             end_day))\n\n                self.log_current_vals_to_sql(rep, cursor)\n\n        self.results_df = get_sql_table_as_df(conn, \"SELECT * FROM results\", chunk_size=int(1e4))\n\n        if filename:\n            self.results_df.to_csv(filename)\n\n        # Commit changes to database and close\n        conn.commit()\n        conn.close()\n\n    def create_results_sql_table(self):\n        \"\"\"\n        Create SQL database and save to `self.database_filename`.\n        Create table named `results` with columns `subpop_name`,\n        `state_var_name`, `age_group`, `risk_group`, `rep`, `timepoint`,\n        and `value` to store results from each replication of experiment.\n        \"\"\"\n\n        # Make sure user is not overwriting database\n        if os.path.exists(self.database_filename):\n            raise ExperimentError(\"Database already exists! Overwriting is not allowed. \"\n                                  \"Delete existing .db file or change database_filename \"\n                                  \"attribute.\")\n\n        # Connect to the SQLite database and create database\n        # Create a cursor object to execute SQL commands\n        # Initialize a table with columns given by column_names\n        # Commit changes and close the connection\n        conn = sqlite3.connect(self.database_filename)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS results (\n            subpop_name TEXT,\n            state_var_name TEXT,\n            age_group INT,\n            risk_group INT,\n            rep INT,\n            timepoint INT,\n            value FLOAT,\n            PRIMARY KEY (subpop_name, state_var_name, age_group, risk_group, rep, timepoint)\n        )\n        \"\"\")\n        conn.commit()\n        conn.close()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment.__init__","title":"<code>__init__(model: SubpopModel | MetapopModel, state_variables_to_record: list, database_filename: str)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>SubpopModel | MetapopModel</code> <p>SubpopModel or MetapopModel instance on which to run multiple replications.</p> required <code>state_variables_to_record</code> <code>list[str]</code> <p>list or list-like of strings corresponding to state variables to record -- each string must match a state variable name on each SubpopModel in the MetapopModel.</p> required <code>database_filename</code> <code>str</code> <p>must be valid filename with suffix \".db\" -- experiment results are saved to this SQL database</p> required Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def __init__(self,\n             model: SubpopModel | MetapopModel,\n             state_variables_to_record: list,\n             database_filename: str):\n\n    \"\"\"\n    Params:\n        model (SubpopModel | MetapopModel):\n            SubpopModel or MetapopModel instance on which to\n            run multiple replications.\n        state_variables_to_record (list[str]):\n            list or list-like of strings corresponding to\n            state variables to record -- each string must match\n            a state variable name on each SubpopModel in\n            the MetapopModel.\n        database_filename (str):\n            must be valid filename with suffix \".db\" --\n            experiment results are saved to this SQL database\n    \"\"\"\n\n    self.model = model\n    self.state_variables_to_record = state_variables_to_record\n    self.database_filename = database_filename\n\n    self.has_been_run = False\n\n    # Create experiment_subpop_models tuple\n    # If model is MetapopModel instance, then this tuple is a list\n    #   of all associated SubpopModel instances\n    # If model is a SubpopModel instance, then this tuple\n    #   only contains that SubpopModel.\n    if isinstance(model, MetapopModel):\n        experiment_subpop_models = tuple(model.subpop_models.values())\n    elif isinstance(model, SubpopModel):\n        experiment_subpop_models = (model,)\n    else:\n        raise ExperimentError(\"\\\"model\\\" argument must be an instance of SubpopModel \"\n                              \"or MetapopModel class.\")\n    self.experiment_subpop_models = experiment_subpop_models\n\n    # Initialize results_df attribute -- this will store\n    #   results of experiment run\n    self.results_df = None\n\n    # Make sure the state variables to record are valid -- the names\n    #   of the state variables to record must match actual state variables\n    #   on each SubpopModel\n    for subpop_model in self.experiment_subpop_models:\n        if not check_is_subset_list(state_variables_to_record,\n                                    subpop_model.all_state_variables.keys()):\n            raise ExperimentError(\n                f\"\\\"state_variables_to_record\\\" list is not a subset \"\n                \"of the state variables on SubpopModel \\\"{subpop_name}\\\" -- \"\n                \"modify \\\"state_variables_to_record\\\" and re-initialize experiment.\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment.create_results_sql_table","title":"<code>create_results_sql_table()</code>","text":"<p>Create SQL database and save to <code>self.database_filename</code>. Create table named <code>results</code> with columns <code>subpop_name</code>, <code>state_var_name</code>, <code>age_group</code>, <code>risk_group</code>, <code>rep</code>, <code>timepoint</code>, and <code>value</code> to store results from each replication of experiment.</p> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def create_results_sql_table(self):\n    \"\"\"\n    Create SQL database and save to `self.database_filename`.\n    Create table named `results` with columns `subpop_name`,\n    `state_var_name`, `age_group`, `risk_group`, `rep`, `timepoint`,\n    and `value` to store results from each replication of experiment.\n    \"\"\"\n\n    # Make sure user is not overwriting database\n    if os.path.exists(self.database_filename):\n        raise ExperimentError(\"Database already exists! Overwriting is not allowed. \"\n                              \"Delete existing .db file or change database_filename \"\n                              \"attribute.\")\n\n    # Connect to the SQLite database and create database\n    # Create a cursor object to execute SQL commands\n    # Initialize a table with columns given by column_names\n    # Commit changes and close the connection\n    conn = sqlite3.connect(self.database_filename)\n    cursor = conn.cursor()\n    cursor.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS results (\n        subpop_name TEXT,\n        state_var_name TEXT,\n        age_group INT,\n        risk_group INT,\n        rep INT,\n        timepoint INT,\n        value FLOAT,\n        PRIMARY KEY (subpop_name, state_var_name, age_group, risk_group, rep, timepoint)\n    )\n    \"\"\")\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment.get_state_var_df","title":"<code>get_state_var_df(state_var_name: str, subpop_name: str = None, age_group: int = None, risk_group: int = None, results_filename: str = None) -&gt; pd.DataFrame</code>","text":"<p>Get pandas DataFrame of recorded values of <code>StateVariable</code> given by <code>state_var_name</code>, in the <code>SubpopModel</code> given by <code>subpop_name</code>, for the age-risk group given by <code>age_group</code> and <code>risk_group</code>. If <code>subpop_name</code> is not specified, then values are summed across all associated subpopulations. Similarly, if <code>age_group</code> (or <code>risk_group</code>) is not specified, then values are summed across all age groups (or risk groups).</p> <p>Parameters:</p> Name Type Description Default <code>state_var_name</code> <code>str</code> <p>Name of the <code>StateVariable</code> to retrieve.</p> required <code>subpop_name</code> <code>Optional[str]</code> <p>The name of the <code>SubpopModel</code> for filtering. If None, values are summed across all <code>SubpopModel</code> instances.</p> <code>None</code> <code>age_group</code> <code>Optional[int]</code> <p>The age group to select. If None, values are summed across all age groups.</p> <code>None</code> <code>risk_group</code> <code>Optional[int]</code> <p>The risk group to select. If None, values are summed across all risk groups.</p> <code>None</code> <code>results_filename</code> <code>Optional[str]</code> <p>If provided, saves the resulting DataFrame as a CSV.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame where rows represent the replication and columns indicate the</p> <code>DataFrame</code> <p>simulation day (timepoint) of recording. DataFrame values are the <code>StateVariable</code>'s</p> <code>DataFrame</code> <p>current_val or the sum of the <code>StateVariable</code>'s current_val across subpopulations,</p> <code>DataFrame</code> <p>age groups, or risk groups (the combination of what is summed over is</p> <code>DataFrame</code> <p>specified by the user -- details are in the part of this docstring describing</p> <code>DataFrame</code> <p>this function's parameters).</p> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def get_state_var_df(self,\n                     state_var_name: str,\n                     subpop_name: str = None,\n                     age_group: int = None,\n                     risk_group: int = None,\n                     results_filename: str = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Get pandas DataFrame of recorded values of `StateVariable` given by\n    `state_var_name`, in the `SubpopModel` given by `subpop_name`,\n    for the age-risk group given by `age_group` and `risk_group`.\n    If `subpop_name` is not specified, then values are summed across all\n    associated subpopulations. Similarly, if `age_group` (or `risk_group`)\n    is not specified, then values are summed across all age groups\n    (or risk groups).\n\n    Args:\n        state_var_name (str):\n            Name of the `StateVariable` to retrieve.\n        subpop_name (Optional[str]):\n            The name of the `SubpopModel` for filtering. If None, values are\n            summed across all `SubpopModel` instances.\n        age_group (Optional[int]):\n            The age group to select. If None, values are summed across\n            all age groups.\n        risk_group (Optional[int]):\n            The risk group to select. If None, values are summed across\n            all risk groups.\n        results_filename (Optional[str]):\n            If provided, saves the resulting DataFrame as a CSV.\n\n    Returns:\n        A pandas DataFrame where rows represent the replication and columns indicate the\n        simulation day (timepoint) of recording. DataFrame values are the `StateVariable`'s\n        current_val or the sum of the `StateVariable`'s current_val across subpopulations,\n        age groups, or risk groups (the combination of what is summed over is\n        specified by the user -- details are in the part of this docstring describing\n        this function's parameters).\n    \"\"\"\n\n    if state_var_name not in self.state_variables_to_record:\n        raise ExperimentError(\"\\\"state_var_name\\\" is not in \\\"self.state_variables_to_record\\\" --\"\n                              \"function call is invalid.\")\n\n    conn = sqlite3.connect(self.database_filename)\n\n    # Query all results table entries where state_var_name matches\n    # This will return results across all subpopulations, age groups,\n    #   and risk groups\n    df = get_sql_table_as_df(conn,\n                             \"SELECT * FROM results WHERE state_var_name = ?\",\n                             chunk_size=int(1e4),\n                             sql_query_params=(state_var_name,))\n\n    conn.close()\n\n    # Define filter conditions\n    filters = {\n        \"subpop_name\": subpop_name,\n        \"age_group\": age_group,\n        \"risk_group\": risk_group\n    }\n\n    # Filter DataFrame based on user-specified conditions\n    #   (for example, if user specifies subpop_name, return subset of\n    #   DataFrame where subpop_name matches)\n    conditions = [(df[col] == value) for col, value in filters.items() if value is not None]\n    df_filtered = df if not conditions else df[np.logical_and.reduce(conditions)]\n\n    # Group DataFrame based on unique combinations of \"rep\" and \"timepoint\" columns\n    # Then sum (numeric values only), return the \"value\" column, and reset the index\n    #   so that \"rep\" and \"timepoint\" become regular columns and are not the index\n    df_aggregated = \\\n        df_filtered.groupby([\"rep\",\n                             \"timepoint\"]).sum(numeric_only=True)[\"value\"].reset_index()\n\n    # Use pivot() function to reshape the DataFrame for its final form\n    # The \"timepoint\" values are spread across new columns\n    #   (creating a column for each unique timepoint).\n    # The \"value\" column populates the corresponding cells.\n    df_final = df_aggregated.pivot(index=\"rep\",\n                                   columns=\"timepoint\",\n                                   values=\"value\")\n\n    if results_filename:\n        df_final.to_csv(results_filename)\n\n    return df_final\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment.log_current_vals_to_sql","title":"<code>log_current_vals_to_sql(rep_counter: int, experiment_cursor: sqlite3.Cursor) -&gt; None</code>","text":"<p>For each subpopulation and state variable to record associated with this <code>Experiment</code>, save current values to \"results\" table in SQL database specified by <code>experiment_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rep_counter</code> <code>int</code> <p>Current replication ID.</p> required <code>experiment_cursor</code> <code>Cursor</code> <p>Cursor object connected to the database where results should be inserted.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def log_current_vals_to_sql(self,\n                            rep_counter: int,\n                            experiment_cursor: sqlite3.Cursor) -&gt; None:\n    \"\"\"\n    For each subpopulation and state variable to record\n    associated with this `Experiment`, save current values to\n    \"results\" table in SQL database specified by `experiment_cursor`.\n\n    Params:\n        rep_counter (int):\n            Current replication ID.\n        experiment_cursor (sqlite3.Cursor):\n            Cursor object connected to the database\n            where results should be inserted.\n    \"\"\"\n\n    for subpop_model in self.experiment_subpop_models:\n        for state_var_name in self.state_variables_to_record:\n            data = format_current_val_for_sql(subpop_model,\n                                              state_var_name,\n                                              rep_counter)\n            experiment_cursor.executemany(\n                \"INSERT INTO results VALUES (?, ?, ?, ?, ?, ?, ?)\", data)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment.log_inputs_to_sql","title":"<code>log_inputs_to_sql(experiment_cursor: sqlite3.Cursor)</code>","text":"<p>For each subpopulation, add a new table to SQL database specified by <code>experiment_cursor</code>. Each table contains information on inputs that vary across replications (either due to random sampling or user-specified deterministic sequence). Each table contains inputs information from <code>Experiment</code> attribute <code>self.inputs_realizations</code> for a given subpopulation.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_cursor</code> <code>Cursor</code> <p>Cursor object connected to the database where results should be inserted.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def log_inputs_to_sql(self,\n                      experiment_cursor: sqlite3.Cursor):\n    \"\"\"\n    For each subpopulation, add a new table to SQL\n    database specified by `experiment_cursor`. Each table\n    contains information on inputs that vary across\n    replications (either due to random sampling or\n    user-specified deterministic sequence). Each table\n    contains inputs information from `Experiment` attribute\n    `self.inputs_realizations` for a given subpopulation.\n\n    Params:\n        experiment_cursor (sqlite3.Cursor):\n            Cursor object connected to the database\n            where results should be inserted.\n    \"\"\"\n\n    for subpop_model in self.experiment_subpop_models:\n        table_name = f'\"{subpop_model.name}_inputs\"'\n\n        # Get the column names (dynamically, based on table)\n        experiment_cursor.execute(f\"PRAGMA table_info({table_name})\")\n\n        # Extract column names from the table info\n        # But exclude the column name \"rep\"\n        columns_info = experiment_cursor.fetchall()\n        column_names = [col[1] for col in columns_info if col[1] != \"rep\"]\n\n        # Create a placeholder string for the dynamic query\n        placeholders = \", \".join([\"?\" for _ in column_names])  # Number of placeholders matches number of columns\n\n        # Create the dynamic INSERT statement\n        sql_statement = f\"INSERT INTO {table_name} ({', '.join(column_names)}) VALUES ({placeholders})\"\n\n        # Create list of lists -- each nested list contains a sequence of values\n        #   for that particular input\n        subpop_inputs_realizations = self.inputs_realizations[subpop_model.name]\n        inputs_vals_over_reps_list = \\\n            [np.array(subpop_inputs_realizations[input_name]).reshape(-1,1) for input_name in column_names]\n        inputs_vals_over_reps_list = np.hstack(inputs_vals_over_reps_list)\n\n        experiment_cursor.executemany(sql_statement, inputs_vals_over_reps_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment.run_static_inputs","title":"<code>run_static_inputs(num_reps: int, simulation_end_day: int, days_between_save_history: int = 1, results_filename: str = None)</code>","text":"<p>Runs the associated <code>SubpopModel</code> or <code>MetapopModel</code> for a given number of independent replications until <code>simulation_end_day</code>. Parameter values and initial values are the same across simulation replications. User can specify how often to save the history and a CSV file in which to store this history.</p> <p>Parameters:</p> Name Type Description Default <code>num_reps</code> <code>positive int</code> <p>number of independent simulation replications to run in an experiment.</p> required <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at simulation_end_day (i.e. exclusive, simulate up to but not including simulation_end_day).</p> required <code>days_between_save_history</code> <code>positive int</code> <p>indicates how often to save simulation results.</p> <code>1</code> <code>results_filename</code> <code>str</code> <p>if specified, must be valid filename with suffix \".csv\" -- experiment results are saved to this CSV file.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def run_static_inputs(self,\n                      num_reps: int,\n                      simulation_end_day: int,\n                      days_between_save_history: int = 1,\n                      results_filename: str = None):\n    \"\"\"\n    Runs the associated `SubpopModel` or `MetapopModel` for a\n    given number of independent replications until `simulation_end_day`.\n    Parameter values and initial values are the same across\n    simulation replications. User can specify how often to save the\n    history and a CSV file in which to store this history.\n\n    Params:\n        num_reps (positive int):\n            number of independent simulation replications\n            to run in an experiment.\n        simulation_end_day (positive int):\n            stop simulation at simulation_end_day (i.e. exclusive,\n            simulate up to but not including simulation_end_day).\n        days_between_save_history (positive int):\n            indicates how often to save simulation results.\n        results_filename (str):\n            if specified, must be valid filename with suffix \".csv\" --\n            experiment results are saved to this CSV file.\n    \"\"\"\n\n    if self.has_been_run:\n        raise ExperimentError(\"Experiment has already been run. \"\n                              \"Create a new Experiment instance to simulate \"\n                              \"more replications.\")\n\n    else:\n        self.has_been_run = True\n\n        self.create_results_sql_table()\n\n        self.simulate_reps_and_save_results(reps=num_reps,\n                                            end_day=simulation_end_day,\n                                            days_per_save=days_between_save_history,\n                                            inputs_are_static=True,\n                                            filename=results_filename)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Experiment.simulate_reps_and_save_results","title":"<code>simulate_reps_and_save_results(reps: int, end_day: int, days_per_save: int, inputs_are_static: bool, filename: str = None)</code>","text":"<p>Helper function that executes main loop over replications in <code>Experiment</code> and saves results.</p> <p>Parameters:</p> Name Type Description Default <code>reps</code> <code>int</code> <p>number of independent simulation replications to run in an experiment.</p> required <code>end_day</code> <code>int</code> <p>stop simulation at end_day (i.e. exclusive, simulate up to but not including end_day).</p> required <code>days_per_save</code> <code>int</code> <p>indicates how often to save simulation results.</p> required <code>inputs_are_static</code> <code>bool</code> <p>indicates if inputs are same across replications.</p> required <code>filename</code> <code>str</code> <p>if specified, must be valid filename with suffix \".csv\" -- experiment results are saved to this CSV file.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def simulate_reps_and_save_results(self,\n                                   reps: int,\n                                   end_day: int,\n                                   days_per_save: int,\n                                   inputs_are_static: bool,\n                                   filename: str = None):\n    \"\"\"\n    Helper function that executes main loop over\n    replications in `Experiment` and saves results.\n\n    Params:\n        reps (int):\n            number of independent simulation replications\n            to run in an experiment.\n        end_day (int):\n            stop simulation at end_day (i.e. exclusive,\n            simulate up to but not including end_day).\n        days_per_save (int):\n            indicates how often to save simulation results.\n        inputs_are_static (bool):\n            indicates if inputs are same across replications.\n        filename (str):\n            if specified, must be valid filename with suffix \".csv\" --\n            experiment results are saved to this CSV file.\n    \"\"\"\n\n    # Override each subpop simulation_settings's save_daily_history attribute --\n    #   set it to False -- because we will manually save history\n    #   to results database according to user-defined\n    #   days_between_save_history for all subpops\n    for subpop_model in self.experiment_subpop_models:\n        subpop_model.simulation_settings = \\\n            updated_dataclass(subpop_model.simulation_settings, {\"save_daily_history\": False})\n\n    model = self.model\n\n    # Connect to SQL database\n    conn = sqlite3.connect(self.database_filename)\n    cursor = conn.cursor()\n\n    # Loop through replications\n    for rep in range(reps):\n\n        # Reset model and clear its history\n        model.reset_simulation()\n\n        # Simulate model and save results every `days_per_save` days\n        while model.current_simulation_day &lt; end_day:\n            model.simulate_until_day(min(model.current_simulation_day + days_per_save,\n                                         end_day))\n\n            self.log_current_vals_to_sql(rep, cursor)\n\n    self.results_df = get_sql_table_as_df(conn, \"SELECT * FROM results\", chunk_size=int(1e4))\n\n    if filename:\n        self.results_df.to_csv(filename)\n\n    # Commit changes to database and close\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.ExperimentError","title":"<code>ExperimentError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for experiment errors.</p> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>class ExperimentError(Exception):\n    \"\"\"Custom exceptions for experiment errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.InteractionTerm","title":"<code>InteractionTerm</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that depend on the state of more than one <code>SubpopModel</code> (i.e., that depend on more than one <code>SubpopState</code>). These variables are functions of how subpopulations interact.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class InteractionTerm(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that depend on the state of\n    more than one `SubpopModel` (i.e., that depend on more than one\n    `SubpopState`). These variables are functions of how subpopulations\n    interact.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    @abstractmethod\n    def update_current_val(self,\n                           subpop_state: SubpopState,\n                           subpop_params: SubpopParams) -&gt; None:\n        \"\"\"\n        Subclasses must provide a concrete implementation of\n        updating `current_val` in-place.\n\n        Args:\n            subpop_params (SubpopParams):\n                holds values of subpopulation's epidemiological parameters.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.InteractionTerm.update_current_val","title":"<code>update_current_val(subpop_state: SubpopState, subpop_params: SubpopParams) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Subclasses must provide a concrete implementation of updating <code>current_val</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_params</code> <code>SubpopParams</code> <p>holds values of subpopulation's epidemiological parameters.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       subpop_state: SubpopState,\n                       subpop_params: SubpopParams) -&gt; None:\n    \"\"\"\n    Subclasses must provide a concrete implementation of\n    updating `current_val` in-place.\n\n    Args:\n        subpop_params (SubpopParams):\n            holds values of subpopulation's epidemiological parameters.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.JointTransitionTypes","title":"<code>JointTransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines available options for <code>transition_type</code> in <code>TransitionVariableGroup</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>class JointTransitionTypes(str, Enum):\n    \"\"\"\n    Defines available options for `transition_type` in `TransitionVariableGroup`.\n    \"\"\"\n    MULTINOM = \"multinom\"\n    MULTINOM_DETERMINISTIC = \"multinom_deterministic\"\n    MULTINOM_TAYLOR_APPROX = \"multinom_taylor_approx\"\n    MULTINOM_TAYLOR_APPROX_DETERMINISTIC = \"multinom_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel","title":"<code>MetapopModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class that bundles <code>SubpopModel</code>s linked using     a travel model.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class MetapopModel(ABC):\n    \"\"\"\n    Abstract base class that bundles `SubpopModel`s linked using\n        a travel model.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_models: list[dict],\n                 mixing_params: dict,\n                 name: str = \"\"):\n        \"\"\"\n        Params:\n            name (str):\n                unique identifier for `MetapopModel`.\n        \"\"\"\n\n        settings_list = [subpop.simulation_settings for subpop in subpop_models]\n        first_settings = settings_list[0]\n        if not all(s == first_settings for s in settings_list[1:]):\n            raise MetapopModelError(\"Each FluSubpopModel must have same simulation settings.\")\n\n        # We use both an `objdict` and an `odict` (ordered):\n        # - `objdict`: allows convenient dot-access for users (consistent with the rest of the model)\n        # - `odict`: preserves the order of subpopulations, which is crucial because\n        #   the index in the state and parameter tensors depends on it.\n        # The `objdict` is \"outwards-facing\" for user access, while the `odict`\n        # is used internally to ensure tensor indices are consistent.\n\n        subpop_models_dict = sc.objdict()\n        for model in subpop_models:\n            subpop_models_dict[model.name] = model\n\n        _subpop_models_ordered_dict = sc.odict()\n        for model in subpop_models:\n            _subpop_models_ordered_dict[model.name] = model\n\n        self.subpop_models = subpop_models_dict\n        self._subpop_models_ordered = _subpop_models_ordered_dict\n\n        self.name = name\n\n        # Concrete implementations of `MetapopModel` will generally\n        #   do something more with these parameters -- but this is\n        #   just default storage here\n        self.mixing_params = mixing_params\n\n        for model in self.subpop_models.values():\n            model.metapop_model = self\n\n        self.run_input_checks()\n\n    def __getattr__(self, name):\n        \"\"\"\n        Called if normal attribute lookup fails.\n        Delegate to `subpop_models` if name matches a key.\n        \"\"\"\n\n        if name in self.subpop_models:\n            return self.subpop_models[name]\n        else:\n            raise AttributeError(f\"{type(self).__name__!r} object has no attribute {name!r}\")\n\n    def run_input_checks(self) -&gt; None:\n        \"\"\"\n        Run input checks to ensure that the provided inputs are valid.\n        Subclasses can override this method to add additional checks.\n        If inputs don't make sense we raise a MetapopModelError, and\n        in some cases only a warning is issued.\n        \"\"\"\n\n        pass\n\n    def modify_simulation_settings(self,\n                                   updates_dict: dict):\n        \"\"\"\n        This method applies the changes specified in `updates_dict` to the\n        `simulation_settings` attribute of each subpopulation model.\n        `SimulationSettings` is a frozen dataclass to prevent users from\n        mutating individual subpop settings directly and making subpop\n        models have different settings within the same metapop model.\n        Instead, a new instance is created with the requested updates.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `SimulationSettings` instance -- keys must match the\n                field names of `SimulationSettings`.\n        \"\"\"\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.modify_simulation_settings(updates_dict)\n\n    def simulate_until_day(self,\n                           simulation_end_day: int) -&gt; None:\n        \"\"\"\n        Advance simulation model time until `simulation_end_day` in\n        `MetapopModel`.\n\n        NOT just the same as looping through each `SubpopModel`'s\n        `simulate_until_day` method. On the `MetapopModel`,\n        because `SubpopModel` instances are linked with `InteractionTerm`s\n        and are not independent of each other, this `MetapopModel`'s\n        `simulate_until_day` method has additional functionality.\n\n        Note: the update order at the beginning of each day is very important!\n\n        - First, each `SubpopModel` updates its daily state (computing\n        `Schedule` and `DynamicVal` instances).\n\n        - Second, the `MetapopModel` computes quantities that depend\n        on more than one subpopulation (i.e. inter-subpop quantities,\n        such as the force of infection to each subpopulation in a travel\n        model, where these terms depend on the number infected in\n        other subpopulations) and then applies the update to each\n        `SubpopModel` according to the user-implemented method\n        `apply_inter_subpop_updates.`\n\n        - Third, each `SubpopModel` simulates discretized timesteps (sampling\n        `TransitionVariable`s, updating `EpiMetric`s, and updating `Compartment`s).\n\n        Note: we only update inter-subpop quantities once a day, not at every timestep\n        -- in other words, the travel model state-dependent values are only\n        updated daily -- this is to avoid severe computation inefficiency\n\n        Args:\n            simulation_end_day (positive int):\n                stop simulation at `simulation_end_day` (i.e. exclusive,\n                simulate up to but not including `simulation_end_day`).\n        \"\"\"\n\n        if self.current_simulation_day &gt; simulation_end_day:\n            raise MetapopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                    f\"exceeds last simulation day ({simulation_end_day}).\")\n\n        # Adding this in case the user manually changes the initial\n        #   value or current value of any state variable --\n        #   otherwise, the state will not get updated\n        # Analogous logic in SubpopModel's `simulate_until_day` method\n        for subpop_model in self.subpop_models.values():\n            subpop_model.state.sync_to_current_vals(subpop_model.all_state_variables)\n\n        while self.current_simulation_day &lt; simulation_end_day:\n\n            for subpop_model in self.subpop_models.values():\n                subpop_model.prepare_daily_state()\n\n            self.apply_inter_subpop_updates()\n\n            for subpop_model in self.subpop_models.values():\n                save_daily_history = subpop_model.simulation_settings.save_daily_history\n                timesteps_per_day = subpop_model.simulation_settings.timesteps_per_day\n\n                subpop_model._simulate_timesteps(timesteps_per_day)\n\n                if save_daily_history:\n                    subpop_model.save_daily_history()\n\n                subpop_model.increment_simulation_day()\n\n    def apply_inter_subpop_updates(self):\n        \"\"\"\n        `MetapopModel` subclasses can **optionally** override this method\n        with a customized implementation. Otherwise, by default does nothing.\n\n        Called once a day (not for each discretized timestep), after each\n        subpop model's daily state is prepared, and before\n        discretized transitions are computed.\n\n        This method computes quantities that depend on multiple subpopulations\n        (e.g. this is where a travel model should be implemented).\n\n        See `simulate_until_day` method for more details.\n        \"\"\"\n\n        pass\n\n    def reset_simulation(self):\n        \"\"\"\n        Resets `MetapopModel` by resetting and clearing\n        history on all `SubpopModel` instances in\n        `subpop_models`.\n        \"\"\"\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.reset_simulation()\n\n    @property\n    def current_simulation_day(self) -&gt; int:\n        \"\"\"\n        Returns:\n            Current simulation day. The current simulation day of the\n            `MetapopModel` should be the same as each individual `SubpopModel`\n            in the `MetapopModel`. Otherwise, an error is raised.\n        \"\"\"\n\n        current_simulation_days_list = []\n\n        for subpop_model in self.subpop_models.values():\n            current_simulation_days_list.append(subpop_model.current_simulation_day)\n\n        if len(set(current_simulation_days_list)) &gt; 1:\n            raise MetapopModelError(\"Subpopulation models are on different simulation days \"\n                                    \"and are out-of-sync. This may be caused by simulating \"\n                                    \"a subpopulation model independently from the \"\n                                    \"metapopulation model. Fix error and try again.\")\n        else:\n            return current_simulation_days_list[0]\n\n    @property\n    def current_real_date(self) -&gt; datetime.date:\n        \"\"\"\n        Returns:\n            Current real date corresponding to current simulation day.\n            The current real date of the `MetapopModel` should be the same as\n            each individual `SubpopModel` in the `MetapopModel`.\n            Otherwise, an error is raised.\n        \"\"\"\n\n        current_real_dates_list = []\n\n        for subpop_model in self.subpop_models.values():\n            current_real_dates_list.append(subpop_model.current_real_date)\n\n        if len(set(current_real_dates_list)) &gt; 1:\n            raise MetapopModelError(\"Subpopulation models are on different real dates \\n\"\n                                    \"and are out-of-sync. This may be caused by simulating \\n\"\n                                    \"a subpopulation model independently from the \\n\"\n                                    \"metapopulation model. Please reset and restart simulation, \\n\"\n                                    \"and try again.\")\n        else:\n            return current_real_dates_list[0]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.current_real_date","title":"<code>current_real_date: datetime.date</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>date</code> <p>Current real date corresponding to current simulation day.</p> <code>date</code> <p>The current real date of the <code>MetapopModel</code> should be the same as</p> <code>date</code> <p>each individual <code>SubpopModel</code> in the <code>MetapopModel</code>.</p> <code>date</code> <p>Otherwise, an error is raised.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.current_simulation_day","title":"<code>current_simulation_day: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>Current simulation day. The current simulation day of the</p> <code>int</code> <p><code>MetapopModel</code> should be the same as each individual <code>SubpopModel</code></p> <code>int</code> <p>in the <code>MetapopModel</code>. Otherwise, an error is raised.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Called if normal attribute lookup fails. Delegate to <code>subpop_models</code> if name matches a key.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"\n    Called if normal attribute lookup fails.\n    Delegate to `subpop_models` if name matches a key.\n    \"\"\"\n\n    if name in self.subpop_models:\n        return self.subpop_models[name]\n    else:\n        raise AttributeError(f\"{type(self).__name__!r} object has no attribute {name!r}\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.__init__","title":"<code>__init__(subpop_models: list[dict], mixing_params: dict, name: str = '')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>unique identifier for <code>MetapopModel</code>.</p> <code>''</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             subpop_models: list[dict],\n             mixing_params: dict,\n             name: str = \"\"):\n    \"\"\"\n    Params:\n        name (str):\n            unique identifier for `MetapopModel`.\n    \"\"\"\n\n    settings_list = [subpop.simulation_settings for subpop in subpop_models]\n    first_settings = settings_list[0]\n    if not all(s == first_settings for s in settings_list[1:]):\n        raise MetapopModelError(\"Each FluSubpopModel must have same simulation settings.\")\n\n    # We use both an `objdict` and an `odict` (ordered):\n    # - `objdict`: allows convenient dot-access for users (consistent with the rest of the model)\n    # - `odict`: preserves the order of subpopulations, which is crucial because\n    #   the index in the state and parameter tensors depends on it.\n    # The `objdict` is \"outwards-facing\" for user access, while the `odict`\n    # is used internally to ensure tensor indices are consistent.\n\n    subpop_models_dict = sc.objdict()\n    for model in subpop_models:\n        subpop_models_dict[model.name] = model\n\n    _subpop_models_ordered_dict = sc.odict()\n    for model in subpop_models:\n        _subpop_models_ordered_dict[model.name] = model\n\n    self.subpop_models = subpop_models_dict\n    self._subpop_models_ordered = _subpop_models_ordered_dict\n\n    self.name = name\n\n    # Concrete implementations of `MetapopModel` will generally\n    #   do something more with these parameters -- but this is\n    #   just default storage here\n    self.mixing_params = mixing_params\n\n    for model in self.subpop_models.values():\n        model.metapop_model = self\n\n    self.run_input_checks()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.apply_inter_subpop_updates","title":"<code>apply_inter_subpop_updates()</code>","text":"<p><code>MetapopModel</code> subclasses can optionally override this method with a customized implementation. Otherwise, by default does nothing.</p> <p>Called once a day (not for each discretized timestep), after each subpop model's daily state is prepared, and before discretized transitions are computed.</p> <p>This method computes quantities that depend on multiple subpopulations (e.g. this is where a travel model should be implemented).</p> <p>See <code>simulate_until_day</code> method for more details.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def apply_inter_subpop_updates(self):\n    \"\"\"\n    `MetapopModel` subclasses can **optionally** override this method\n    with a customized implementation. Otherwise, by default does nothing.\n\n    Called once a day (not for each discretized timestep), after each\n    subpop model's daily state is prepared, and before\n    discretized transitions are computed.\n\n    This method computes quantities that depend on multiple subpopulations\n    (e.g. this is where a travel model should be implemented).\n\n    See `simulate_until_day` method for more details.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.modify_simulation_settings","title":"<code>modify_simulation_settings(updates_dict: dict)</code>","text":"<p>This method applies the changes specified in <code>updates_dict</code> to the <code>simulation_settings</code> attribute of each subpopulation model. <code>SimulationSettings</code> is a frozen dataclass to prevent users from mutating individual subpop settings directly and making subpop models have different settings within the same metapop model. Instead, a new instance is created with the requested updates.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>SimulationSettings</code> instance -- keys must match the field names of <code>SimulationSettings</code>.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def modify_simulation_settings(self,\n                               updates_dict: dict):\n    \"\"\"\n    This method applies the changes specified in `updates_dict` to the\n    `simulation_settings` attribute of each subpopulation model.\n    `SimulationSettings` is a frozen dataclass to prevent users from\n    mutating individual subpop settings directly and making subpop\n    models have different settings within the same metapop model.\n    Instead, a new instance is created with the requested updates.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `SimulationSettings` instance -- keys must match the\n            field names of `SimulationSettings`.\n    \"\"\"\n\n    for subpop_model in self.subpop_models.values():\n        subpop_model.modify_simulation_settings(updates_dict)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.reset_simulation","title":"<code>reset_simulation()</code>","text":"<p>Resets <code>MetapopModel</code> by resetting and clearing history on all <code>SubpopModel</code> instances in <code>subpop_models</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_simulation(self):\n    \"\"\"\n    Resets `MetapopModel` by resetting and clearing\n    history on all `SubpopModel` instances in\n    `subpop_models`.\n    \"\"\"\n\n    for subpop_model in self.subpop_models.values():\n        subpop_model.reset_simulation()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.run_input_checks","title":"<code>run_input_checks() -&gt; None</code>","text":"<p>Run input checks to ensure that the provided inputs are valid. Subclasses can override this method to add additional checks. If inputs don't make sense we raise a MetapopModelError, and in some cases only a warning is issued.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def run_input_checks(self) -&gt; None:\n    \"\"\"\n    Run input checks to ensure that the provided inputs are valid.\n    Subclasses can override this method to add additional checks.\n    If inputs don't make sense we raise a MetapopModelError, and\n    in some cases only a warning is issued.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.simulate_until_day","title":"<code>simulate_until_day(simulation_end_day: int) -&gt; None</code>","text":"<p>Advance simulation model time until <code>simulation_end_day</code> in <code>MetapopModel</code>.</p> <p>NOT just the same as looping through each <code>SubpopModel</code>'s <code>simulate_until_day</code> method. On the <code>MetapopModel</code>, because <code>SubpopModel</code> instances are linked with <code>InteractionTerm</code>s and are not independent of each other, this <code>MetapopModel</code>'s <code>simulate_until_day</code> method has additional functionality.</p> <p>Note: the update order at the beginning of each day is very important!</p> <ul> <li> <p>First, each <code>SubpopModel</code> updates its daily state (computing <code>Schedule</code> and <code>DynamicVal</code> instances).</p> </li> <li> <p>Second, the <code>MetapopModel</code> computes quantities that depend on more than one subpopulation (i.e. inter-subpop quantities, such as the force of infection to each subpopulation in a travel model, where these terms depend on the number infected in other subpopulations) and then applies the update to each <code>SubpopModel</code> according to the user-implemented method <code>apply_inter_subpop_updates.</code></p> </li> <li> <p>Third, each <code>SubpopModel</code> simulates discretized timesteps (sampling <code>TransitionVariable</code>s, updating <code>EpiMetric</code>s, and updating <code>Compartment</code>s).</p> </li> </ul> <p>Note: we only update inter-subpop quantities once a day, not at every timestep -- in other words, the travel model state-dependent values are only updated daily -- this is to avoid severe computation inefficiency</p> <p>Parameters:</p> Name Type Description Default <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at <code>simulation_end_day</code> (i.e. exclusive, simulate up to but not including <code>simulation_end_day</code>).</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def simulate_until_day(self,\n                       simulation_end_day: int) -&gt; None:\n    \"\"\"\n    Advance simulation model time until `simulation_end_day` in\n    `MetapopModel`.\n\n    NOT just the same as looping through each `SubpopModel`'s\n    `simulate_until_day` method. On the `MetapopModel`,\n    because `SubpopModel` instances are linked with `InteractionTerm`s\n    and are not independent of each other, this `MetapopModel`'s\n    `simulate_until_day` method has additional functionality.\n\n    Note: the update order at the beginning of each day is very important!\n\n    - First, each `SubpopModel` updates its daily state (computing\n    `Schedule` and `DynamicVal` instances).\n\n    - Second, the `MetapopModel` computes quantities that depend\n    on more than one subpopulation (i.e. inter-subpop quantities,\n    such as the force of infection to each subpopulation in a travel\n    model, where these terms depend on the number infected in\n    other subpopulations) and then applies the update to each\n    `SubpopModel` according to the user-implemented method\n    `apply_inter_subpop_updates.`\n\n    - Third, each `SubpopModel` simulates discretized timesteps (sampling\n    `TransitionVariable`s, updating `EpiMetric`s, and updating `Compartment`s).\n\n    Note: we only update inter-subpop quantities once a day, not at every timestep\n    -- in other words, the travel model state-dependent values are only\n    updated daily -- this is to avoid severe computation inefficiency\n\n    Args:\n        simulation_end_day (positive int):\n            stop simulation at `simulation_end_day` (i.e. exclusive,\n            simulate up to but not including `simulation_end_day`).\n    \"\"\"\n\n    if self.current_simulation_day &gt; simulation_end_day:\n        raise MetapopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                f\"exceeds last simulation day ({simulation_end_day}).\")\n\n    # Adding this in case the user manually changes the initial\n    #   value or current value of any state variable --\n    #   otherwise, the state will not get updated\n    # Analogous logic in SubpopModel's `simulate_until_day` method\n    for subpop_model in self.subpop_models.values():\n        subpop_model.state.sync_to_current_vals(subpop_model.all_state_variables)\n\n    while self.current_simulation_day &lt; simulation_end_day:\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.prepare_daily_state()\n\n        self.apply_inter_subpop_updates()\n\n        for subpop_model in self.subpop_models.values():\n            save_daily_history = subpop_model.simulation_settings.save_daily_history\n            timesteps_per_day = subpop_model.simulation_settings.timesteps_per_day\n\n            subpop_model._simulate_timesteps(timesteps_per_day)\n\n            if save_daily_history:\n                subpop_model.save_daily_history()\n\n            subpop_model.increment_simulation_day()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModelError","title":"<code>MetapopModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for metapopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class MetapopModelError(Exception):\n    \"\"\"Custom exceptions for metapopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.ParamShapes","title":"<code>ParamShapes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines allowed structural shapes for parameter sampling.</p> <p>Specifies which population dimension(s) a parameter varies across.   - \"age\": an array of length A (one value per age group)   - \"age_risk\": a 2D array of shape (A, R) (values per age \u00d7 risk group)   - \"scalar\": a single value applied to all subpopulations</p> <p>Used in <code>UniformSamplingSpec.param_shapes</code> to reduce the need for manually expanding arrays.</p> Source code in <code>CLT_BaseModel/clt_toolkit/sampling.py</code> <pre><code>class ParamShapes(str, Enum):\n    \"\"\"\n    Defines allowed structural shapes for parameter sampling.\n\n    Specifies which population dimension(s) a parameter varies across.\n      - \"age\": an array of length A (one value per age group)\n      - \"age_risk\": a 2D array of shape (A, R) (values per age \u00d7 risk group)\n      - \"scalar\": a single value applied to all subpopulations\n\n    Used in `UniformSamplingSpec.param_shapes` to reduce the need for\n    manually expanding arrays.\n    \"\"\"\n\n    age = \"age\"\n    age_risk = \"age_risk\"\n    scalar = \"scalar\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Schedule","title":"<code>Schedule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that are functions of real-world dates -- for example, contact matrices (which depend on the day of the week and whether the current day is a holiday), historical vaccination data, and seasonality.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@dataclass\nclass Schedule(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that are functions of real-world\n    dates -- for example, contact matrices (which depend on the day of\n    the week and whether the current day is a holiday), historical\n    vaccination data, and seasonality.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: Optional[dict] = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                has a \"date\" column with strings in format `\"YYYY-MM-DD\"`\n                of consecutive calendar days, and other columns\n                corresponding to values on those days\n        \"\"\"\n\n        super().__init__(init_val)\n        self.timeseries_df = timeseries_df\n\n    @abstractmethod\n    def update_current_val(self,\n                           params: SubpopParams,\n                           current_date: datetime.date) -&gt; None:\n        \"\"\"\n        Subpop classes must provide a concrete implementation of\n        updating `current_val` in-place.\n\n        Args:\n            params (SubpopParams):\n                fixed parameters of subpopulation model.\n            current_date (date):\n                real-world date corresponding to\n                model's current simulation day.\n        \"\"\"\n        pass\n\n    def postprocess_data_input(self) -&gt; None:\n        \"\"\"\n        Subpop classes must provide a concrete implementation of\n        updating `current_val` in-place.\n\n        Used to modify timeseries_df format, if necessary.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Schedule.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: Optional[dict] = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>has a \"date\" column with strings in format <code>\"YYYY-MM-DD\"</code> of consecutive calendar days, and other columns corresponding to values on those days</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: Optional[dict] = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            has a \"date\" column with strings in format `\"YYYY-MM-DD\"`\n            of consecutive calendar days, and other columns\n            corresponding to values on those days\n    \"\"\"\n\n    super().__init__(init_val)\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Schedule.postprocess_data_input","title":"<code>postprocess_data_input() -&gt; None</code>","text":"<p>Subpop classes must provide a concrete implementation of updating <code>current_val</code> in-place.</p> <p>Used to modify timeseries_df format, if necessary.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def postprocess_data_input(self) -&gt; None:\n    \"\"\"\n    Subpop classes must provide a concrete implementation of\n    updating `current_val` in-place.\n\n    Used to modify timeseries_df format, if necessary.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Schedule.update_current_val","title":"<code>update_current_val(params: SubpopParams, current_date: datetime.date) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Subpop classes must provide a concrete implementation of updating <code>current_val</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>SubpopParams</code> <p>fixed parameters of subpopulation model.</p> required <code>current_date</code> <code>date</code> <p>real-world date corresponding to model's current simulation day.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       params: SubpopParams,\n                       current_date: datetime.date) -&gt; None:\n    \"\"\"\n    Subpop classes must provide a concrete implementation of\n    updating `current_val` in-place.\n\n    Args:\n        params (SubpopParams):\n            fixed parameters of subpopulation model.\n        current_date (date):\n            real-world date corresponding to\n            model's current simulation day.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SimulationSettings","title":"<code>SimulationSettings</code>  <code>dataclass</code>","text":"<p>Stores simulation settings.</p> <p>Attributes:</p> Name Type Description <code>timesteps_per_day</code> <code>int</code> <p>number of discretized timesteps within a simulation day -- more <code>timesteps_per_day</code> mean smaller discretization time intervals, which may cause the model to run slower.</p> <code>transition_type</code> <code>str</code> <p>valid value must be from <code>TransitionTypes</code>, specifying the probability distribution of transitions between compartments.</p> <code>use_deterministic_softplus</code> <code>bool</code> <p>If the transition type used is deterministic this determines whether we use a softplus function once compartment values are updated. If true this matches the behavior of the torch implementation of the model, if false true zeros are used.</p> <code>start_real_date</code> <code>str</code> <p>actual date in string format \"YYYY-MM-DD\" that aligns with the beginning of the simulation.</p> <code>save_daily_history</code> <code>bool</code> <p>set to <code>True</code> to save <code>current_val</code> of <code>StateVariable</code> to history after each simulation day -- set to <code>False</code> if want speedier performance.</p> <code>transition_variables_to_save</code> <code>tuple[str]</code> <p>List of names of transition variables whose histories should be saved during the simulation. Saving these can significantly slow execution, so leave this tuple empty for faster performance.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass SimulationSettings:\n    \"\"\"\n    Stores simulation settings.\n\n    Attributes:\n        timesteps_per_day (int):\n            number of discretized timesteps within a simulation\n            day -- more `timesteps_per_day` mean smaller discretization\n            time intervals, which may cause the model to run slower.\n        transition_type (str):\n            valid value must be from `TransitionTypes`, specifying\n            the probability distribution of transitions between\n            compartments.\n        use_deterministic_softplus (bool):\n            If the transition type used is deterministic this determines\n            whether we use a softplus function once compartment values are\n            updated. If true this matches the behavior of the torch\n            implementation of the model, if false true zeros are used.\n        start_real_date (str):\n            actual date in string format \"YYYY-MM-DD\" that aligns with the\n            beginning of the simulation.\n        save_daily_history (bool):\n            set to `True` to save `current_val` of `StateVariable` to history after each\n            simulation day -- set to `False` if want speedier performance.\n        transition_variables_to_save (tuple[str]):\n            List of names of transition variables whose histories should be saved\n            during the simulation. Saving these can significantly slow\n            execution, so leave this tuple empty for faster performance.\n    \"\"\"\n\n    timesteps_per_day: int = 7\n    transition_type: str = TransitionTypes.BINOM\n    use_deterministic_softplus: bool = False\n    start_real_date: str = \"2024-10-31\"\n    save_daily_history: bool = True\n    transition_variables_to_save: tuple = ()\n\n    def __post_init__(self):\n\n        # Convert to tuple if a list is passed\n        if not isinstance(self.transition_variables_to_save, tuple):\n            object.__setattr__(self, \"transition_variables_to_save\", tuple(self.transition_variables_to_save))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.StateVariable","title":"<code>StateVariable</code>","text":"<p>Parent class of <code>InteractionTerm</code>, <code>Compartment</code>, <code>EpiMetric</code>, <code>DynamicVal</code>, and <code>Schedule</code> classes. All subclasses have the attributes <code>init_val</code> and <code>current_val</code>.</p> Dimensions <p>A (int):     Number of age groups. R (int):     Number of risk groups.</p> <p>Attributes:</p> Name Type Description <code>init_val</code> <code>np.ndarray of shape (A, R</code> <p>Holds initial value of <code>StateVariable</code> for age-risk groups.</p> <code>current_val</code> <code>np.ndarray of shape (A, R</code> <p>Same size as <code>init_val</code>, holds current value of <code>StateVariable</code> for age-risk groups.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>Each element is an A x R array that holds history of compartment states for age-risk groups -- element t corresponds to previous <code>current_val</code> value at end of simulation day t.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class StateVariable:\n    \"\"\"\n    Parent class of `InteractionTerm`, `Compartment`, `EpiMetric`,\n    `DynamicVal`, and `Schedule` classes. All subclasses have the\n    attributes `init_val` and `current_val`.\n\n    Dimensions:\n        A (int):\n            Number of age groups.\n        R (int):\n            Number of risk groups.\n\n    Attributes:\n        init_val (np.ndarray of shape (A, R)):\n            Holds initial value of `StateVariable` for age-risk groups.\n        current_val (np.ndarray of shape (A, R)):\n            Same size as `init_val`, holds current value of `StateVariable`\n            for age-risk groups.\n        history_vals_list (list[np.ndarray]):\n            Each element is an A x R array that holds\n            history of compartment states for age-risk groups --\n            element t corresponds to previous `current_val` value at\n            end of simulation day t.\n    \"\"\"\n\n    def __init__(self, init_val=None):\n        self._init_val = init_val\n        self.current_val = copy.deepcopy(init_val)\n        self.history_vals_list = []\n\n    @property\n    def init_val(self):\n        return self._init_val\n\n    @init_val.setter\n    def init_val(self, value):\n        \"\"\"\n        We need to use properties/setters because when we change\n        `init_val`, we want `current_val` to be updated too!\n        \"\"\"\n        self._init_val = value\n        self.current_val = copy.deepcopy(value)\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending `current_val` attribute\n        to `history_vals_list` in-place..\n\n        Deep copying is CRUCIAL because `current_val` is a mutable\n        `np.ndarray` -- without deep copying, `history_vals_list` would\n        have the same value for all elements.\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets `current_val` to `init_val` and resets\n        `history_vals_list` attribute to empty list.\n        \"\"\"\n\n        self.current_val = copy.deepcopy(self.init_val)\n        self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.StateVariable.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets <code>current_val</code> to <code>init_val</code> and resets <code>history_vals_list</code> attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets `current_val` to `init_val` and resets\n    `history_vals_list` attribute to empty list.\n    \"\"\"\n\n    self.current_val = copy.deepcopy(self.init_val)\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.StateVariable.save_history","title":"<code>save_history() -&gt; None</code>","text":"<p>Saves current value to history by appending <code>current_val</code> attribute to <code>history_vals_list</code> in-place..</p> <p>Deep copying is CRUCIAL because <code>current_val</code> is a mutable <code>np.ndarray</code> -- without deep copying, <code>history_vals_list</code> would have the same value for all elements.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending `current_val` attribute\n    to `history_vals_list` in-place..\n\n    Deep copying is CRUCIAL because `current_val` is a mutable\n    `np.ndarray` -- without deep copying, `history_vals_list` would\n    have the same value for all elements.\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel","title":"<code>SubpopModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Contains and manages all necessary components for simulating a compartmental model for a given subpopulation.</p> <p>Each <code>SubpopModel</code> instance includes compartments, epi metrics, dynamic vals, a data container for the current simulation state, transition variables and transition variable groups, epidemiological parameters, simulation experiment simulation settings parameters, and a random number generator.</p> <p>All city-level subpopulation models, regardless of disease type and compartment/transition structure, are instances of this class.</p> <p>When creating an instance, the order of elements does not matter within <code>compartments</code>, <code>epi_metrics</code>, <code>dynamic_vals</code>, <code>transition_variables</code>, and <code>transition_variable_groups</code>. The \"flow\" and \"physics\" information are stored on the objects.</p> <p>Attributes:</p> Name Type Description <code>compartments</code> <code>objdict[str, Compartment]</code> <p>objdict of all the subpop model's <code>Compartment</code> instances.</p> <code>transition_variables</code> <code>objdict[str, TransitionVariable]</code> <p>objdict of all the subpop model's <code>TransitionVariable</code> instances.</p> <code>transition_variable_groups</code> <code>objdict[str, TransitionVariableGroup]</code> <p>objdict of all the subpop model's <code>TransitionVariableGroup</code> instances.</p> <code>epi_metrics</code> <code>objdict[str, EpiMetric]</code> <p>objdict of all the subpop model's <code>EpiMetric</code> instances.</p> <code>dynamic_vals</code> <code>objdict[str, DynamicVal]</code> <p>objdict of all the subpop model's <code>DynamicVal</code> instances.</p> <code>schedules</code> <code>objdict[str, Schedule]</code> <p>objdict of all the subpop model's <code>Schedule</code> instances.</p> <code>current_simulation_day</code> <code>int</code> <p>tracks current simulation day -- incremented by +1 when <code>simulation_settings.timesteps_per_day</code> discretized timesteps have completed.</p> <code>current_real_date</code> <code>date</code> <p>tracks real-world date -- advanced by +1 day when <code>simulation_settings.timesteps_per_day</code> discretized timesteps have completed.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class SubpopModel(ABC):\n    \"\"\"\n    Contains and manages all necessary components for\n    simulating a compartmental model for a given subpopulation.\n\n    Each `SubpopModel` instance includes compartments,\n    epi metrics, dynamic vals, a data container for the current simulation\n    state, transition variables and transition variable groups,\n    epidemiological parameters, simulation experiment simulation settings\n    parameters, and a random number generator.\n\n    All city-level subpopulation models, regardless of disease type and\n    compartment/transition structure, are instances of this class.\n\n    When creating an instance, the order of elements does not matter\n    within `compartments`, `epi_metrics`, `dynamic_vals`,\n    `transition_variables`, and `transition_variable_groups`.\n    The \"flow\" and \"physics\" information are stored on the objects.\n\n    Attributes:\n        compartments (sc.objdict[str, Compartment]):\n            objdict of all the subpop model's `Compartment` instances.\n        transition_variables (sc.objdict[str, TransitionVariable]):\n            objdict of all the subpop model's `TransitionVariable` instances.\n        transition_variable_groups (sc.objdict[str, TransitionVariableGroup]):\n            objdict of all the subpop model's `TransitionVariableGroup` instances.\n        epi_metrics (sc.objdict[str, EpiMetric]):\n            objdict of all the subpop model's `EpiMetric` instances.\n        dynamic_vals (sc.objdict[str, DynamicVal]):\n            objdict of all the subpop model's `DynamicVal` instances.\n        schedules (sc.objdict[str, Schedule]):\n            objdict of all the subpop model's `Schedule` instances.\n        current_simulation_day (int):\n            tracks current simulation day -- incremented by +1\n            when `simulation_settings.timesteps_per_day` discretized timesteps\n            have completed.\n        current_real_date (datetime.date):\n            tracks real-world date -- advanced by +1 day when\n            `simulation_settings.timesteps_per_day` discretized timesteps\n            have completed.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 state: SubpopState,\n                 params: SubpopParams,\n                 simulation_settings: SimulationSettings,\n                 RNG: np.random.Generator,\n                 name: str,\n                 metapop_model: MetapopModel = None):\n\n        \"\"\"\n        Params:\n            state (SubpopState):\n                holds current values of `SubpopModel`'s state variables.\n            params (SubpopParams):\n                data container for the model's epidemiological parameters,\n                such as the \"Greek letters\" characterizing sojourn times\n                in compartments.\n            simulation_settings (SimulationSettings):\n                data container for the model's simulation settings.\n            RNG (np.random.Generator):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            name (str):\n                unique identifier of `SubpopModel`.\n            metapop_model (Optional[MetapopModel]):\n                if not `None`, is the `MetapopModel` instance\n                associated with this `SubpopModel`.\n        \"\"\"\n\n        self.state = copy.deepcopy(state)\n        self.params = copy.deepcopy(params)\n        self.simulation_settings = copy.deepcopy(simulation_settings)\n\n        self.RNG = RNG\n\n        self.current_simulation_day = 0\n        self.start_real_date = self.get_start_real_date()\n        self.current_real_date = self.start_real_date\n\n        self.metapop_model = metapop_model\n        self.name = name\n\n        self.schedules = self.create_schedules()\n        self.compartments = self.create_compartments()\n        self.transition_variables = self.create_transition_variables()\n        self.transition_variable_groups = self.create_transition_variable_groups()\n        self.epi_metrics = self.create_epi_metrics()\n        self.dynamic_vals = self.create_dynamic_vals()\n\n        self.all_state_variables = {**self.compartments,\n                                    **self.epi_metrics,\n                                    **self.dynamic_vals,\n                                    **self.schedules}\n\n        # The model's state also has access to the model's\n        #   compartments, epi_metrics, dynamic_vals, and schedules --\n        #   so that state can easily retrieve each object's\n        #   current_val and store it\n        self.state.compartments = self.compartments\n        self.state.epi_metrics = self.epi_metrics\n        self.state.dynamic_vals = self.dynamic_vals\n        self.state.schedules = self.schedules\n\n        self.params = updated_dataclass(self.params, {\"total_pop_age_risk\": self.compute_total_pop_age_risk()})\n\n        self.run_input_checks()\n\n    def __getattr__(self, name):\n        \"\"\"\n        Called if normal attribute lookup fails.\n        Delegate to `all_state_variables`, `transition_variables`,\n            or `transition_variable_groups` if name matches a key.\n        \"\"\"\n\n        if name in self.all_state_variables:\n            return self.all_state_variables[name]\n        elif name in self.transition_variables:\n            return self.transition_variables[name]\n        elif name in self.transition_variable_groups:\n            return self.transition_variable_groups[name]\n        else:\n            raise AttributeError(f\"{type(self).__name__!r} object has no attribute {name!r}\")\n\n    def modify_simulation_settings(self,\n                                   updates_dict: dict):\n        \"\"\"\n        This method lets users safely modify simulation settings;\n        if this subpop model is associated with a metapop model,\n        the same updates are applied to all subpop models on the\n        metapop model. See also `modify_simulation_settings` method on\n        `MetapopModel`.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `SimulationSettings` instance -- keys must match the\n                field names of `SimulationSettings`.\n        \"\"\"\n\n        self.simulation_settings = \\\n            updated_dataclass(self.simulation_settings, updates_dict)\n\n    def compute_total_pop_age_risk(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            (np.ndarray of shape (A, R))\n                A x R array, where A is the number of age groups\n                and R is the number of risk groups, corresponding to\n                total population for that age-risk group (summed\n                over all compartments in the subpop model).\n        \"\"\"\n\n        total_pop_age_risk = np.zeros((self.params.num_age_groups,\n                                       self.params.num_risk_groups))\n\n        # At initialization (before simulation is run), each\n        #   compartment's current val is equivalent to the initial val\n        #   specified in the state variables' init val JSON.\n        for compartment in self.compartments.values():\n            total_pop_age_risk += compartment.current_val\n\n        return total_pop_age_risk\n\n    def get_start_real_date(self):\n        \"\"\"\n        Fetches `start_real_date` from `simulation_settings` -- converts to\n            proper datetime.date format if originally given as\n            string.\n\n        Returns:\n            start_real_date (datetime.date):\n                real-world date that corresponds to start of\n                simulation.\n        \"\"\"\n\n        start_real_date = self.simulation_settings.start_real_date\n\n        if not isinstance(start_real_date, datetime.date):\n            try:\n                start_real_date = \\\n                    datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n            except ValueError:\n                print(\"Error: The date format should be YYYY-MM-DD.\")\n\n        return start_real_date\n\n    def run_input_checks(self) -&gt; None:\n        \"\"\"\n        Run input checks to ensure that the provided inputs are valid.\n        Subclasses can override this method to add additional checks.\n        If inputs don't make sense we raise a SubpopModelError, and\n        in some cases only a warning is issued.\n        \"\"\"\n\n        # Check that all compartments have non-negative initial values\n        for compartment_name, compartment in self.compartments.items():\n            if np.any(compartment.init_val &lt; 0):\n                raise SubpopModelError(f\"Compartment '{compartment_name}' has negative initial values.\")\n\n    @abstractmethod\n    def create_compartments(self) -&gt; sc.objdict[str, Compartment]:\n        \"\"\"\n        Create the epidemiological compartments used in the model.\n        Subclasses **must override** this method to provide model-specific\n        transitions.\n\n        Returns:\n            (sc.objdict[str, Compartment]):\n                Dictionary mapping compartment names to `Compartment` objects.\n        \"\"\"\n\n        return sc.objdict()\n\n    @abstractmethod\n    def create_transition_variables(self) -&gt; sc.objdict[str, TransitionVariable]:\n        \"\"\"\n        Create the transition variables specifying how individuals transition\n        between epidemiological compartments in the model. Subclasses\n        **must override** this method to provide model-specific transitions.\n\n        See `__init__` method -- this method is called after `compartments`\n        is assigned via `create_compartments()`, so it can reference the instance's\n        compartments.\n\n        Returns:\n            (sc.objdict[str, TransitionVariable]):\n                Dictionary mapping names to `TransitionVariable` objects.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_transition_variable_groups(self) -&gt; sc.objdict[str, TransitionVariableGroup]:\n        \"\"\"\n        Create the joint transition variables specifying how transitioning\n        from compartments with multiple outflows is handled. Subclasses\n        can **optionally** override this method to provide model-specific transitions.\n\n        See `__init__` method -- this method is called after `compartments`\n        is assigned via `create_compartments()` and `transition_variables` is\n        assigned via `create_transition_variables()`, so it can reference the instance's\n        compartments and transition variables.\n\n        Returns:\n            (sc.objdict[str, TransitionVariableGroup]):\n                Dictionary mapping names to `TransitionVariableGroup` objects.\n                Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_epi_metrics(self) -&gt; sc.objdict[str, EpiMetric]:\n        \"\"\"\n        Create the epidemiological metrics that track deterministic functions of\n        compartments' current values. Subclasses can **optionally** override this method\n        to provide model-specific transitions.\n\n        See `__init__` method -- this method is called after `transition_variables` is\n        assigned via `create_transition_variables()`, so it can reference the instance's\n        transition variables.\n\n        Returns:\n            (sc.objdict[str, EpiMetric]):\n                Dictionary mapping names to `EpiMetric` objects. Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_dynamic_vals(self) -&gt; sc.objdict[str, DynamicVal]:\n        \"\"\"\n        Create dynamic values that change depending on the simulation state.\n        Subclasses can **optionally** override this method to provide model-specific transitions.\n\n        Returns:\n            (sc.objdict[str, DynamicVal]):\n                Dictionary mapping names to `DynamicVal` objects. Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_schedules(self) -&gt; sc.objdict[str, Schedule]:\n        \"\"\"\n        Create schedules that are deterministic functions of the real-world simulation date.\n        Subclasses can **optionally** override this method to provide model-specific transitions.\n\n        Returns:\n            (sc.objdict[str, Schedule]):\n                Dictionary mapping names to `Schedule` objects. Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def modify_random_seed(self, new_seed_number) -&gt; None:\n        \"\"\"\n        Modifies model's `RNG` attribute in-place to new generator\n        seeded at `new_seed_number`.\n\n        Args:\n            new_seed_number (int):\n                used to re-seed model's random number generator.\n        \"\"\"\n\n        self._bit_generator = np.random.MT19937(seed=new_seed_number)\n        self.RNG = np.random.Generator(self._bit_generator)\n\n    def simulate_until_day(self,\n                           simulation_end_day: int) -&gt; None:\n        \"\"\"\n        Advance simulation model time until `simulation_end_day`.\n\n        Advance time by iterating through simulation days,\n        which are simulated by iterating through discretized\n        timesteps.\n\n        Save daily simulation data as history on each `Compartment`\n        instance.\n\n        Args:\n            simulation_end_day (positive int):\n                stop simulation at `simulation_end_day` (i.e. exclusive,\n                simulate up to but not including `simulation_end_day`).\n        \"\"\"\n\n        if self.current_simulation_day &gt; simulation_end_day:\n            raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                   f\"exceeds last simulation day ({simulation_end_day}).\")\n\n        save_daily_history = self.simulation_settings.save_daily_history\n        timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n        # Adding this in case the user manually changes the initial\n        #   value or current value of any state variable --\n        #   otherwise, the state will not get updated\n        self.state.sync_to_current_vals(self.all_state_variables)\n\n        # simulation_end_day is exclusive endpoint\n        while self.current_simulation_day &lt; simulation_end_day:\n\n            self.prepare_daily_state()\n\n            self._simulate_timesteps(timesteps_per_day)\n\n            if save_daily_history:\n                self.save_daily_history()\n\n            self.increment_simulation_day()\n\n    def _simulate_timesteps(self,\n                            num_timesteps: int) -&gt; None:\n        \"\"\"\n        Subroutine for `simulate_until_day`.\n\n        Iterates through discretized timesteps to simulate next\n        simulation day. Granularity of discretization is given by\n        attribute `simulation_settings.timesteps_per_day`.\n\n        Properly scales transition variable realizations and changes\n        in dynamic vals by specified timesteps per day.\n\n        Args:\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        for timestep in range(num_timesteps):\n\n            self.update_transition_rates()\n\n            self.sample_transitions()\n\n            self.update_epi_metrics()\n\n            self.update_compartments()\n\n            self.state.sync_to_current_vals(self.epi_metrics)\n            self.state.sync_to_current_vals(self.compartments)\n\n    def prepare_daily_state(self) -&gt; None:\n        \"\"\"\n        At beginning of each day, update current value of\n        interaction terms, schedules, dynamic values --\n        note that these are only updated once a day, not\n        for every discretized timestep.\n        \"\"\"\n\n        subpop_state = self.state\n        subpop_params = self.params\n        current_real_date = self.current_real_date\n\n        # Important note: this order of updating is important,\n        #   because schedules do not depend on other state variables,\n        #   but dynamic vals may depend on schedules\n        # Interaction terms may depend on both schedules\n        #   and dynamic vals.\n\n        schedules = self.schedules\n        dynamic_vals = self.dynamic_vals\n\n        # Update schedules for current day\n        for schedule in schedules.values():\n            schedule.update_current_val(subpop_params,\n                                        current_real_date)\n\n        self.state.sync_to_current_vals(schedules)\n\n        # Update dynamic values for current day\n        for dval in dynamic_vals.values():\n            if dval.is_enabled:\n                dval.update_current_val(subpop_state, subpop_params)\n\n        self.state.sync_to_current_vals(dynamic_vals)\n\n    def update_epi_metrics(self) -&gt; None:\n        \"\"\"\n        Update current value attribute on each associated\n            `EpiMetric` instance.\n        \"\"\"\n\n        state = self.state\n        params = self.params\n        timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n        for metric in self.epi_metrics.values():\n            metric.change_in_current_val = \\\n                metric.get_change_in_current_val(state,\n                                                 params,\n                                                 timesteps_per_day)\n            metric.update_current_val()\n\n    def update_transition_rates(self) -&gt; None:\n        \"\"\"\n        Compute current transition rates for each transition variable,\n            and store this updated value on each variable's\n            current_rate attribute.\n        \"\"\"\n\n        state = self.state\n        params = self.params\n\n        for tvar in self.transition_variables.values():\n            tvar.current_rate = tvar.get_current_rate(state, params)\n\n    def sample_transitions(self) -&gt; None:\n        \"\"\"\n        For each transition variable, sample a random realization\n            using its current rate. Handle jointly distributed transition\n            variables first (using `TransitionVariableGroup` logic), then\n            handle marginally distributed transition variables.\n            Use `SubpopModel`'s `RNG` to generate random variables.\n        \"\"\"\n\n        RNG = self.RNG\n        timesteps_per_day = self.simulation_settings.timesteps_per_day\n        transition_variables_to_save = self.simulation_settings.transition_variables_to_save\n\n        # Obtain transition variable realizations for jointly distributed transition variables\n        #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                          timesteps_per_day)\n            tvargroup.update_transition_variable_realizations()\n\n        # Obtain transition variable realizations for marginally distributed transition variables\n        #   (i.e. when there is only one transition variable outflow from an epi compartment)\n        # If transition variable is jointly distributed, then its realization has already\n        #   been computed by its transition variable group container previously,\n        #   so skip the marginal computation\n        for tvar in self.transition_variables.values():\n            if not tvar.is_jointly_distributed:\n                tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n\n        for name in transition_variables_to_save:\n            self.transition_variables[name].save_history()\n\n    def update_compartments(self) -&gt; None:\n        \"\"\"\n        Update current value of each `Compartment`, by\n            looping through all `TransitionVariable` instances\n            and subtracting/adding their current values\n            from origin/destination compartments respectively.\n        \"\"\"\n\n        for tvar in self.transition_variables.values():\n            tvar.update_origin_outflow()\n            tvar.update_destination_inflow()\n\n        for compartment in self.compartments.values():\n            compartment.update_current_val()\n\n            # By construction (using binomial/multinomial with or without taylor expansion),\n            #   more individuals cannot leave the compartment than are in the compartment\n            ## TODO check whether the following reason is still valid: a flooring function \n            #  was added to transition variables when using Poisson distributed transitions\n            # However, for Poisson any for ANY deterministic version, it is possible\n            #   to have more individuals leaving the compartment than are in the compartment,\n            #   and hence negative-valued compartments\n            # We use this function to fix this, and also use a differentiable torch\n            #   function to be consistent with the torch implementation (this still\n            #   allows us to take derivatives in the torch implementation)\n            # The syntax is janky here -- we want everything as an array, but\n            #   we need to pass a tensor to the torch functional\n            if (\"deterministic\" in self.simulation_settings.transition_type) and \\\n               (self.simulation_settings.use_deterministic_softplus):\n                compartment.current_val = \\\n                        np.array(torch.nn.functional.softplus(torch.tensor(compartment.current_val)))\n\n            # After updating the compartment's current value,\n            #   reset its inflow and outflow attributes, to\n            #   prepare for the next iteration.\n            compartment.reset_inflow()\n            compartment.reset_outflow()\n\n    def increment_simulation_day(self) -&gt; None:\n        \"\"\"\n        Move day counters to next simulation day, both\n            for integer simulation day and real date.\n        \"\"\"\n\n        self.current_simulation_day += 1\n        self.current_real_date += datetime.timedelta(days=1)\n\n    def save_daily_history(self) -&gt; None:\n        \"\"\"\n        Update history at end of each day, not at end of every\n           discretization timestep, to be efficient.\n        Update history of state variables other than `Schedule`\n           instances -- schedules do not have history.\n        \"\"\"\n        for svar in self.compartments.values() + \\\n                    self.epi_metrics.values() + \\\n                    self.dynamic_vals.values():\n            svar.save_history()\n\n    def reset_simulation(self) -&gt; None:\n        \"\"\"\n        Reset simulation in-place. Subsequent method calls of\n        `simulate_until_day` start from day 0, with original\n        day 0 state.\n\n        Returns `current_simulation_day` to 0.\n        Restores state values to initial values.\n        Clears history on model's state variables.\n        Resets transition variables' `current_val` attribute to 0.\n\n        WARNING:\n            DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n            ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n            WHERE IT LEFT OFF.\n\n        Use method `modify_random_seed` to reset model's `RNG` to its\n        initial starting seed.\n        \"\"\"\n\n        self.current_simulation_day = 0\n        self.current_real_date = self.start_real_date\n\n        # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n        for svar in self.all_state_variables.values():\n            setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n        self.state.sync_to_current_vals(self.all_state_variables)\n\n        for svar in self.all_state_variables.values():\n            svar.reset()\n\n        for tvar in self.transition_variables.values():\n            tvar.reset()\n\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = []\n\n    def find_name_by_compartment(self,\n                                 target_compartment: Compartment) -&gt; str:\n        \"\"\"\n        Given `Compartment`, returns name of that `Compartment`.\n\n        Args:\n            target_compartment (Compartment):\n                Compartment object with a name to look up\n\n        Returns:\n            (str):\n                Compartment name, given by the key to look\n                it up in the `SubpopModel`'s compartments objdict\n        \"\"\"\n\n        for name, compartment in self.compartments.items():\n            if compartment == target_compartment:\n                return name\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Called if normal attribute lookup fails. Delegate to <code>all_state_variables</code>, <code>transition_variables</code>,     or <code>transition_variable_groups</code> if name matches a key.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"\n    Called if normal attribute lookup fails.\n    Delegate to `all_state_variables`, `transition_variables`,\n        or `transition_variable_groups` if name matches a key.\n    \"\"\"\n\n    if name in self.all_state_variables:\n        return self.all_state_variables[name]\n    elif name in self.transition_variables:\n        return self.transition_variables[name]\n    elif name in self.transition_variable_groups:\n        return self.transition_variable_groups[name]\n    else:\n        raise AttributeError(f\"{type(self).__name__!r} object has no attribute {name!r}\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.__init__","title":"<code>__init__(state: SubpopState, params: SubpopParams, simulation_settings: SimulationSettings, RNG: np.random.Generator, name: str, metapop_model: MetapopModel = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds current values of <code>SubpopModel</code>'s state variables.</p> required <code>params</code> <code>SubpopParams</code> <p>data container for the model's epidemiological parameters, such as the \"Greek letters\" characterizing sojourn times in compartments.</p> required <code>simulation_settings</code> <code>SimulationSettings</code> <p>data container for the model's simulation settings.</p> required <code>RNG</code> <code>Generator</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>name</code> <code>str</code> <p>unique identifier of <code>SubpopModel</code>.</p> required <code>metapop_model</code> <code>Optional[MetapopModel]</code> <p>if not <code>None</code>, is the <code>MetapopModel</code> instance associated with this <code>SubpopModel</code>.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             state: SubpopState,\n             params: SubpopParams,\n             simulation_settings: SimulationSettings,\n             RNG: np.random.Generator,\n             name: str,\n             metapop_model: MetapopModel = None):\n\n    \"\"\"\n    Params:\n        state (SubpopState):\n            holds current values of `SubpopModel`'s state variables.\n        params (SubpopParams):\n            data container for the model's epidemiological parameters,\n            such as the \"Greek letters\" characterizing sojourn times\n            in compartments.\n        simulation_settings (SimulationSettings):\n            data container for the model's simulation settings.\n        RNG (np.random.Generator):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        name (str):\n            unique identifier of `SubpopModel`.\n        metapop_model (Optional[MetapopModel]):\n            if not `None`, is the `MetapopModel` instance\n            associated with this `SubpopModel`.\n    \"\"\"\n\n    self.state = copy.deepcopy(state)\n    self.params = copy.deepcopy(params)\n    self.simulation_settings = copy.deepcopy(simulation_settings)\n\n    self.RNG = RNG\n\n    self.current_simulation_day = 0\n    self.start_real_date = self.get_start_real_date()\n    self.current_real_date = self.start_real_date\n\n    self.metapop_model = metapop_model\n    self.name = name\n\n    self.schedules = self.create_schedules()\n    self.compartments = self.create_compartments()\n    self.transition_variables = self.create_transition_variables()\n    self.transition_variable_groups = self.create_transition_variable_groups()\n    self.epi_metrics = self.create_epi_metrics()\n    self.dynamic_vals = self.create_dynamic_vals()\n\n    self.all_state_variables = {**self.compartments,\n                                **self.epi_metrics,\n                                **self.dynamic_vals,\n                                **self.schedules}\n\n    # The model's state also has access to the model's\n    #   compartments, epi_metrics, dynamic_vals, and schedules --\n    #   so that state can easily retrieve each object's\n    #   current_val and store it\n    self.state.compartments = self.compartments\n    self.state.epi_metrics = self.epi_metrics\n    self.state.dynamic_vals = self.dynamic_vals\n    self.state.schedules = self.schedules\n\n    self.params = updated_dataclass(self.params, {\"total_pop_age_risk\": self.compute_total_pop_age_risk()})\n\n    self.run_input_checks()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.compute_total_pop_age_risk","title":"<code>compute_total_pop_age_risk() -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) A x R array, where A is the number of age groups and R is the number of risk groups, corresponding to total population for that age-risk group (summed over all compartments in the subpop model).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def compute_total_pop_age_risk(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        (np.ndarray of shape (A, R))\n            A x R array, where A is the number of age groups\n            and R is the number of risk groups, corresponding to\n            total population for that age-risk group (summed\n            over all compartments in the subpop model).\n    \"\"\"\n\n    total_pop_age_risk = np.zeros((self.params.num_age_groups,\n                                   self.params.num_risk_groups))\n\n    # At initialization (before simulation is run), each\n    #   compartment's current val is equivalent to the initial val\n    #   specified in the state variables' init val JSON.\n    for compartment in self.compartments.values():\n        total_pop_age_risk += compartment.current_val\n\n    return total_pop_age_risk\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_compartments","title":"<code>create_compartments() -&gt; sc.objdict[str, Compartment]</code>  <code>abstractmethod</code>","text":"<p>Create the epidemiological compartments used in the model. Subclasses must override this method to provide model-specific transitions.</p> <p>Returns:</p> Type Description <code>objdict[str, Compartment]</code> <p>Dictionary mapping compartment names to <code>Compartment</code> objects.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef create_compartments(self) -&gt; sc.objdict[str, Compartment]:\n    \"\"\"\n    Create the epidemiological compartments used in the model.\n    Subclasses **must override** this method to provide model-specific\n    transitions.\n\n    Returns:\n        (sc.objdict[str, Compartment]):\n            Dictionary mapping compartment names to `Compartment` objects.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_dynamic_vals","title":"<code>create_dynamic_vals() -&gt; sc.objdict[str, DynamicVal]</code>","text":"<p>Create dynamic values that change depending on the simulation state. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>Returns:</p> Type Description <code>objdict[str, DynamicVal]</code> <p>Dictionary mapping names to <code>DynamicVal</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_dynamic_vals(self) -&gt; sc.objdict[str, DynamicVal]:\n    \"\"\"\n    Create dynamic values that change depending on the simulation state.\n    Subclasses can **optionally** override this method to provide model-specific transitions.\n\n    Returns:\n        (sc.objdict[str, DynamicVal]):\n            Dictionary mapping names to `DynamicVal` objects. Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_epi_metrics","title":"<code>create_epi_metrics() -&gt; sc.objdict[str, EpiMetric]</code>","text":"<p>Create the epidemiological metrics that track deterministic functions of compartments' current values. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>See <code>__init__</code> method -- this method is called after <code>transition_variables</code> is assigned via <code>create_transition_variables()</code>, so it can reference the instance's transition variables.</p> <p>Returns:</p> Type Description <code>objdict[str, EpiMetric]</code> <p>Dictionary mapping names to <code>EpiMetric</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_epi_metrics(self) -&gt; sc.objdict[str, EpiMetric]:\n    \"\"\"\n    Create the epidemiological metrics that track deterministic functions of\n    compartments' current values. Subclasses can **optionally** override this method\n    to provide model-specific transitions.\n\n    See `__init__` method -- this method is called after `transition_variables` is\n    assigned via `create_transition_variables()`, so it can reference the instance's\n    transition variables.\n\n    Returns:\n        (sc.objdict[str, EpiMetric]):\n            Dictionary mapping names to `EpiMetric` objects. Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_schedules","title":"<code>create_schedules() -&gt; sc.objdict[str, Schedule]</code>","text":"<p>Create schedules that are deterministic functions of the real-world simulation date. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>Returns:</p> Type Description <code>objdict[str, Schedule]</code> <p>Dictionary mapping names to <code>Schedule</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_schedules(self) -&gt; sc.objdict[str, Schedule]:\n    \"\"\"\n    Create schedules that are deterministic functions of the real-world simulation date.\n    Subclasses can **optionally** override this method to provide model-specific transitions.\n\n    Returns:\n        (sc.objdict[str, Schedule]):\n            Dictionary mapping names to `Schedule` objects. Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_transition_variable_groups","title":"<code>create_transition_variable_groups() -&gt; sc.objdict[str, TransitionVariableGroup]</code>","text":"<p>Create the joint transition variables specifying how transitioning from compartments with multiple outflows is handled. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>See <code>__init__</code> method -- this method is called after <code>compartments</code> is assigned via <code>create_compartments()</code> and <code>transition_variables</code> is assigned via <code>create_transition_variables()</code>, so it can reference the instance's compartments and transition variables.</p> <p>Returns:</p> Type Description <code>objdict[str, TransitionVariableGroup]</code> <p>Dictionary mapping names to <code>TransitionVariableGroup</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_transition_variable_groups(self) -&gt; sc.objdict[str, TransitionVariableGroup]:\n    \"\"\"\n    Create the joint transition variables specifying how transitioning\n    from compartments with multiple outflows is handled. Subclasses\n    can **optionally** override this method to provide model-specific transitions.\n\n    See `__init__` method -- this method is called after `compartments`\n    is assigned via `create_compartments()` and `transition_variables` is\n    assigned via `create_transition_variables()`, so it can reference the instance's\n    compartments and transition variables.\n\n    Returns:\n        (sc.objdict[str, TransitionVariableGroup]):\n            Dictionary mapping names to `TransitionVariableGroup` objects.\n            Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_transition_variables","title":"<code>create_transition_variables() -&gt; sc.objdict[str, TransitionVariable]</code>  <code>abstractmethod</code>","text":"<p>Create the transition variables specifying how individuals transition between epidemiological compartments in the model. Subclasses must override this method to provide model-specific transitions.</p> <p>See <code>__init__</code> method -- this method is called after <code>compartments</code> is assigned via <code>create_compartments()</code>, so it can reference the instance's compartments.</p> <p>Returns:</p> Type Description <code>objdict[str, TransitionVariable]</code> <p>Dictionary mapping names to <code>TransitionVariable</code> objects.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef create_transition_variables(self) -&gt; sc.objdict[str, TransitionVariable]:\n    \"\"\"\n    Create the transition variables specifying how individuals transition\n    between epidemiological compartments in the model. Subclasses\n    **must override** this method to provide model-specific transitions.\n\n    See `__init__` method -- this method is called after `compartments`\n    is assigned via `create_compartments()`, so it can reference the instance's\n    compartments.\n\n    Returns:\n        (sc.objdict[str, TransitionVariable]):\n            Dictionary mapping names to `TransitionVariable` objects.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.find_name_by_compartment","title":"<code>find_name_by_compartment(target_compartment: Compartment) -&gt; str</code>","text":"<p>Given <code>Compartment</code>, returns name of that <code>Compartment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target_compartment</code> <code>Compartment</code> <p>Compartment object with a name to look up</p> required <p>Returns:</p> Type Description <code>str</code> <p>Compartment name, given by the key to look it up in the <code>SubpopModel</code>'s compartments objdict</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def find_name_by_compartment(self,\n                             target_compartment: Compartment) -&gt; str:\n    \"\"\"\n    Given `Compartment`, returns name of that `Compartment`.\n\n    Args:\n        target_compartment (Compartment):\n            Compartment object with a name to look up\n\n    Returns:\n        (str):\n            Compartment name, given by the key to look\n            it up in the `SubpopModel`'s compartments objdict\n    \"\"\"\n\n    for name, compartment in self.compartments.items():\n        if compartment == target_compartment:\n            return name\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.get_start_real_date","title":"<code>get_start_real_date()</code>","text":"<p>Fetches <code>start_real_date</code> from <code>simulation_settings</code> -- converts to     proper datetime.date format if originally given as     string.</p> <p>Returns:</p> Name Type Description <code>start_real_date</code> <code>date</code> <p>real-world date that corresponds to start of simulation.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_start_real_date(self):\n    \"\"\"\n    Fetches `start_real_date` from `simulation_settings` -- converts to\n        proper datetime.date format if originally given as\n        string.\n\n    Returns:\n        start_real_date (datetime.date):\n            real-world date that corresponds to start of\n            simulation.\n    \"\"\"\n\n    start_real_date = self.simulation_settings.start_real_date\n\n    if not isinstance(start_real_date, datetime.date):\n        try:\n            start_real_date = \\\n                datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n        except ValueError:\n            print(\"Error: The date format should be YYYY-MM-DD.\")\n\n    return start_real_date\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.increment_simulation_day","title":"<code>increment_simulation_day() -&gt; None</code>","text":"<p>Move day counters to next simulation day, both     for integer simulation day and real date.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def increment_simulation_day(self) -&gt; None:\n    \"\"\"\n    Move day counters to next simulation day, both\n        for integer simulation day and real date.\n    \"\"\"\n\n    self.current_simulation_day += 1\n    self.current_real_date += datetime.timedelta(days=1)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.modify_random_seed","title":"<code>modify_random_seed(new_seed_number) -&gt; None</code>","text":"<p>Modifies model's <code>RNG</code> attribute in-place to new generator seeded at <code>new_seed_number</code>.</p> <p>Parameters:</p> Name Type Description Default <code>new_seed_number</code> <code>int</code> <p>used to re-seed model's random number generator.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def modify_random_seed(self, new_seed_number) -&gt; None:\n    \"\"\"\n    Modifies model's `RNG` attribute in-place to new generator\n    seeded at `new_seed_number`.\n\n    Args:\n        new_seed_number (int):\n            used to re-seed model's random number generator.\n    \"\"\"\n\n    self._bit_generator = np.random.MT19937(seed=new_seed_number)\n    self.RNG = np.random.Generator(self._bit_generator)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.modify_simulation_settings","title":"<code>modify_simulation_settings(updates_dict: dict)</code>","text":"<p>This method lets users safely modify simulation settings; if this subpop model is associated with a metapop model, the same updates are applied to all subpop models on the metapop model. See also <code>modify_simulation_settings</code> method on <code>MetapopModel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>SimulationSettings</code> instance -- keys must match the field names of <code>SimulationSettings</code>.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def modify_simulation_settings(self,\n                               updates_dict: dict):\n    \"\"\"\n    This method lets users safely modify simulation settings;\n    if this subpop model is associated with a metapop model,\n    the same updates are applied to all subpop models on the\n    metapop model. See also `modify_simulation_settings` method on\n    `MetapopModel`.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `SimulationSettings` instance -- keys must match the\n            field names of `SimulationSettings`.\n    \"\"\"\n\n    self.simulation_settings = \\\n        updated_dataclass(self.simulation_settings, updates_dict)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.prepare_daily_state","title":"<code>prepare_daily_state() -&gt; None</code>","text":"<p>At beginning of each day, update current value of interaction terms, schedules, dynamic values -- note that these are only updated once a day, not for every discretized timestep.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def prepare_daily_state(self) -&gt; None:\n    \"\"\"\n    At beginning of each day, update current value of\n    interaction terms, schedules, dynamic values --\n    note that these are only updated once a day, not\n    for every discretized timestep.\n    \"\"\"\n\n    subpop_state = self.state\n    subpop_params = self.params\n    current_real_date = self.current_real_date\n\n    # Important note: this order of updating is important,\n    #   because schedules do not depend on other state variables,\n    #   but dynamic vals may depend on schedules\n    # Interaction terms may depend on both schedules\n    #   and dynamic vals.\n\n    schedules = self.schedules\n    dynamic_vals = self.dynamic_vals\n\n    # Update schedules for current day\n    for schedule in schedules.values():\n        schedule.update_current_val(subpop_params,\n                                    current_real_date)\n\n    self.state.sync_to_current_vals(schedules)\n\n    # Update dynamic values for current day\n    for dval in dynamic_vals.values():\n        if dval.is_enabled:\n            dval.update_current_val(subpop_state, subpop_params)\n\n    self.state.sync_to_current_vals(dynamic_vals)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.reset_simulation","title":"<code>reset_simulation() -&gt; None</code>","text":"<p>Reset simulation in-place. Subsequent method calls of <code>simulate_until_day</code> start from day 0, with original day 0 state.</p> <p>Returns <code>current_simulation_day</code> to 0. Restores state values to initial values. Clears history on model's state variables. Resets transition variables' <code>current_val</code> attribute to 0.</p> WARNING <p>DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE WHERE IT LEFT OFF.</p> <p>Use method <code>modify_random_seed</code> to reset model's <code>RNG</code> to its initial starting seed.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_simulation(self) -&gt; None:\n    \"\"\"\n    Reset simulation in-place. Subsequent method calls of\n    `simulate_until_day` start from day 0, with original\n    day 0 state.\n\n    Returns `current_simulation_day` to 0.\n    Restores state values to initial values.\n    Clears history on model's state variables.\n    Resets transition variables' `current_val` attribute to 0.\n\n    WARNING:\n        DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n        ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n        WHERE IT LEFT OFF.\n\n    Use method `modify_random_seed` to reset model's `RNG` to its\n    initial starting seed.\n    \"\"\"\n\n    self.current_simulation_day = 0\n    self.current_real_date = self.start_real_date\n\n    # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n    for svar in self.all_state_variables.values():\n        setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n    self.state.sync_to_current_vals(self.all_state_variables)\n\n    for svar in self.all_state_variables.values():\n        svar.reset()\n\n    for tvar in self.transition_variables.values():\n        tvar.reset()\n\n    for tvargroup in self.transition_variable_groups.values():\n        tvargroup.current_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.run_input_checks","title":"<code>run_input_checks() -&gt; None</code>","text":"<p>Run input checks to ensure that the provided inputs are valid. Subclasses can override this method to add additional checks. If inputs don't make sense we raise a SubpopModelError, and in some cases only a warning is issued.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def run_input_checks(self) -&gt; None:\n    \"\"\"\n    Run input checks to ensure that the provided inputs are valid.\n    Subclasses can override this method to add additional checks.\n    If inputs don't make sense we raise a SubpopModelError, and\n    in some cases only a warning is issued.\n    \"\"\"\n\n    # Check that all compartments have non-negative initial values\n    for compartment_name, compartment in self.compartments.items():\n        if np.any(compartment.init_val &lt; 0):\n            raise SubpopModelError(f\"Compartment '{compartment_name}' has negative initial values.\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.sample_transitions","title":"<code>sample_transitions() -&gt; None</code>","text":"<p>For each transition variable, sample a random realization     using its current rate. Handle jointly distributed transition     variables first (using <code>TransitionVariableGroup</code> logic), then     handle marginally distributed transition variables.     Use <code>SubpopModel</code>'s <code>RNG</code> to generate random variables.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def sample_transitions(self) -&gt; None:\n    \"\"\"\n    For each transition variable, sample a random realization\n        using its current rate. Handle jointly distributed transition\n        variables first (using `TransitionVariableGroup` logic), then\n        handle marginally distributed transition variables.\n        Use `SubpopModel`'s `RNG` to generate random variables.\n    \"\"\"\n\n    RNG = self.RNG\n    timesteps_per_day = self.simulation_settings.timesteps_per_day\n    transition_variables_to_save = self.simulation_settings.transition_variables_to_save\n\n    # Obtain transition variable realizations for jointly distributed transition variables\n    #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n    for tvargroup in self.transition_variable_groups.values():\n        tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                      timesteps_per_day)\n        tvargroup.update_transition_variable_realizations()\n\n    # Obtain transition variable realizations for marginally distributed transition variables\n    #   (i.e. when there is only one transition variable outflow from an epi compartment)\n    # If transition variable is jointly distributed, then its realization has already\n    #   been computed by its transition variable group container previously,\n    #   so skip the marginal computation\n    for tvar in self.transition_variables.values():\n        if not tvar.is_jointly_distributed:\n            tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n\n    for name in transition_variables_to_save:\n        self.transition_variables[name].save_history()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.save_daily_history","title":"<code>save_daily_history() -&gt; None</code>","text":"<p>Update history at end of each day, not at end of every    discretization timestep, to be efficient. Update history of state variables other than <code>Schedule</code>    instances -- schedules do not have history.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def save_daily_history(self) -&gt; None:\n    \"\"\"\n    Update history at end of each day, not at end of every\n       discretization timestep, to be efficient.\n    Update history of state variables other than `Schedule`\n       instances -- schedules do not have history.\n    \"\"\"\n    for svar in self.compartments.values() + \\\n                self.epi_metrics.values() + \\\n                self.dynamic_vals.values():\n        svar.save_history()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.simulate_until_day","title":"<code>simulate_until_day(simulation_end_day: int) -&gt; None</code>","text":"<p>Advance simulation model time until <code>simulation_end_day</code>.</p> <p>Advance time by iterating through simulation days, which are simulated by iterating through discretized timesteps.</p> <p>Save daily simulation data as history on each <code>Compartment</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at <code>simulation_end_day</code> (i.e. exclusive, simulate up to but not including <code>simulation_end_day</code>).</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def simulate_until_day(self,\n                       simulation_end_day: int) -&gt; None:\n    \"\"\"\n    Advance simulation model time until `simulation_end_day`.\n\n    Advance time by iterating through simulation days,\n    which are simulated by iterating through discretized\n    timesteps.\n\n    Save daily simulation data as history on each `Compartment`\n    instance.\n\n    Args:\n        simulation_end_day (positive int):\n            stop simulation at `simulation_end_day` (i.e. exclusive,\n            simulate up to but not including `simulation_end_day`).\n    \"\"\"\n\n    if self.current_simulation_day &gt; simulation_end_day:\n        raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                               f\"exceeds last simulation day ({simulation_end_day}).\")\n\n    save_daily_history = self.simulation_settings.save_daily_history\n    timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n    # Adding this in case the user manually changes the initial\n    #   value or current value of any state variable --\n    #   otherwise, the state will not get updated\n    self.state.sync_to_current_vals(self.all_state_variables)\n\n    # simulation_end_day is exclusive endpoint\n    while self.current_simulation_day &lt; simulation_end_day:\n\n        self.prepare_daily_state()\n\n        self._simulate_timesteps(timesteps_per_day)\n\n        if save_daily_history:\n            self.save_daily_history()\n\n        self.increment_simulation_day()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.update_compartments","title":"<code>update_compartments() -&gt; None</code>","text":"<p>Update current value of each <code>Compartment</code>, by     looping through all <code>TransitionVariable</code> instances     and subtracting/adding their current values     from origin/destination compartments respectively.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_compartments(self) -&gt; None:\n    \"\"\"\n    Update current value of each `Compartment`, by\n        looping through all `TransitionVariable` instances\n        and subtracting/adding their current values\n        from origin/destination compartments respectively.\n    \"\"\"\n\n    for tvar in self.transition_variables.values():\n        tvar.update_origin_outflow()\n        tvar.update_destination_inflow()\n\n    for compartment in self.compartments.values():\n        compartment.update_current_val()\n\n        # By construction (using binomial/multinomial with or without taylor expansion),\n        #   more individuals cannot leave the compartment than are in the compartment\n        ## TODO check whether the following reason is still valid: a flooring function \n        #  was added to transition variables when using Poisson distributed transitions\n        # However, for Poisson any for ANY deterministic version, it is possible\n        #   to have more individuals leaving the compartment than are in the compartment,\n        #   and hence negative-valued compartments\n        # We use this function to fix this, and also use a differentiable torch\n        #   function to be consistent with the torch implementation (this still\n        #   allows us to take derivatives in the torch implementation)\n        # The syntax is janky here -- we want everything as an array, but\n        #   we need to pass a tensor to the torch functional\n        if (\"deterministic\" in self.simulation_settings.transition_type) and \\\n           (self.simulation_settings.use_deterministic_softplus):\n            compartment.current_val = \\\n                    np.array(torch.nn.functional.softplus(torch.tensor(compartment.current_val)))\n\n        # After updating the compartment's current value,\n        #   reset its inflow and outflow attributes, to\n        #   prepare for the next iteration.\n        compartment.reset_inflow()\n        compartment.reset_outflow()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.update_epi_metrics","title":"<code>update_epi_metrics() -&gt; None</code>","text":"<p>Update current value attribute on each associated     <code>EpiMetric</code> instance.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_epi_metrics(self) -&gt; None:\n    \"\"\"\n    Update current value attribute on each associated\n        `EpiMetric` instance.\n    \"\"\"\n\n    state = self.state\n    params = self.params\n    timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n    for metric in self.epi_metrics.values():\n        metric.change_in_current_val = \\\n            metric.get_change_in_current_val(state,\n                                             params,\n                                             timesteps_per_day)\n        metric.update_current_val()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.update_transition_rates","title":"<code>update_transition_rates() -&gt; None</code>","text":"<p>Compute current transition rates for each transition variable,     and store this updated value on each variable's     current_rate attribute.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_transition_rates(self) -&gt; None:\n    \"\"\"\n    Compute current transition rates for each transition variable,\n        and store this updated value on each variable's\n        current_rate attribute.\n    \"\"\"\n\n    state = self.state\n    params = self.params\n\n    for tvar in self.transition_variables.values():\n        tvar.current_rate = tvar.get_current_rate(state, params)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModelError","title":"<code>SubpopModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for subpopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class SubpopModelError(Exception):\n    \"\"\"Custom exceptions for subpopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopParams","title":"<code>SubpopParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in model.</p> <p>Assume that <code>SubpopParams</code> fields are constant or piecewise constant throughout the simulation. For variables that are more complicated and time-dependent, use an <code>EpiMetric</code> instead.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass SubpopParams(ABC):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in model.\n\n    Assume that `SubpopParams` fields are constant or piecewise\n    constant throughout the simulation. For variables that\n    are more complicated and time-dependent, use an `EpiMetric`\n    instead.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopState","title":"<code>SubpopState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Holds current values of <code>SubpopModel</code>'s simulation state.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>@dataclass\nclass SubpopState(ABC):\n    \"\"\"\n    Holds current values of `SubpopModel`'s simulation state.\n    \"\"\"\n\n    def sync_to_current_vals(self, lookup_dict: dict):\n        \"\"\"\n        Updates `SubpopState`'s attributes according to\n        data in `lookup_dict.` Keys of `lookup_dict` must match\n        names of attributes of `SubpopState` instance.\n        \"\"\"\n\n        for name, item in lookup_dict.items():\n            setattr(self, name, item.current_val)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopState.sync_to_current_vals","title":"<code>sync_to_current_vals(lookup_dict: dict)</code>","text":"<p>Updates <code>SubpopState</code>'s attributes according to data in <code>lookup_dict.</code> Keys of <code>lookup_dict</code> must match names of attributes of <code>SubpopState</code> instance.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>def sync_to_current_vals(self, lookup_dict: dict):\n    \"\"\"\n    Updates `SubpopState`'s attributes according to\n    data in `lookup_dict.` Keys of `lookup_dict` must match\n    names of attributes of `SubpopState` instance.\n    \"\"\"\n\n    for name, item in lookup_dict.items():\n        setattr(self, name, item.current_val)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionTypes","title":"<code>TransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines available options for <code>transition_type</code> in <code>TransitionVariable</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>class TransitionTypes(str, Enum):\n    \"\"\"\n    Defines available options for `transition_type` in `TransitionVariable`.\n    \"\"\"\n    BINOM = \"binom\"\n    BINOM_DETERMINISTIC = \"binom_deterministic\"\n    BINOM_DETERMINISTIC_NO_ROUND = \"binom_deterministic_no_round\"\n    BINOM_TAYLOR_APPROX = \"binom_taylor_approx\"\n    BINOM_TAYLOR_APPROX_DETERMINISTIC = \"binom_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable","title":"<code>TransitionVariable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for transition variables in epidemiological model.</p> <p>For example, in an S-I-R model, the new number infected every iteration (the number going from S to I) in an iteration is modeled as a <code>TransitionVariable</code> subclass, with a concrete implementation of the abstract method <code>get_current_rate</code>.</p> <p>When an instance is initialized, its <code>get_realization</code> attribute is dynamically assigned, just like in the case of <code>TransitionVariableGroup</code> instantiation.</p> Dimensions <p>A (int):     Number of age groups. R (int):     Number of risk groups.</p> <p>Attributes:</p> Name Type Description <code>_transition_type</code> <code>str</code> <p>only values defined in <code>TransitionTypes</code> are valid, specifying probability distribution of transitions between compartments.</p> <code>get_current_rate</code> <code>function</code> <p>provides specific implementation for computing current rate as a function of current subpopulation simulation state and epidemiological parameters.</p> <code>current_rate</code> <code>np.ndarray of shape (A, R</code> <p>holds output from <code>get_current_rate</code> method -- used to generate random variable realizations for transitions between compartments.</p> <code>current_val</code> <code>np.ndarray of shape (A, R</code> <p>holds realization of random variable parameterized by <code>current_rate</code>.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of <code>current_val</code>, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous <code>current_val</code> value at end of simulation day t.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class TransitionVariable(ABC):\n    \"\"\"\n    Abstract base class for transition variables in\n    epidemiological model.\n\n    For example, in an S-I-R model, the new number infected\n    every iteration (the number going from S to I) in an iteration\n    is modeled as a `TransitionVariable` subclass, with a concrete\n    implementation of the abstract method `get_current_rate`.\n\n    When an instance is initialized, its `get_realization` attribute\n    is dynamically assigned, just like in the case of\n    `TransitionVariableGroup` instantiation.\n\n    Dimensions:\n        A (int):\n            Number of age groups.\n        R (int):\n            Number of risk groups.\n\n    Attributes:\n        _transition_type (str):\n            only values defined in `TransitionTypes` are valid, specifying\n            probability distribution of transitions between compartments.\n        get_current_rate (function):\n            provides specific implementation for computing current rate\n            as a function of current subpopulation simulation state and\n            epidemiological parameters.\n        current_rate (np.ndarray of shape (A, R)):\n            holds output from `get_current_rate` method -- used to generate\n            random variable realizations for transitions between compartments.\n        current_val (np.ndarray of shape (A, R)):\n            holds realization of random variable parameterized by\n            `current_rate`.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of `current_val`, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous `current_val`\n            value at end of simulation day t.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: Compartment,\n                 destination: Compartment,\n                 transition_type: TransitionTypes,\n                 is_jointly_distributed: str = False):\n        \"\"\"\n        Parameters:\n            origin (Compartment):\n                `Compartment` from which `TransitionVariable` exits.\n            destination (Compartment):\n                `Compartment` that the `TransitionVariable` enters.\n            transition_type (TransitionTypes):\n                Specifies probability distribution of transitions between compartments.\n            is_jointly_distributed (bool):\n                Indicates if transition quantity must be jointly computed\n                (i.e. if there are multiple outflows from the origin compartment).\n        \"\"\"\n\n        self.origin = origin\n        self.destination = destination\n\n        # Also see __init__ method in TransitionVariableGroup class.\n        #   The structure is similar.\n        self._transition_type = transition_type\n        self._is_jointly_distributed = is_jointly_distributed\n\n        # Assigns appropriate realization method based on transition type.\n        # If jointly distributed, no single realization function applies.\n        if is_jointly_distributed:\n            self.get_realization = None\n        else:\n            self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_rate = None\n        self.current_val = None\n\n        self.history_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; TransitionTypes:\n        return self._transition_type\n\n    @property\n    def is_jointly_distributed(self) -&gt; bool:\n        return self._is_jointly_distributed\n\n    @abstractmethod\n    def get_current_rate(self,\n                         state: SubpopState,\n                         params: SubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns current rate of transition variable,\n        based on current state of the simulation and epidemiological parameters.\n\n        Args:\n            state (SubpopState):\n                Holds subpopulation simulation state\n                (current values of `StateVariable` instances).\n            params (SubpopParams):\n                Holds values of epidemiological parameters.\n\n        Returns:\n            np.ndarray:\n                Holds age-risk transition rate.\n        \"\"\"\n        pass\n\n    def update_origin_outflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of `TransitionVariable` to\n            its origin `Compartment`'s current_outflow.\n            Used to compute total number leaving that\n            origin `Compartment`.\n        \"\"\"\n\n        self.origin.current_outflow = self.origin.current_outflow + self.current_val\n\n    def update_destination_inflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of `TransitionVariable` to\n            its destination `Compartment`'s `current_inflow`.\n            Used to compute total number leaving that\n            destination `Compartment`.\n        \"\"\"\n\n        self.destination.current_inflow = self.destination.current_inflow + self.current_val\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending `current_val`\n        attribute to `history_vals_list` in-place..\n\n        Deep copying is CRUCIAL because `current_val` is a mutable\n        np.ndarray -- without deep copying, `history_vals_list` would\n        have the same value for all elements.\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets `history_vals_list` attribute to empty list.\n        \"\"\"\n\n        self.current_rate = None\n        self.current_val = None\n        self.history_vals_list = []\n\n    def get_realization(self,\n                        RNG: np.random.Generator,\n                        num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Generate a realization of the transition process.\n\n        This method is dynamically assigned to the appropriate transition-specific\n        function (e.g., `get_binom_realization`) depending on the transition type.\n        Provides common interface so realizations can always be obtained via\n        ``get_realization``.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 Used to generate stochastic transitions in the model and control\n                 reproducibility. If deterministic transitions are used, the\n                 RNG is passed for a consistent function interface but the RNG\n                 is not used.\n            num_timesteps (int):\n                Number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            (np.ndarray of shape (A, R)):\n                Number of transitions for age-risk groups.\n        \"\"\"\n\n        pass\n\n    def get_binom_realization(self,\n                              RNG: np.random.Generator,\n                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses `RNG` to generate binomial random variable with\n        number of trials equal to population count in the\n        origin `Compartment` and probability computed from\n        a function of the `TransitionVariable`'s current rate\n        -- see `approx_binom_probability_from_rate` function\n        for details.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Element-wise Binomial distributed transitions for each\n                age-risk group, with the probability parameter generated\n                using a conversion from rates to probabilities.\n        \"\"\"\n\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n\n    def get_binom_taylor_approx_realization(self,\n                                            RNG: np.random.Generator,\n                                            num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses `RNG` to generate binomial random variable with\n            number of trials equal to population count in the\n            origin `Compartment` and probability equal to\n            the `TransitionVariable`'s `current_rate` / `num_timesteps`.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Element-wise Binomial distributed transitions for each\n                age-risk group, with the probability parameter generated\n                using a Taylor approximation.\n        \"\"\"\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=self.current_rate * (1.0 / num_timesteps))\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Generates realizations from a Poisson distribution.\n\n        The rate is computed element-wise from each age-risk group as:\n        (origin compartment population count x `current_rate` / `num_timesteps`)\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Poisson-distributed integers representing number\n                of individuals transitioning in each age-risk group.\n        \"\"\"\n        # Make sure random variable values are not greater than the base counts\n        value = RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n        value = np.minimum(value, self.base_count)\n\n        return value\n\n    def get_binom_deterministic_realization(self,\n                                            RNG: np.random.Generator,\n                                            num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin `Compartment` and\n        probability is computed from a function of the `TransitionVariable`'s\n        current rate -- see the `approx_binom_probability_from_rate`\n        function for details.\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Number of individuals transitioning compartments in each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count *\n                          approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                          dtype=int)\n\n    def get_binom_deterministic_no_round_realization(self,\n                                                     RNG: np.random.Generator,\n                                                     num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        The same as `get_binom_deterministic_realization` except no rounding --\n        so the populations can be non-integer. This is used to test the torch\n        implementation (because that implementation does not round either).\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                (Non-integer) \"number of individuals\" transitioning compartments in\n                each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count *\n                          approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n\n    def get_binom_taylor_approx_deterministic_realization(self,\n                                                          RNG: np.random.Generator,\n                                                          num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin `Compartment` and\n        probability equals the `TransitionVariable`'s `current_rate` /\n        `num_timesteps`.\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Number of individuals transitioning compartments in each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of Poisson distribution,\n        given by (population count in the origin `Compartment` x\n        `TransitionVariable`'s `current_rate` / `num_timesteps`).\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Number of individuals transitioning compartments in each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    @property\n    def base_count(self) -&gt; np.ndarray:\n        return self.origin.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.__init__","title":"<code>__init__(origin: Compartment, destination: Compartment, transition_type: TransitionTypes, is_jointly_distributed: str = False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Compartment</code> <p><code>Compartment</code> from which <code>TransitionVariable</code> exits.</p> required <code>destination</code> <code>Compartment</code> <p><code>Compartment</code> that the <code>TransitionVariable</code> enters.</p> required <code>transition_type</code> <code>TransitionTypes</code> <p>Specifies probability distribution of transitions between compartments.</p> required <code>is_jointly_distributed</code> <code>bool</code> <p>Indicates if transition quantity must be jointly computed (i.e. if there are multiple outflows from the origin compartment).</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             origin: Compartment,\n             destination: Compartment,\n             transition_type: TransitionTypes,\n             is_jointly_distributed: str = False):\n    \"\"\"\n    Parameters:\n        origin (Compartment):\n            `Compartment` from which `TransitionVariable` exits.\n        destination (Compartment):\n            `Compartment` that the `TransitionVariable` enters.\n        transition_type (TransitionTypes):\n            Specifies probability distribution of transitions between compartments.\n        is_jointly_distributed (bool):\n            Indicates if transition quantity must be jointly computed\n            (i.e. if there are multiple outflows from the origin compartment).\n    \"\"\"\n\n    self.origin = origin\n    self.destination = destination\n\n    # Also see __init__ method in TransitionVariableGroup class.\n    #   The structure is similar.\n    self._transition_type = transition_type\n    self._is_jointly_distributed = is_jointly_distributed\n\n    # Assigns appropriate realization method based on transition type.\n    # If jointly distributed, no single realization function applies.\n    if is_jointly_distributed:\n        self.get_realization = None\n    else:\n        self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_rate = None\n    self.current_val = None\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_deterministic_no_round_realization","title":"<code>get_binom_deterministic_no_round_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>The same as <code>get_binom_deterministic_realization</code> except no rounding -- so the populations can be non-integer. This is used to test the torch implementation (because that implementation does not round either).</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) (Non-integer) \"number of individuals\" transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_deterministic_no_round_realization(self,\n                                                 RNG: np.random.Generator,\n                                                 num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    The same as `get_binom_deterministic_realization` except no rounding --\n    so the populations can be non-integer. This is used to test the torch\n    implementation (because that implementation does not round either).\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            (Non-integer) \"number of individuals\" transitioning compartments in\n            each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count *\n                      approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_deterministic_realization","title":"<code>get_binom_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of binomial distribution (number of trials x probability), where number of trials equals population count in the origin <code>Compartment</code> and probability is computed from a function of the <code>TransitionVariable</code>'s current rate -- see the <code>approx_binom_probability_from_rate</code> function for details.</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Number of individuals transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_deterministic_realization(self,\n                                        RNG: np.random.Generator,\n                                        num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n    (number of trials x probability), where number of trials\n    equals population count in the origin `Compartment` and\n    probability is computed from a function of the `TransitionVariable`'s\n    current rate -- see the `approx_binom_probability_from_rate`\n    function for details.\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Number of individuals transitioning compartments in each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count *\n                      approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                      dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_realization","title":"<code>get_binom_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Uses <code>RNG</code> to generate binomial random variable with number of trials equal to population count in the origin <code>Compartment</code> and probability computed from a function of the <code>TransitionVariable</code>'s current rate -- see <code>approx_binom_probability_from_rate</code> function for details.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Element-wise Binomial distributed transitions for each age-risk group, with the probability parameter generated using a conversion from rates to probabilities.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_realization(self,\n                          RNG: np.random.Generator,\n                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses `RNG` to generate binomial random variable with\n    number of trials equal to population count in the\n    origin `Compartment` and probability computed from\n    a function of the `TransitionVariable`'s current rate\n    -- see `approx_binom_probability_from_rate` function\n    for details.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Element-wise Binomial distributed transitions for each\n            age-risk group, with the probability parameter generated\n            using a conversion from rates to probabilities.\n    \"\"\"\n\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_taylor_approx_deterministic_realization","title":"<code>get_binom_taylor_approx_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of binomial distribution (number of trials x probability), where number of trials equals population count in the origin <code>Compartment</code> and probability equals the <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>.</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Number of individuals transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_taylor_approx_deterministic_realization(self,\n                                                      RNG: np.random.Generator,\n                                                      num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n    (number of trials x probability), where number of trials\n    equals population count in the origin `Compartment` and\n    probability equals the `TransitionVariable`'s `current_rate` /\n    `num_timesteps`.\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Number of individuals transitioning compartments in each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_taylor_approx_realization","title":"<code>get_binom_taylor_approx_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Uses <code>RNG</code> to generate binomial random variable with     number of trials equal to population count in the     origin <code>Compartment</code> and probability equal to     the <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Element-wise Binomial distributed transitions for each age-risk group, with the probability parameter generated using a Taylor approximation.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_taylor_approx_realization(self,\n                                        RNG: np.random.Generator,\n                                        num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses `RNG` to generate binomial random variable with\n        number of trials equal to population count in the\n        origin `Compartment` and probability equal to\n        the `TransitionVariable`'s `current_rate` / `num_timesteps`.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Element-wise Binomial distributed transitions for each\n            age-risk group, with the probability parameter generated\n            using a Taylor approximation.\n    \"\"\"\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=self.current_rate * (1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_current_rate","title":"<code>get_current_rate(state: SubpopState, params: SubpopParams) -&gt; np.ndarray</code>  <code>abstractmethod</code>","text":"<p>Computes and returns current rate of transition variable, based on current state of the simulation and epidemiological parameters.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>Holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>Holds values of epidemiological parameters.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Holds age-risk transition rate.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef get_current_rate(self,\n                     state: SubpopState,\n                     params: SubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns current rate of transition variable,\n    based on current state of the simulation and epidemiological parameters.\n\n    Args:\n        state (SubpopState):\n            Holds subpopulation simulation state\n            (current values of `StateVariable` instances).\n        params (SubpopParams):\n            Holds values of epidemiological parameters.\n\n    Returns:\n        np.ndarray:\n            Holds age-risk transition rate.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of Poisson distribution, given by (population count in the origin <code>Compartment</code> x <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>).</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Number of individuals transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of Poisson distribution,\n    given by (population count in the origin `Compartment` x\n    `TransitionVariable`'s `current_rate` / `num_timesteps`).\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Number of individuals transitioning compartments in each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_poisson_realization","title":"<code>get_poisson_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Generates realizations from a Poisson distribution.</p> <p>The rate is computed element-wise from each age-risk group as: (origin compartment population count x <code>current_rate</code> / <code>num_timesteps</code>)</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Poisson-distributed integers representing number of individuals transitioning in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Generates realizations from a Poisson distribution.\n\n    The rate is computed element-wise from each age-risk group as:\n    (origin compartment population count x `current_rate` / `num_timesteps`)\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Poisson-distributed integers representing number\n            of individuals transitioning in each age-risk group.\n    \"\"\"\n    # Make sure random variable values are not greater than the base counts\n    value = RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n    value = np.minimum(value, self.base_count)\n\n    return value\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_realization","title":"<code>get_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Generate a realization of the transition process.</p> <p>This method is dynamically assigned to the appropriate transition-specific function (e.g., <code>get_binom_realization</code>) depending on the transition type. Provides common interface so realizations can always be obtained via <code>get_realization</code>.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>Used to generate stochastic transitions in the model and control  reproducibility. If deterministic transitions are used, the  RNG is passed for a consistent function interface but the RNG  is not used.</p> required <code>num_timesteps</code> <code>int</code> <p>Number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>np.ndarray of shape (A, R)</code> <p>Number of transitions for age-risk groups.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_realization(self,\n                    RNG: np.random.Generator,\n                    num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Generate a realization of the transition process.\n\n    This method is dynamically assigned to the appropriate transition-specific\n    function (e.g., `get_binom_realization`) depending on the transition type.\n    Provides common interface so realizations can always be obtained via\n    ``get_realization``.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             Used to generate stochastic transitions in the model and control\n             reproducibility. If deterministic transitions are used, the\n             RNG is passed for a consistent function interface but the RNG\n             is not used.\n        num_timesteps (int):\n            Number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        (np.ndarray of shape (A, R)):\n            Number of transitions for age-risk groups.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets <code>history_vals_list</code> attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets `history_vals_list` attribute to empty list.\n    \"\"\"\n\n    self.current_rate = None\n    self.current_val = None\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.save_history","title":"<code>save_history() -&gt; None</code>","text":"<p>Saves current value to history by appending <code>current_val</code> attribute to <code>history_vals_list</code> in-place..</p> <p>Deep copying is CRUCIAL because <code>current_val</code> is a mutable np.ndarray -- without deep copying, <code>history_vals_list</code> would have the same value for all elements.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending `current_val`\n    attribute to `history_vals_list` in-place..\n\n    Deep copying is CRUCIAL because `current_val` is a mutable\n    np.ndarray -- without deep copying, `history_vals_list` would\n    have the same value for all elements.\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.update_destination_inflow","title":"<code>update_destination_inflow() -&gt; None</code>","text":"<p>Adds current realization of <code>TransitionVariable</code> to     its destination <code>Compartment</code>'s <code>current_inflow</code>.     Used to compute total number leaving that     destination <code>Compartment</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_destination_inflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of `TransitionVariable` to\n        its destination `Compartment`'s `current_inflow`.\n        Used to compute total number leaving that\n        destination `Compartment`.\n    \"\"\"\n\n    self.destination.current_inflow = self.destination.current_inflow + self.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.update_origin_outflow","title":"<code>update_origin_outflow() -&gt; None</code>","text":"<p>Adds current realization of <code>TransitionVariable</code> to     its origin <code>Compartment</code>'s current_outflow.     Used to compute total number leaving that     origin <code>Compartment</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_origin_outflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of `TransitionVariable` to\n        its origin `Compartment`'s current_outflow.\n        Used to compute total number leaving that\n        origin `Compartment`.\n    \"\"\"\n\n    self.origin.current_outflow = self.origin.current_outflow + self.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup","title":"<code>TransitionVariableGroup</code>","text":"<p>Container for <code>TransitionVariable</code> objects to handle joint sampling, when there are multiple outflows from a single compartment.</p> <p>For example, if all outflows of compartment <code>H</code> are: <code>R</code> and <code>D</code>, i.e. from the hospital, individuals either recover or die, a <code>TransitionVariableGroup</code> that holds both <code>R</code> and <code>D</code> handles the correct correlation structure between <code>R</code> and <code>D.</code></p> <p>When an instance is initialized, its <code>get_joint_realization</code> attribute is dynamically assigned to a method according to its <code>transition_type</code> attribute. This enables all instances to use the same method during simulation.</p> Dimensions <p>M (int):     number of outgoing compartments from the origin compartment A (int):     number of age groups R (int):     number of risk groups</p> <p>Attributes:</p> Name Type Description <code>origin</code> <code>Compartment</code> <p>Specifies origin of <code>TransitionVariableGroup</code> -- corresponding populations leave this compartment.</p> <code>_transition_type</code> <code>str</code> <p>Only values defined in <code>JointTransitionTypes</code> are valid, specifies joint probability distribution of all outflows from origin.</p> <code>transition_variables</code> <code>list[`TransitionVariable`]</code> <p>Specifying <code>TransitionVariable</code> instances that outflow from origin -- order does not matter.</p> <code>get_joint_realization</code> <code>function</code> <p>Assigned at initialization, generates realizations according to probability distribution given by <code>transition_type</code>, returns np.ndarray of either shape (M, A, R) or ((M+1), A, R), where M is the length of <code>transition_variables</code> (i.e., number of outflows from origin), A is the number of age groups, R is number of risk groups.</p> <code>current_vals_list</code> <code>list</code> <p>Used to store results from <code>get_joint_realization</code> -- has either M or M+1 arrays of shape (A, R).</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class TransitionVariableGroup:\n    \"\"\"\n    Container for `TransitionVariable` objects to handle joint sampling,\n    when there are multiple outflows from a single compartment.\n\n    For example, if all outflows of compartment `H` are: `R` and `D`,\n    i.e. from the hospital, individuals either recover or die,\n    a `TransitionVariableGroup` that holds both `R` and `D` handles\n    the correct correlation structure between `R` and `D.`\n\n    When an instance is initialized, its `get_joint_realization` attribute\n    is dynamically assigned to a method according to its `transition_type`\n    attribute. This enables all instances to use the same method during\n    simulation.\n\n    Dimensions:\n        M (int):\n            number of outgoing compartments from the origin compartment\n        A (int):\n            number of age groups\n        R (int):\n            number of risk groups\n\n    Attributes:\n        origin (Compartment):\n            Specifies origin of `TransitionVariableGroup` --\n            corresponding populations leave this compartment.\n        _transition_type (str):\n            Only values defined in `JointTransitionTypes` are valid,\n            specifies joint probability distribution of all outflows\n            from origin.\n        transition_variables (list[`TransitionVariable`]):\n            Specifying `TransitionVariable` instances that outflow from origin --\n            order does not matter.\n        get_joint_realization (function):\n            Assigned at initialization, generates realizations according\n            to probability distribution given by `transition_type`,\n            returns np.ndarray of either shape (M, A, R) or ((M+1), A, R),\n            where M is the length of `transition_variables` (i.e., number of\n            outflows from origin), A is the number of age groups, R is number of\n            risk groups.\n        current_vals_list (list):\n            Used to store results from `get_joint_realization` --\n            has either M or M+1 arrays of shape (A, R).\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: Compartment,\n                 transition_type: TransitionTypes,\n                 transition_variables: list[TransitionVariable]):\n        \"\"\"\n        Args:\n            transition_type (TransitionTypes):\n                Specifies probability distribution of transitions between compartments.\n\n        See class docstring for other parameters.\n        \"\"\"\n\n        self.origin = origin\n\n        # Using a list is important here because we want to keep the order\n        #   of transition variables -- this determines the index in the\n        #   current rates array\n        self.transition_variables = transition_variables\n\n        # If marginal transition type is any kind of binomial transition,\n        #   then its joint transition type is a multinomial counterpart\n        # For example, if the marginal transition type is TransitionTypes.BINOM_DETERMINISTIC,\n        #   then the joint transition type is JointTransitionTypes.MULTINOM_DETERMINISTIC\n        transition_type = transition_type.replace(\"binom\", \"multinom\")\n        self._transition_type = transition_type\n\n        # Dynamically assign a method to get_joint_realization attribute\n        #   based on the value of transition_type\n        # getattr fetches a method by name\n        self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; JointTransitionTypes:\n        return self._transition_type\n\n    def get_total_rate(self) -&gt; np.ndarray:\n        \"\"\"\n        Return the age-risk-specific total transition rate,\n        which is the sum of the current rate of each transition variable\n        in this transition variable group.\n\n        Used to properly scale multinomial probabilities vector so\n        that elements sum to 1.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Array with values corresponding to sum of current rates of\n                transition variables in transition variable group, where\n                elements correspond to age-risk groups.\n        \"\"\"\n\n        # axis 0: corresponds to outgoing transition variable\n        # axis 1: corresponds to age groups\n        # axis 2: corresponds to risk groups\n        # --&gt; summing over axis 0 gives the total rate for each age-risk group\n        return np.sum(self.get_current_rates_array(), axis=0)\n\n    def get_probabilities_array(self,\n                                num_timesteps: int) -&gt; list:\n        \"\"\"\n        Returns an array of probabilities used for joint binomial\n        (multinomial) transitions (`get_multinom_realization` method).\n\n        Returns:\n            (np.ndarray of shape (M+1, A, R)\n                Contains positive floats &lt;= 1, corresponding to probability\n                of transitioning to a compartment for that outgoing compartment\n                and age-risk group -- note the \"+1\" corresponds to the multinomial\n                outcome of staying in the same compartment (we can think of as\n                transitioning to the same compartment).\n        \"\"\"\n\n        total_rate = self.get_total_rate()\n\n        total_outgoing_probability = approx_binom_probability_from_rate(total_rate,\n                                                                        1 / num_timesteps)\n\n        # Create probabilities_list, where element i corresponds to the\n        #   transition variable i's current rate divided by the total rate,\n        #   multiplized by the total outgoing probability\n        # This generates the probabilities array that parameterizes the\n        #   multinomial distribution\n        probabilities_list = []\n\n        for transition_variable in self.transition_variables:\n            probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                      total_outgoing_probability)\n\n        # Append the probability that a person stays in the compartment\n        probabilities_list.append(1 - total_outgoing_probability)\n\n        return np.asarray(probabilities_list)\n\n    def get_current_rates_array(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of current rates of transition variables in\n        `transition_variables` -- ith element in array\n        corresponds to current rate of ith transition variable.\n\n        Returns:\n            (np.ndarray of shape (M, A, R))\n                array of positive floats corresponding to current rate\n                element-wise for an outgoing compartment and age-risk group\n        \"\"\"\n\n        current_rates_list = []\n        for tvar in self.transition_variables:\n            current_rates_list.append(tvar.current_rate)\n\n        return np.asarray(current_rates_list)\n\n    def get_joint_realization(self,\n                              RNG: np.random.Generator,\n                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        This function is dynamically assigned based on the `TransitionVariableGroup`'s\n            `transition_type`. It is set to the appropriate distribution-specific method.\n\n        See `get_realization` for parameters.\n        \"\"\"\n\n        pass\n\n    def get_multinom_realization(self,\n                                 RNG: np.random.Generator,\n                                 num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive floats with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    probabilities_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_multinom_taylor_approx_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution\n        using Taylor Series approximation for probability parameter.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        current_rates_array = self.get_current_rates_array()\n\n        total_rate = self.get_total_rate()\n\n        # Multiply current rates array by length of time interval (1 / num_timesteps)\n        # Also append additional value corresponding to probability of\n        #   remaining in current epi compartment (not transitioning at all)\n        # Note: \"vstack\" function here works better than append function because append\n        #   automatically flattens the resulting array, resulting in dimension issues\n        current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                                np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    current_scaled_rates_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from Poisson distribution.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M, A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r)\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n        transition_variables = self.transition_variables\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                for outflow_ix in range(num_outflows):\n                    realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                        self.origin.current_val[age_group, risk_group] *\n                        transition_variables[outflow_ix].current_rate[\n                            age_group, risk_group] / num_timesteps)\n\n        return realizations_array\n\n    def get_multinom_deterministic_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `get_multinom_realization` --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n        return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n\n    def get_multinom_deterministic_no_round_realization(self,\n                                                        RNG: np.random.Generator,\n                                                        num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        The same as `get_multinom_deterministic_realization` except no rounding --\n        so the populations can be non-integer. This is used to test the torch\n        implementation (because that implementation does not round either).\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive floats with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n        return np.asarray(self.origin.current_val * probabilities_array)\n\n    def get_multinom_taylor_approx_deterministic_realization(self,\n                                                             RNG: np.random.Generator,\n                                                             num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `get_multinom_taylor_approx_realization` --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive floats with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        current_rates_array = self.get_current_rates_array()\n        return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `get_poisson_realization` --\n        uses mean (rate array) as realization rather than randomly sampling.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n        \"\"\"\n\n        return np.asarray(self.origin.current_val *\n                          self.get_current_rates_array() / num_timesteps, dtype=int)\n\n    def reset(self) -&gt; None:\n        self.current_vals_list = []\n\n    def update_transition_variable_realizations(self) -&gt; None:\n        \"\"\"\n        Updates current_val attribute on all `TransitionVariable`\n        instances contained in this `TransitionVariableGroup`.\n        \"\"\"\n\n        # Since the ith element in probabilities_array corresponds to the ith transition variable\n        #   in transition_variables, the ith element in multinom_realizations_list\n        #   also corresponds to the ith transition variable in transition_variables\n        # Update the current realization of the transition variables contained in this group\n        for ix in range(len(self.transition_variables)):\n            self.transition_variables[ix].current_val = \\\n                self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.__init__","title":"<code>__init__(origin: Compartment, transition_type: TransitionTypes, transition_variables: list[TransitionVariable])</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transition_type</code> <code>TransitionTypes</code> <p>Specifies probability distribution of transitions between compartments.</p> required <p>See class docstring for other parameters.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             origin: Compartment,\n             transition_type: TransitionTypes,\n             transition_variables: list[TransitionVariable]):\n    \"\"\"\n    Args:\n        transition_type (TransitionTypes):\n            Specifies probability distribution of transitions between compartments.\n\n    See class docstring for other parameters.\n    \"\"\"\n\n    self.origin = origin\n\n    # Using a list is important here because we want to keep the order\n    #   of transition variables -- this determines the index in the\n    #   current rates array\n    self.transition_variables = transition_variables\n\n    # If marginal transition type is any kind of binomial transition,\n    #   then its joint transition type is a multinomial counterpart\n    # For example, if the marginal transition type is TransitionTypes.BINOM_DETERMINISTIC,\n    #   then the joint transition type is JointTransitionTypes.MULTINOM_DETERMINISTIC\n    transition_type = transition_type.replace(\"binom\", \"multinom\")\n    self._transition_type = transition_type\n\n    # Dynamically assign a method to get_joint_realization attribute\n    #   based on the value of transition_type\n    # getattr fetches a method by name\n    self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_current_rates_array","title":"<code>get_current_rates_array() -&gt; np.ndarray</code>","text":"<p>Returns an array of current rates of transition variables in <code>transition_variables</code> -- ith element in array corresponds to current rate of ith transition variable.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M, A, R)) array of positive floats corresponding to current rate element-wise for an outgoing compartment and age-risk group</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_current_rates_array(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of current rates of transition variables in\n    `transition_variables` -- ith element in array\n    corresponds to current rate of ith transition variable.\n\n    Returns:\n        (np.ndarray of shape (M, A, R))\n            array of positive floats corresponding to current rate\n            element-wise for an outgoing compartment and age-risk group\n    \"\"\"\n\n    current_rates_list = []\n    for tvar in self.transition_variables:\n        current_rates_list.append(tvar.current_rate)\n\n    return np.asarray(current_rates_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_joint_realization","title":"<code>get_joint_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>This function is dynamically assigned based on the <code>TransitionVariableGroup</code>'s     <code>transition_type</code>. It is set to the appropriate distribution-specific method.</p> <p>See <code>get_realization</code> for parameters.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_joint_realization(self,\n                          RNG: np.random.Generator,\n                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    This function is dynamically assigned based on the `TransitionVariableGroup`'s\n        `transition_type`. It is set to the appropriate distribution-specific method.\n\n    See `get_realization` for parameters.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_deterministic_no_round_realization","title":"<code>get_multinom_deterministic_no_round_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>The same as <code>get_multinom_deterministic_realization</code> except no rounding -- so the populations can be non-integer. This is used to test the torch implementation (because that implementation does not round either).</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive floats with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_deterministic_no_round_realization(self,\n                                                    RNG: np.random.Generator,\n                                                    num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    The same as `get_multinom_deterministic_realization` except no rounding --\n    so the populations can be non-integer. This is used to test the torch\n    implementation (because that implementation does not round either).\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive floats with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n    return np.asarray(self.origin.current_val * probabilities_array)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_deterministic_realization","title":"<code>get_multinom_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>get_multinom_realization</code> -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_deterministic_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `get_multinom_realization` --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n    return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_realization","title":"<code>get_multinom_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive floats with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_realization(self,\n                             RNG: np.random.Generator,\n                             num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive floats with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                probabilities_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_taylor_approx_deterministic_realization","title":"<code>get_multinom_taylor_approx_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>get_multinom_taylor_approx_realization</code> -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive floats with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_taylor_approx_deterministic_realization(self,\n                                                         RNG: np.random.Generator,\n                                                         num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `get_multinom_taylor_approx_realization` --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive floats with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    current_rates_array = self.get_current_rates_array()\n    return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_taylor_approx_realization","title":"<code>get_multinom_taylor_approx_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution using Taylor Series approximation for probability parameter.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_taylor_approx_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution\n    using Taylor Series approximation for probability parameter.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    current_rates_array = self.get_current_rates_array()\n\n    total_rate = self.get_total_rate()\n\n    # Multiply current rates array by length of time interval (1 / num_timesteps)\n    # Also append additional value corresponding to probability of\n    #   remaining in current epi compartment (not transitioning at all)\n    # Note: \"vstack\" function here works better than append function because append\n    #   automatically flattens the resulting array, resulting in dimension issues\n    current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                            np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                current_scaled_rates_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>get_poisson_realization</code> -- uses mean (rate array) as realization rather than randomly sampling.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r) --</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `get_poisson_realization` --\n    uses mean (rate array) as realization rather than randomly sampling.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n    \"\"\"\n\n    return np.asarray(self.origin.current_val *\n                      self.get_current_rates_array() / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_poisson_realization","title":"<code>get_poisson_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from Poisson distribution.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M, A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r)</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from Poisson distribution.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M, A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r)\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n    transition_variables = self.transition_variables\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            for outflow_ix in range(num_outflows):\n                realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                    self.origin.current_val[age_group, risk_group] *\n                    transition_variables[outflow_ix].current_rate[\n                        age_group, risk_group] / num_timesteps)\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_probabilities_array","title":"<code>get_probabilities_array(num_timesteps: int) -&gt; list</code>","text":"<p>Returns an array of probabilities used for joint binomial (multinomial) transitions (<code>get_multinom_realization</code> method).</p> <p>Returns:</p> Type Description <code>list</code> <p>(np.ndarray of shape (M+1, A, R) Contains positive floats &lt;= 1, corresponding to probability of transitioning to a compartment for that outgoing compartment and age-risk group -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (we can think of as transitioning to the same compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_probabilities_array(self,\n                            num_timesteps: int) -&gt; list:\n    \"\"\"\n    Returns an array of probabilities used for joint binomial\n    (multinomial) transitions (`get_multinom_realization` method).\n\n    Returns:\n        (np.ndarray of shape (M+1, A, R)\n            Contains positive floats &lt;= 1, corresponding to probability\n            of transitioning to a compartment for that outgoing compartment\n            and age-risk group -- note the \"+1\" corresponds to the multinomial\n            outcome of staying in the same compartment (we can think of as\n            transitioning to the same compartment).\n    \"\"\"\n\n    total_rate = self.get_total_rate()\n\n    total_outgoing_probability = approx_binom_probability_from_rate(total_rate,\n                                                                    1 / num_timesteps)\n\n    # Create probabilities_list, where element i corresponds to the\n    #   transition variable i's current rate divided by the total rate,\n    #   multiplized by the total outgoing probability\n    # This generates the probabilities array that parameterizes the\n    #   multinomial distribution\n    probabilities_list = []\n\n    for transition_variable in self.transition_variables:\n        probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                  total_outgoing_probability)\n\n    # Append the probability that a person stays in the compartment\n    probabilities_list.append(1 - total_outgoing_probability)\n\n    return np.asarray(probabilities_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_total_rate","title":"<code>get_total_rate() -&gt; np.ndarray</code>","text":"<p>Return the age-risk-specific total transition rate, which is the sum of the current rate of each transition variable in this transition variable group.</p> <p>Used to properly scale multinomial probabilities vector so that elements sum to 1.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Array with values corresponding to sum of current rates of transition variables in transition variable group, where elements correspond to age-risk groups.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_total_rate(self) -&gt; np.ndarray:\n    \"\"\"\n    Return the age-risk-specific total transition rate,\n    which is the sum of the current rate of each transition variable\n    in this transition variable group.\n\n    Used to properly scale multinomial probabilities vector so\n    that elements sum to 1.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Array with values corresponding to sum of current rates of\n            transition variables in transition variable group, where\n            elements correspond to age-risk groups.\n    \"\"\"\n\n    # axis 0: corresponds to outgoing transition variable\n    # axis 1: corresponds to age groups\n    # axis 2: corresponds to risk groups\n    # --&gt; summing over axis 0 gives the total rate for each age-risk group\n    return np.sum(self.get_current_rates_array(), axis=0)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.update_transition_variable_realizations","title":"<code>update_transition_variable_realizations() -&gt; None</code>","text":"<p>Updates current_val attribute on all <code>TransitionVariable</code> instances contained in this <code>TransitionVariableGroup</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_transition_variable_realizations(self) -&gt; None:\n    \"\"\"\n    Updates current_val attribute on all `TransitionVariable`\n    instances contained in this `TransitionVariableGroup`.\n    \"\"\"\n\n    # Since the ith element in probabilities_array corresponds to the ith transition variable\n    #   in transition_variables, the ith element in multinom_realizations_list\n    #   also corresponds to the ith transition variable in transition_variables\n    # Update the current realization of the transition variables contained in this group\n    for ix in range(len(self.transition_variables)):\n        self.transition_variables[ix].current_val = \\\n            self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.UniformSamplingSpec","title":"<code>UniformSamplingSpec</code>  <code>dataclass</code>","text":"<p>Holds Uniform distribution info to randomly sample a subpop model's <code>SubpopParams</code> attribute.</p> <p>Attributes:</p> Name Type Description <code>lower_bound</code> <code>[ndarray | float]</code> <p>Lower bound(s) of the uniform distribution. Can be a scalar, shape (A,) array, or shape (A, R) array depending on <code>param_shape</code>.</p> <code>upper_bound</code> <code>[ndarray | float]</code> <p>Upper bound(s) of the uniform distribution. Must have the same shape as <code>lower_bound</code>.</p> <code>param_shape</code> <code>ParamShapes</code> <p>Describes how the parameter varies across subpopulations (scalar, by age, or by age and risk).</p> <code>num_decimals</code> <code>positive int</code> <p>Optional number of decimals to keep after rounding -- default is 2.</p> Source code in <code>CLT_BaseModel/clt_toolkit/sampling.py</code> <pre><code>@dataclass(frozen=True)\nclass UniformSamplingSpec:\n    \"\"\"\n    Holds Uniform distribution info to randomly sample a\n    subpop model's `SubpopParams` attribute.\n\n    Attributes:\n        lower_bound ([np.ndarray | float]):\n            Lower bound(s) of the uniform distribution. Can be a scalar,\n            shape (A,) array, or shape (A, R) array depending on `param_shape`.\n        upper_bound ([np.ndarray | float]):\n            Upper bound(s) of the uniform distribution. Must have the same shape\n            as `lower_bound`.\n        param_shape (ParamShapes):\n            Describes how the parameter varies across subpopulations\n            (scalar, by age, or by age and risk).\n        num_decimals (positive int):\n            Optional number of decimals to keep after rounding -- default is 2.\n    \"\"\"\n\n    lower_bound: Optional[np.ndarray | float] = None\n    upper_bound: Optional[np.ndarray | float] = None\n    param_shape: Optional[ParamShapes] = None\n    num_decimals: Optional[int] = 2\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.aggregate_daily_tvar_history","title":"<code>aggregate_daily_tvar_history(metapop_model: MetapopModel, transition_var_name_list: list[str]) -&gt; np.ndarray</code>","text":"<p>Sum the history values of a given transition variable across all subpopulations and across timesteps per day, so that we have the total number that transitioned compartments in a day.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>The metapopulation model containing subpopulations.</p> required <code>transition_var_name</code> <code>str</code> <p>Name of the transition variable to sum.</p> required <p>Returns:</p> Name Type Description <code>total</code> <code>ndarray</code> <p>Array of shape (num_days, A, R) containing the sum across all subpopulations, where A = number of age groups, and R = number of risk groups. Each element contains the total number of individuals who transitioned that day for the given age and risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/sampling.py</code> <pre><code>def aggregate_daily_tvar_history(metapop_model: MetapopModel,\n                                 transition_var_name_list: list[str]) -&gt; np.ndarray:\n    \"\"\"\n    Sum the history values of a given transition variable\n    across all subpopulations and across timesteps per day,\n    so that we have the total number that transitioned compartments\n    in a day.\n\n    Parameters:\n        metapop_model (MetapopModel):\n            The metapopulation model containing subpopulations.\n        transition_var_name (str):\n            Name of the transition variable to sum.\n\n    Returns:\n        total (np.ndarray):\n            Array of shape (num_days, A, R) containing the sum across all subpopulations,\n            where A = number of age groups, and R = number of risk groups.\n            Each element contains the total number of individuals who transitioned that\n            day for the given age and risk group.\n    \"\"\"\n    # Convert each subpop's history list to a NumPy array\n    all_arrays = [\n        np.asarray(getattr(subpop, transition_var_name).history_vals_list)\n        for subpop in metapop_model.subpop_models.values()\n        for transition_var_name in transition_var_name_list\n    ]\n\n    # Stack along new subpop dimension (axis=0) and sum across subpops\n    total = np.sum(np.stack(all_arrays, axis=0), axis=0)\n\n    # Each subpopulation model should have the same simulation settings, so\n    #   just grab the first subpop model\n    num_timesteps = metapop_model.subpop_models[0].simulation_settings.timesteps_per_day\n\n    # Transition variable history contains values recorded at each TIMESTEP.\n    # To get DAILY totals, we sum blocks of `num_timesteps` consecutive timesteps.\n    return daily_sum_over_timesteps(total, num_timesteps)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.approx_binom_probability_from_rate","title":"<code>approx_binom_probability_from_rate(rate: np.ndarray, interval_length: int) -&gt; np.ndarray</code>","text":"<p>Converts a rate (events per time) to the probability of any event occurring in the next time interval of length <code>interval_length</code>, assuming the number of events occurring in time interval follows a Poisson distribution with given rate parameter.</p> <p>The probability of 0 events in <code>interval_length</code> is e^(-<code>rate</code> * <code>interval_length</code>), so the probability of any event in <code>interval_length</code> is 1 - e^(-<code>rate</code> * <code>interval_length</code>).</p> <p>Rate must be A x R <code>np.ndarray</code>, where A is the number of age groups and R is the number of risk groups. Rate is transformed to A x R <code>np.ndarray</code> corresponding to probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>np.ndarray of shape (A, R</code> <p>Rate parameters in a Poisson distribution per age-risk group.</p> required <code>interval_length</code> <code>positive int</code> <p>Length of time interval in simulation days.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R): Array of positive scalars corresponding to probability that any individual in an age-risk group transitions compartments.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def approx_binom_probability_from_rate(rate: np.ndarray,\n                                       interval_length: int) -&gt; np.ndarray:\n    \"\"\"\n    Converts a rate (events per time) to the probability of any event\n    occurring in the next time interval of length `interval_length`,\n    assuming the number of events occurring in time interval\n    follows a Poisson distribution with given rate parameter.\n\n    The probability of 0 events in `interval_length` is\n    e^(-`rate` * `interval_length`), so the probability of any event\n    in `interval_length` is 1 - e^(-`rate` * `interval_length`).\n\n    Rate must be A x R `np.ndarray`, where A is the number of\n    age groups and R is the number of risk groups. Rate is transformed to\n    A x R `np.ndarray` corresponding to probabilities.\n\n    Parameters:\n        rate (np.ndarray of shape (A, R)):\n            Rate parameters in a Poisson distribution per age-risk group.\n        interval_length (positive int):\n            Length of time interval in simulation days.\n\n    Returns:\n        np.ndarray of shape (A, R):\n            Array of positive scalars corresponding to probability that\n            any individual in an age-risk group transitions compartments.\n    \"\"\"\n\n    return 1 - np.exp(-rate * interval_length)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.check_is_subset_list","title":"<code>check_is_subset_list(listA: list, listB: list) -&gt; bool</code>","text":"<p>Parameters:</p> Name Type Description Default <code>listA</code> <code>list</code> <p>list-like of elements to check if subset of listB.</p> required <code>listB</code> <code>list</code> <p>list-like of elements.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if listA is a subset of listB, and False otherwise.</p> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def check_is_subset_list(listA: list,\n                         listB: list) -&gt; bool:\n    \"\"\"\n    Params:\n        listA (list):\n            list-like of elements to check if subset of listB.\n        listB (list):\n            list-like of elements.\n\n    Returns:\n        True if listA is a subset of listB, and False otherwise.\n    \"\"\"\n\n    return all(item in listB for item in listA)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.convert_dict_vals_lists_to_arrays","title":"<code>convert_dict_vals_lists_to_arrays(d: dict) -&gt; dict</code>","text":"<p>Converts dictionary of lists to dictionary of arrays to support <code>numpy</code> operations.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def convert_dict_vals_lists_to_arrays(d: dict) -&gt; dict:\n    \"\"\"\n    Converts dictionary of lists to dictionary of arrays\n    to support `numpy` operations.\n    \"\"\"\n\n    for key, val in d.items():\n        if type(val) is list:\n            d[key] = np.asarray(val)\n\n    return d\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.daily_sum_over_timesteps","title":"<code>daily_sum_over_timesteps(x: np.ndarray, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>For example, used for transition variable history, which is saved for every timestep, but we generally would like converted to daily totals.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray of shape (N, A, R</code> <p>Array to aggregate -- N is the number of timesteps, A is the number of age groups, R is the number of risk groups.</p> required <code>num_timesteps</code> <code>int</code> <p>Number of timesteps per day. Must divide N (length of <code>x</code>) evenly.</p> required <p>Returns:</p> Type Description <code>np.ndarray of shape (N/n, A, R</code> <p>Array of daily totals, where each block of <code>num_timesteps</code> consecutive timesteps from <code>x</code> has been summed along the first dimension. The first axis now represents days instead of individual timesteps.</p> Source code in <code>CLT_BaseModel/clt_toolkit/utils.py</code> <pre><code>def daily_sum_over_timesteps(x: np.ndarray,\n                             num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    For example, used for transition variable history, which is\n    saved for every timestep, but we generally would like converted to daily totals.\n\n    Params:\n        x (np.ndarray of shape (N, A, R)):\n            Array to aggregate -- N is the number of\n            timesteps, A is the number of age groups,\n            R is the number of risk groups.\n        num_timesteps (int):\n            Number of timesteps per day. Must divide\n            N (length of `x`) evenly.\n\n    Returns:\n        (np.ndarray of shape (N/n, A, R):\n            Array of daily totals, where each block of `num_timesteps`\n            consecutive timesteps from `x` has been summed along the\n            first dimension. The first axis now represents days instead\n            of individual timesteps.\n    \"\"\"\n\n    total_timesteps, A, R = x.shape\n\n    if total_timesteps / num_timesteps != total_timesteps // num_timesteps:\n        raise ValueError(\"x must be shape (N, A, R), where num_timesteps divides N.\")\n\n    num_days = int(total_timesteps/num_timesteps)\n\n    # Pretty sweet hack ;)\n    x = x.reshape(num_days, num_timesteps, A, R)\n\n    # Sum along the number of timesteps\n    return x.sum(axis=1)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.format_current_val_for_sql","title":"<code>format_current_val_for_sql(subpop_model: SubpopModel, state_var_name: str, rep: int) -&gt; list</code>","text":"<p>Processes current_val of given subpop_model's <code>StateVariable</code> specified by <code>state_var_name</code>. Current_val is an A x R numpy array (for age-risk) -- this function \"unpacks\" it into an (A x R, 1) numpy array (a column vector). Converts metadata (subpop_name, state_var_name, <code>rep</code>, and current_simulation_day) into list of A x R rows, where each row has 7 elements, for consistent row formatting for batch SQL insertion.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>SubpopModel to record.</p> required <code>state_var_name</code> <code>str</code> <p>StateVariable name to record.</p> required <code>rep</code> <code>int</code> <p>replication counter to record.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>list</code> <p>list of A x R rows, where each row is a list of 7 elements corresponding to subpop_name, state_var_name, age_group, risk_group, rep, current_simulation_day, and the scalar element of current_val corresponding to that age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def format_current_val_for_sql(subpop_model: SubpopModel,\n                               state_var_name: str,\n                               rep: int) -&gt; list:\n    \"\"\"\n    Processes current_val of given subpop_model's `StateVariable`\n    specified by `state_var_name`. Current_val is an A x R\n    numpy array (for age-risk) -- this function \"unpacks\" it into an\n    (A x R, 1) numpy array (a column vector). Converts metadata\n    (subpop_name, state_var_name, `rep`, and current_simulation_day)\n    into list of A x R rows, where each row has 7 elements, for\n    consistent row formatting for batch SQL insertion.\n\n    Params:\n        subpop_model (SubpopModel):\n            SubpopModel to record.\n        state_var_name (str):\n            StateVariable name to record.\n        rep (int):\n            replication counter to record.\n\n    Returns:\n        data (list):\n            list of A x R rows, where each row is a list of 7 elements\n            corresponding to subpop_name, state_var_name, age_group, risk_group,\n            rep, current_simulation_day, and the scalar element of current_val\n            corresponding to that age-risk group.\n    \"\"\"\n\n    current_val = subpop_model.all_state_variables[state_var_name].current_val\n\n    A, R = np.shape(current_val)\n\n    # numpy's default is row-major / C-style order\n    # This means the elements are unpacked ROW BY ROW\n    current_val_reshaped = current_val.reshape(-1, 1)\n\n    # (AxR, 1) column vector of row indices, indicating the original row in current_val\n    #   before reshaping\n    # Each integer in np.arange(A) repeated R times\n    age_group_indices = np.repeat(np.arange(A), R).reshape(-1, 1)\n\n    # (AxR, 1) column vector of column indices, indicating the original column\n    #   each element belonged to in current_val before reshaping\n    # Repeat np.arange(R) A times\n    risk_group_indices = np.tile(np.arange(R), A).reshape(-1, 1)\n\n    # (subpop_name, state_var_name, age_group, risk_group, rep, timepoint)\n    data = np.column_stack(\n        (np.full((A * R, 1), subpop_model.name),\n         np.full((A * R, 1), state_var_name),\n         age_group_indices,\n         risk_group_indices,\n         np.full((A * R, 1), rep),\n         np.full((A * R, 1), subpop_model.current_simulation_day),\n         current_val_reshaped)).tolist()\n\n    return data\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.get_sql_table_as_df","title":"<code>get_sql_table_as_df(conn: sqlite3.Connection, sql_query: str, sql_query_params: tuple[str] = None, chunk_size: int = int(10000.0)) -&gt; pd.DataFrame</code>","text":"<p>Returns a pandas DataFrame containing data from specified SQL table, retrieved using the provided database connection. Reads in SQL rows in batches of size <code>chunk_size</code> to avoid memory issues for very large tables.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>Connection</code> <p>connection to SQL database.</p> required <code>sql_query</code> <code>str</code> <p>SQL query/statement to execute on database.</p> required <code>sql_query_params</code> <code>tuple[str]</code> <p>tuple of strings to pass as parameters to SQL query -- used to avoid SQL injections.</p> <code>None</code> <code>chunk_size</code> <code>positive int</code> <p>number of rows to read in at a time.</p> <code>int(10000.0)</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing data from specified SQL table,</p> <code>DataFrame</code> <p>or empty DataFrame if table does not exist.</p> Source code in <code>CLT_BaseModel/clt_toolkit/experiments.py</code> <pre><code>def get_sql_table_as_df(conn: sqlite3.Connection,\n                        sql_query: str,\n                        sql_query_params: tuple[str] = None,\n                        chunk_size: int = int(1e4)) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a pandas DataFrame containing data from specified SQL table,\n    retrieved using the provided database connection. Reads in SQL rows\n    in batches of size `chunk_size` to avoid memory issues for very large\n    tables.\n\n    Params:\n        conn (sqlite3.Connection):\n            connection to SQL database.\n        sql_query (str):\n            SQL query/statement to execute on database.\n        sql_query_params (tuple[str]):\n            tuple of strings to pass as parameters to\n            SQL query -- used to avoid SQL injections.\n        chunk_size (positive int):\n            number of rows to read in at a time.\n\n    Returns:\n        DataFrame containing data from specified SQL table,\n        or empty DataFrame if table does not exist.\n    \"\"\"\n\n    chunks = []\n\n    try:\n        for chunk in pd.read_sql_query(sql_query,\n                                       conn,\n                                       chunksize=chunk_size,\n                                       params=sql_query_params):\n            chunks.append(chunk)\n            df = pd.concat(chunks, ignore_index=True)\n\n    # Handle exception gracefully -- print a warning and\n    #   return an empty DataFrame if table given by sql_query\n    #   does not exist\n    except sqlite3.OperationalError as e:\n        if \"no such table\" in str(e).lower():\n            print(f\"Warning: table does not exist for query: {sql_query}. \"\n                  f\"Returning empty DataFrame.\")\n            df = pd.DataFrame()\n\n    return df\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.load_json_augment_dict","title":"<code>load_json_augment_dict(json_filepath: str, d: dict) -&gt; dict</code>","text":"<p>Augments pre-existing dictionary with information from <code>JSON</code> file -- if keys already exist, the previous values are overriden, otherwise the new key-value pairs are added. Lists are automatically converted to numpy arrays for computational compatibility, since <code>JSON</code> does not natively support <code>np.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>json_filepath</code> <code>str</code> <p>Full <code>JSON</code> filepath.</p> required <code>d</code> <code>dict</code> <p>Dictionary to be augmented with new <code>JSON</code> values.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary loaded with <code>JSON</code> information.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def load_json_augment_dict(json_filepath: str,\n                           d: dict) -&gt; dict:\n    \"\"\"\n    Augments pre-existing dictionary with information\n    from `JSON` file -- if keys already exist, the previous values\n    are overriden, otherwise the new key-value pairs are added.\n    Lists are automatically converted to numpy arrays for\n    computational compatibility, since `JSON` does not natively\n    support `np.ndarray`.\n\n    Args:\n        json_filepath (str):\n            Full `JSON` filepath.\n        d (dict):\n            Dictionary to be augmented with new `JSON` values.\n\n    Returns:\n        (dict):\n            Dictionary loaded with `JSON` information.\n    \"\"\"\n\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    data = convert_dict_vals_lists_to_arrays(data)\n\n    for key, val in data.items():\n        d[key] = val\n\n    return d\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.load_json_new_dict","title":"<code>load_json_new_dict(json_filepath: str) -&gt; dict</code>","text":"<p>Loads specified <code>JSON</code> file into new dictionary. Lists are automatically converted to numpy arrays for computational compatibility, since <code>JSON</code> does not natively support <code>np.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>json_filepath</code> <code>str</code> <p>Full <code>JSON</code> filepath.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary loaded with <code>JSON</code> information.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def load_json_new_dict(json_filepath: str) -&gt; dict:\n    \"\"\"\n    Loads specified `JSON` file into new dictionary.\n    Lists are automatically converted to numpy arrays for\n    computational compatibility, since `JSON` does not natively\n    support `np.ndarray`.\n\n    Args:\n        json_filepath (str):\n            Full `JSON` filepath.\n\n    Returns:\n        (dict):\n            Dictionary loaded with `JSON` information.\n    \"\"\"\n\n    # Note: the \"with open\" is important for file handling\n    #   and avoiding resource leaks -- otherwise,\n    #   we have to manually close the file, which is a bit\n    #   more cumbersome\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    # json does not support numpy, so we must convert\n    #   lists to numpy arrays\n    return convert_dict_vals_lists_to_arrays(data)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.make_dataclass_from_dict","title":"<code>make_dataclass_from_dict(dataclass_ref: Type[DataClassProtocol], d: dict) -&gt; DataClassProtocol</code>","text":"<p>Create instance of class dataclass_ref, based on information in dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <code>d</code> <code>dict</code> <p>all keys and values respectively must match name and datatype of dataclass_ref instance attributes.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def make_dataclass_from_dict(dataclass_ref: Type[DataClassProtocol],\n                             d: dict) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in dictionary.\n\n    Args:\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n        d (dict):\n            all keys and values respectively must match name and datatype\n            of dataclass_ref instance attributes.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = convert_dict_vals_lists_to_arrays(d)\n\n    return dataclass_ref(**d)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.make_dataclass_from_json","title":"<code>make_dataclass_from_json(json_filepath: str, dataclass_ref: Type[DataClassProtocol]) -&gt; DataClassProtocol</code>","text":"<p>Create instance of class dataclass_ref, based on information in json_filepath.</p> <p>Parameters:</p> Name Type Description Default <code>json_filepath</code> <code>str</code> <p>path to json file (path includes actual filename with suffix \".json\") -- all json fields must match name and datatype of dataclass_ref instance attributes.</p> required <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def make_dataclass_from_json(json_filepath: str,\n                             dataclass_ref: Type[DataClassProtocol]) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in json_filepath.\n\n    Args:\n        json_filepath (str):\n            path to json file (path includes actual filename\n            with suffix \".json\") -- all json fields must\n            match name and datatype of dataclass_ref instance\n            attributes.\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = load_json_new_dict(json_filepath)\n\n    return make_dataclass_from_dict(dataclass_ref, d)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_TransitionVariable","title":"<code>plot_metapop_TransitionVariable(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the TransitionVariable for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_TransitionVariable(metapop_model: MetapopModel,\n                             axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the TransitionVariable for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_TransitionVariable(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_basic_compartment_history","title":"<code>plot_metapop_basic_compartment_history(metapop_model: MetapopModel, axes: matplotlib.axes.Axes = None)</code>","text":"<p>Plots the compartment data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_basic_compartment_history(metapop_model: MetapopModel,\n                                           axes: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots the compartment data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    # Iterate over subpop models and plot\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_basic_compartment_history(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_decorator","title":"<code>plot_metapop_decorator(plot_func)</code>","text":"<p>Decorator to handle common metapopulation plotting tasks.</p> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>def plot_metapop_decorator(plot_func):\n    \"\"\"\n    Decorator to handle common metapopulation plotting tasks.\n    \"\"\"\n\n    @functools.wraps(plot_func)\n    def wrapper(metapop_model: MetapopModel,\n                savefig_filename = None):\n\n        num_plots = len(metapop_model.subpop_models)\n        num_cols = 2\n        num_rows = (num_plots + num_cols - 1) // num_cols\n\n        # Create figure and axes\n        fig, axes = plt.subplots(num_rows, num_cols, figsize=(5 * num_cols, 4 * num_rows))\n        axes = axes.flatten()\n\n        plot_func(metapop_model=metapop_model, axes=axes)\n\n        # Turn off any unused subplots\n        for j in range(num_plots, len(axes)):\n            fig.delaxes(axes[j])  # Remove empty subplot\n\n        # Adjust layout and save/show the figure\n        plt.tight_layout()\n\n        if savefig_filename:\n            plt.savefig(savefig_filename, dpi=1200)\n\n        plt.show()\n\n    return wrapper\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_epi_metrics","title":"<code>plot_metapop_epi_metrics(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the EpiMetric data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_epi_metrics(metapop_model: MetapopModel,\n                             axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the EpiMetric data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_epi_metrics(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_epi_metrics_justM","title":"<code>plot_metapop_epi_metrics_justM(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the EpiMetric data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_epi_metrics_justM(metapop_model: MetapopModel,\n                             axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the EpiMetric data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_epi_metrics_justM(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_total_infected","title":"<code>plot_metapop_total_infected(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the total infected (IP+IS+IA) data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_total_infected(metapop_model: MetapopModel,\n                                       axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the total infected (IP+IS+IA) data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    # Iterate over subpop models and plot\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_total_infected(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_total_infected_deaths","title":"<code>plot_metapop_total_infected_deaths(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the total infected (IP+IS+IA) and deaths data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_total_infected_deaths(metapop_model: MetapopModel,\n                                       axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the total infected (IP+IS+IA) and deaths data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    # Iterate over subpop models and plot\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_total_infected_deaths(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_TransitionVariable","title":"<code>plot_subpop_TransitionVariable(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots the values for a given transition variable for a subpopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing transition variables.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_TransitionVariable(subpop_model: SubpopModel,\n                     ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots the values for a given transition variable for a subpopulation model.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing transition variables.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n    #transition_history = subpop_model.transition_variables.R_to_S.history_vals_list\n    transition_history = np.array(subpop_model.transition_variables.ISH_to_HR.history_vals_list) + \\\n        np.array(subpop_model.transition_variables.ISH_to_HD.history_vals_list)\n\n    #transition_history is AxR matrix, so need to sum over all entries \n    #total_infected = np.sum(np.asarray(infected_compartments_history), axis=(0, 2, 3))\n    total = [np.sum(age_risk_group_entry)\n                  for age_risk_group_entry\n                  in transition_history]\n\n    # Aggregate to daily values if needed\n    timesteps_per_day = subpop_model.simulation_settings.timesteps_per_day\n    if timesteps_per_day &gt; 1:\n        total = np.array(total).reshape(-1, timesteps_per_day).sum(axis=1)\n\n    #ax.plot(total, label=\"R to S\", alpha=0.6)\n    ax.plot(total, label=\"ISH to HR and HD\", alpha=0.6)\n\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_basic_compartment_history","title":"<code>plot_subpop_basic_compartment_history(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots data for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_basic_compartment_history(subpop_model: SubpopModel,\n                                          ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots data for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    for name, compartment in subpop_model.compartments.items():\n        # Compute summed history values for each age-risk group\n        history_vals_list = [np.sum(age_risk_group_entry) for\n                             age_risk_group_entry in compartment.history_vals_list]\n\n        # Plot data with a label\n        ax.plot(history_vals_list, label=name, alpha=0.6)\n\n    # Set axis title and labels\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_decorator","title":"<code>plot_subpop_decorator(plot_func)</code>","text":"<p>Decorator to handle common subpopulation plotting tasks.</p> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>def plot_subpop_decorator(plot_func):\n    \"\"\"\n    Decorator to handle common subpopulation plotting tasks.\n    \"\"\"\n\n    @functools.wraps(plot_func)\n    def wrapper(subpop_model: SubpopModel,\n                ax: matplotlib.axes.Axes = None,\n                savefig_filename: str = None):\n        \"\"\"\n        Args:\n            subpop_model (SubpopModel):\n                SubpopModel to plot.\n            ax (matplotlib.axes.Axes):\n                Matplotlib axis to plot on.\n            savefig_filename (str):\n                Optional filename to save the figure.\n        \"\"\"\n\n        ax_provided = ax\n\n        # If no axis is provided, create own axis\n        if ax is None:\n            fig, ax = plt.subplots()\n\n        plot_func(subpop_model=subpop_model, ax=ax)\n\n        if savefig_filename:\n            plt.savefig(savefig_filename, dpi=1200)\n\n        if ax_provided is None:\n            plt.show()\n\n    return wrapper\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_epi_metrics","title":"<code>plot_subpop_epi_metrics(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots EpiMetric history for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_epi_metrics(subpop_model: SubpopModel,\n                            ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots EpiMetric history for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    for name, epi_metric in subpop_model.epi_metrics.items():\n\n        # Compute summed history values for each age-risk group\n        history_vals_list = [np.average(age_risk_group_entry) for\n                             age_risk_group_entry in epi_metric.history_vals_list]\n\n        # Plot data with a label\n        ax.plot(history_vals_list, label=name, alpha=0.6)\n\n    # Set axis title and labels\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Epi Metric Value\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_epi_metrics_justM","title":"<code>plot_subpop_epi_metrics_justM(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots EpiMetric history for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_epi_metrics_justM(subpop_model: SubpopModel,\n                            ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots EpiMetric history for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    # Compute summed history values for each age-risk group\n    history_vals_list = [np.average(age_risk_group_entry) for\n                         age_risk_group_entry in subpop_model.epi_metrics.M.history_vals_list]\n\n    # Plot data with a label\n    ax.plot(history_vals_list, label=\"M\", alpha=0.6)\n\n    # Set axis title and labels\n    ax.set_title(f\"M\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Epi Metric Value\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_total_infected","title":"<code>plot_subpop_total_infected(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots data for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_total_infected(subpop_model: SubpopModel,\n                                      ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots data for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    infected_compartment_names = [name for name in subpop_model.compartments.keys() if\n                                  \"I\" in name or \"H\" in name]\n\n    infected_compartments_history = [subpop_model.compartments[compartment_name].history_vals_list\n                                     for compartment_name in infected_compartment_names]\n\n    total_infected = np.sum(np.asarray(infected_compartments_history), axis=(0, 2, 3))\n\n    ax.plot(total_infected, label=\"Total infected\", alpha=0.6)\n\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_total_infected_deaths","title":"<code>plot_subpop_total_infected_deaths(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots data for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_total_infected_deaths(subpop_model: SubpopModel,\n                                      ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots data for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    infected_compartment_names = [name for name in subpop_model.compartments.keys() if\n                                  \"I\" in name or \"H\" in name]\n\n    infected_compartments_history = [subpop_model.compartments[compartment_name].history_vals_list\n                                     for compartment_name in infected_compartment_names]\n\n    total_infected = np.sum(np.asarray(infected_compartments_history), axis=(0, 2, 3))\n\n    ax.plot(total_infected, label=\"Total infected\", alpha=0.6)\n\n    if \"D\" in subpop_model.compartments.keys():\n        deaths = [np.sum(age_risk_group_entry)\n                  for age_risk_group_entry\n                  in subpop_model.compartments.D.history_vals_list]\n\n        ax.plot(deaths, label=\"D\", alpha=0.6)\n\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.sample_uniform_matrix","title":"<code>sample_uniform_matrix(lb: [np.ndarray | float], ub: [np.ndarray | float], RNG: np.random.Generator, A: int, R: int, param_shape: str) -&gt; [np.ndarray | float]</code>","text":"<p>Sample a matrix X of shape (A,R) such that X[a,r] ~ (independent) Uniform(low[a,r], high[a,r]). We assume each element is independent, so we do not assume any correlation structure:</p> <p>Parameters:</p> Name Type Description Default <code>lb</code> <code>np.ndarray of shape (A,) or (A, R) or float</code> <p>Array or scalar of lower bounds</p> required <code>ub</code> <code>np.ndarray of shape (A,) or (A, R) or float</code> <p>Array or scalar of upper bounds</p> required <code>RNG</code> <code>Generator</code> <p>Used to generate Uniform random variables.</p> required <p>Returns:</p> Name Type Description <code>X</code> <code>np.ndarray of shape (A,) or (A, R) or float</code> <p>Random matrix or scalar realization where each element is independently sampled from a Uniform distribution with parameters given element-wise by <code>lb</code> and <code>ub</code> -- <code>X</code> is same shape as <code>lb</code> and <code>ub</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/sampling.py</code> <pre><code>def sample_uniform_matrix(lb: [np.ndarray | float],\n                          ub: [np.ndarray | float],\n                          RNG: np.random.Generator,\n                          A: int,\n                          R: int,\n                          param_shape: str,\n                          ) -&gt; [np.ndarray | float]:\n    \"\"\"\n    Sample a matrix X of shape (A,R) such that\n    X[a,r] ~ (independent) Uniform(low[a,r], high[a,r]).\n    We assume each element is independent, so we do not assume\n    any correlation structure:\n\n    Parameters:\n        lb (np.ndarray of shape (A,) or (A, R) or float):\n            Array or scalar of lower bounds\n        ub (np.ndarray of shape (A,) or (A, R) or float):\n            Array or scalar of upper bounds\n        RNG (np.random.Generator):\n            Used to generate Uniform random variables.\n\n\n    Returns:\n        X (np.ndarray of shape (A,) or (A, R) or float):\n            Random matrix or scalar realization where each\n            element is independently sampled from a Uniform distribution\n            with parameters given element-wise by `lb`\n            and `ub` -- `X` is same shape as `lb` and `ub`.\n    \"\"\"\n\n    # Use linear transformation of Uniform random variable!\n    # Sample standard Uniforms ~[0,1] and apply transformation below\n    #   to get Uniforms ~[low, high] element-wise :)\n\n    if param_shape == \"age\":\n        if (np.shape(lb) != (A,) or\n                np.shape(ub) != (A,)):\n            raise ValueError(\"With dependence on age, lower bounds and \\n\"\n                             \"upper bounds must be arrays of shape (A,). \\n\"\n                             \"Fix inputs and try again.\")\n\n        U = RNG.uniform(size=lb.shape)\n        X = lb + (ub - lb) * U\n    elif param_shape == \"AR\":\n        if (np.shape(lb) != (A, R) or\n                np.shape(ub) != (A, R)):\n            raise ValueError(\"With dependence on age-risk, lower bounds and \\n\"\n                             \"upper bounds must be arrays of shape (A,R). \\n\"\n                             \"Fix inputs and try again.\")\n        U = RNG.uniform(size=lb.shape)\n        X = lb + (ub - lb) * U\n    elif param_shape == \"scalar\":\n        if not np.isscalar(lb) or not np.isscalar(ub):\n            raise ValueError(\"With dependence type scalar, lower bounds and \\n\"\n                             \"upper bounds must be scalars. Fix inputs and try again.\")\n        U = RNG.uniform()\n        X = lb + (ub - lb) * U\n\n    return X\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.sample_uniform_metapop_params","title":"<code>sample_uniform_metapop_params(metapop_model: MetapopModel, sampling_RNG: np.random.Generator, sampling_info: dict[str, dict[str, UniformSamplingSpec]]) -&gt; dict[str, dict[str, np.ndarray]]</code>","text":"<p>Draw parameter realizations from uniform distributions for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>The metapop model whose subpopulation parameters are sampled.</p> required <code>sampling_RNG</code> <code>Generator</code> <p>Random number generator for Uniform sampling.</p> required <code>sampling_info</code> <code>dict[str, dict[str, UniformSamplingSpec]]</code> <p>Nested dictionary with sampling information. - Outer keys:     Either \"all_subpop\" (apply to all subpopulations)     or the name of a subpopulation, matching the <code>name</code>     attribute of a <code>SubpopModel</code> in <code>metapop_model</code>. - Inner keys:     Parameter names corresponding to attributes of the     <code>SubpopParams</code> class associated with the subpop models     in <code>metapop_model</code>. - Values:     <code>UniformSamplingSpec</code> objects defining lower/upper bounds     and shape of the parameter.</p> required <p>Returns:</p> Name Type Description <code>pending_param_updates</code> <code>dict[str, dict[str, ndarray | float]]</code> <p>Nested dictionary of sampled parameter values. - Outer keys: subpop names -- similar to description for     outer keys of <code>sampling_info</code> argument. But unlike <code>sampling_info</code>,     there is no <code>\"all_subpop\"</code> key here -- if a parameter applies to     all subpopulations, the same sampled value appears under each     subpopulation key. - Inner keys: parameter names -- same as description for     inner keys of <code>sampling_info</code> argument. - Values: sampled parameters (scalar, 1D array, or 2D array) according to the shape specified in <code>UniformSamplingSpec.param_shape</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/sampling.py</code> <pre><code>def sample_uniform_metapop_params(metapop_model: MetapopModel,\n                                  sampling_RNG: np.random.Generator,\n                                  sampling_info: dict[str, dict[str, UniformSamplingSpec]]) \\\n        -&gt; dict[str, dict[str, np.ndarray]]:\n    \"\"\"\n    Draw parameter realizations from uniform distributions for a\n    metapopulation model.\n\n    Parameters:\n        metapop_model (MetapopModel):\n            The metapop model whose subpopulation parameters are sampled.\n        sampling_RNG (np.random.Generator):\n            Random number generator for Uniform sampling.\n        sampling_info (dict[str, dict[str, UniformSamplingSpec]]):\n            Nested dictionary with sampling information.\n            - Outer keys:\n                Either \"all_subpop\" (apply to all subpopulations)\n                or the name of a subpopulation, matching the `name`\n                attribute of a `SubpopModel` in `metapop_model`.\n            - Inner keys:\n                Parameter names corresponding to attributes of the\n                `SubpopParams` class associated with the subpop models\n                in `metapop_model`.\n            - Values:\n                `UniformSamplingSpec` objects defining lower/upper bounds\n                and shape of the parameter.\n\n    Returns:\n        pending_param_updates (dict[str, dict[str, np.ndarray | float]]):\n            Nested dictionary of sampled parameter values.\n            - Outer keys: subpop names -- similar to description for\n                outer keys of `sampling_info` argument. But unlike `sampling_info`,\n                there is no `\"all_subpop\"` key here -- if a parameter applies to\n                all subpopulations, the same sampled value appears under each\n                subpopulation key.\n            - Inner keys: parameter names -- same as description for\n                inner keys of `sampling_info` argument.\n            - Values: sampled parameters (scalar, 1D array, or 2D array) according to\n            the shape specified in `UniformSamplingSpec.param_shape`.\n    \"\"\"\n\n    # These dimensions should be the same across subpopulations\n    #   -- so just grab the values from the 1st subpop model\n    num_age_groups = metapop_model._subpop_models_ordered[0].params.num_age_groups\n    num_risk_groups = metapop_model._subpop_models_ordered[0].params.num_risk_groups\n\n    # We do not want to call `updated_dataclass` repeatedly\n    #   when we update a single parameter field for each subpopulation,\n    #   because this creates a NEW instance (since the dataclass\n    #   is frozen and cannot be edited).\n    # Instead, we to call `updated_dataclass` once for each\n    #   subpop model.\n    # So, for each subpop model, we save the parameters that\n    #   need to be changed (to reflect the sampling outcomes)\n    #   in a dictionary, hence the nested dictionaries.\n    pending_param_updates = defaultdict(dict)  # {subpop_id: {param_name: new_value}}\n\n    for subpop_name, params_dict in sampling_info.items():\n\n        for param_name, param_spec in params_dict.items():\n            sample = sample_uniform_matrix(param_spec.lower_bound,\n                                           param_spec.upper_bound,\n                                           sampling_RNG,\n                                           num_age_groups,\n                                           num_risk_groups,\n                                           param_spec.param_shape)\n\n            sample = np.round(sample, param_spec.num_decimals)\n\n        if subpop_name == \"all_subpop\":  # sample is the same across all subpop models\n            for subpop_id in metapop_model.subpop_models.keys():\n                pending_param_updates[subpop_id][param_name] = sample\n        else:\n            pending_param_updates[subpop_name][param_name] = sample\n\n    return pending_param_updates\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.serialize_dataclass","title":"<code>serialize_dataclass(dc) -&gt; dict</code>","text":"<p>Convert a dataclass or dict to a JSON-serializable dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dc</code> <code>obj | dict</code> <p>The object to serialize. - If a dataclass, it will be converted using <code>asdict()</code>. - All numpy arrays are converted to lists. - Scalars (int, float, str, bool) remain unchanged. - Other objects are converted to strings as a fallback.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>dict Dictionary representation of the object, fully JSON-serializable.</p> Source code in <code>CLT_BaseModel/clt_toolkit/utils.py</code> <pre><code>def serialize_dataclass(dc) -&gt; dict:\n    \"\"\"\n    Convert a dataclass or dict to a JSON-serializable dictionary.\n\n    Parameters:\n        dc (obj | dict):\n            The object to serialize.\n            - If a dataclass, it will be converted using `asdict()`.\n            - All numpy arrays are converted to lists.\n            - Scalars (int, float, str, bool) remain unchanged.\n            - Other objects are converted to strings as a fallback.\n\n    Returns:\n        dict\n            Dictionary representation of the object, fully JSON-serializable.\n    \"\"\"\n\n    if is_dataclass(dc):\n        dc = asdict(dc)\n    elif not isinstance(dc, dict):\n        raise TypeError(\"Object must be a dataclass or dict.\")\n\n    return {k: serialize_value(v) for k, v in dc.items()}\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.serialize_value","title":"<code>serialize_value(value)</code>","text":"<p>Convert a value into a JSON-serializable format.</p> <p>value (any):     The value to serialize. Supported types:     - <code>np.ndarray</code> is converted to <code>list</code>     - Scalars and <code>None</code> remain unchanged     - <code>dict</code>, <code>list</code>, or <code>tuple</code> gets recursively serialized         (i.e. in case it's a nested object, etc...)     - Any other type is converted to <code>str</code> as a fallback</p> <p>Returns:</p> Type Description <p>A version of the input that can be safely serialized to JSON.</p> Source code in <code>CLT_BaseModel/clt_toolkit/utils.py</code> <pre><code>def serialize_value(value):\n    \"\"\"\n    Convert a value into a JSON-serializable format.\n\n    Parameters:\n    value (any):\n        The value to serialize. Supported types:\n        - `np.ndarray` is converted to `list`\n        - Scalars and `None` remain unchanged\n        - `dict`, `list`, or `tuple` gets recursively serialized\n            (i.e. in case it's a nested object, etc...)\n        - Any other type is converted to `str` as a fallback\n\n    Returns:\n        A version of the input that can be safely serialized to JSON.\n    \"\"\"\n\n    if isinstance(value, np.ndarray):\n        return value.tolist()\n    elif isinstance(value, (int, float, str, bool)) or value is None:\n        return value\n    elif isinstance(value, dict):\n        return {k: serialize_value(v) for k, v in value.items()}\n    elif isinstance(value, list) or isinstance(value, tuple):\n        return [serialize_value(v) for v in value]\n    else:\n        return str(value)  # fallback for anything else\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.to_AR_array","title":"<code>to_AR_array(x, A, R) -&gt; np.ndarray</code>","text":"<p>Convert scalar, 1D (A,) or 2D (A,R) to a (A,R) array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float | ndarray</code> <p>Float or array to convert to (A, R) array.</p> required <code>A</code> <code>int</code> <p>number of age groups.</p> required <code>R</code> <code>int</code> <p>number of risk groups.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R))</p> Source code in <code>CLT_BaseModel/clt_toolkit/utils.py</code> <pre><code>def to_AR_array(x, A, R) -&gt; np.ndarray:\n    \"\"\"\n    Convert scalar, 1D (A,) or 2D (A,R) to a (A,R) array.\n\n    Params:\n        x (float | np.ndarray):\n            Float or array to convert to (A, R) array.\n        A (int):\n            number of age groups.\n        R (int):\n            number of risk groups.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n    \"\"\"\n\n    arr = np.asarray(x)\n\n    if arr.ndim == 0:  # scalar\n        return np.full((A, R), arr)\n\n    elif arr.ndim == 1:  # shape (A,)\n        if arr.shape[0] != A:\n            raise ValueError(f\"Expected length {A}, got {arr.shape[0]}.\")\n        return np.tile(arr[:, None], (1, R))  # expand to (A,R)\n\n    elif arr.ndim == 2:  # shape (A,R)\n        if arr.shape != (A, R):\n            raise ValueError(f\"Expected shape ({A},{R}), got {arr.shape}.\")\n        return arr\n\n    else:\n        raise ValueError(f\"Unsupported array shape {arr.shape}\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.updated_dataclass","title":"<code>updated_dataclass(original: dataclass, updates: dict) -&gt; object</code>","text":"<p>Return a new dataclass based on <code>original</code>, with fields in <code>updates</code> replaced/added.</p> Source code in <code>CLT_BaseModel/clt_toolkit/utils.py</code> <pre><code>def updated_dataclass(original: dataclass,\n                      updates: dict) -&gt; object:\n\n    \"\"\"\n    Return a new dataclass based on `original`, with fields in `updates` replaced/added.\n    \"\"\"\n\n    return replace(original, **updates)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.updated_dict","title":"<code>updated_dict(original: dict, updates: dict) -&gt; dict</code>","text":"<p>Return a new dictionary based on <code>original</code>, with keys in <code>updates</code> replaced/added.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>dict</code> <p>Original dictionary.</p> required <code>updates</code> <code>dict</code> <p>Dictionary of updates to apply.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>New dictionary with updates applied.</p> Source code in <code>CLT_BaseModel/clt_toolkit/utils.py</code> <pre><code>def updated_dict(original: dict,\n                 updates: dict) -&gt; dict:\n    \"\"\"\n    Return a new dictionary based on `original`, with keys in `updates` replaced/added.\n\n    Parameters:\n        original (dict):\n            Original dictionary.\n        updates (dict):\n            Dictionary of updates to apply.\n\n    Returns:\n        (dict):\n            New dictionary with updates applied.\n    \"\"\"\n\n    return {**original, **updates}\n</code></pre>"},{"location":"flu_components_reference/","title":"Flu Core API Reference","text":"<p>Docstrings and references for <code>flu_core</code> module.</p>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.base_path","title":"<code>base_path = clt.utils.PROJECT_ROOT / 'flu_instances' / 'texas_input_files'</code>  <code>module-attribute</code>","text":""},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AbsoluteHumidity","title":"<code>AbsoluteHumidity</code>","text":"<p>               Bases: <code>Schedule</code></p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class AbsoluteHumidity(clt.Schedule):\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                must have columns \"date\" and \"absolute_humidity\" --\n                \"date\" entries must correspond to consecutive calendar days\n                and must either be strings with `\"YYYY-MM-DD\"` format or\n                `datetime.date` objects -- \"value\" entries correspond to\n                absolute humidity on those days. Identical to\n                `FluSubpopSchedules` field of same name.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self, params, current_date: datetime.date) -&gt; None:\n        self.current_val = self.timeseries_df.loc[\n            self.timeseries_df[\"date\"] == current_date, \"absolute_humidity\"].values[0]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AbsoluteHumidity.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: pd.DataFrame = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>must have columns \"date\" and \"absolute_humidity\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to absolute humidity on those days. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <code>None</code> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: pd.DataFrame = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            must have columns \"date\" and \"absolute_humidity\" --\n            \"date\" entries must correspond to consecutive calendar days\n            and must either be strings with `\"YYYY-MM-DD\"` format or\n            `datetime.date` objects -- \"value\" entries correspond to\n            absolute humidity on those days. Identical to\n            `FluSubpopSchedules` field of same name.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AsympToRecovered","title":"<code>AsympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IA\" to \"R\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class AsympToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IA\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.IA_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AsympToRecovered.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.IA_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.BetaReduce","title":"<code>BetaReduce</code>","text":"<p>               Bases: <code>DynamicVal</code></p> <p>\"Toy\" function representing staged-alert policy     that reduces transmission by 50% when more than 5%     of the total population is infected. Note: the     numbers are completely made up :) The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"     behavior where the staged-alert policy gets triggered     one day and then is off the next, and then is on the     day after, and so on... but as the name suggests,     it IS permanent. TODO: replace with realistic function.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class BetaReduce(clt.DynamicVal):\n    \"\"\"\n    \"Toy\" function representing staged-alert policy\n        that reduces transmission by 50% when more than 5%\n        of the total population is infected. Note: the\n        numbers are completely made up :)\n    The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"\n        behavior where the staged-alert policy gets triggered\n        one day and then is off the next, and then is on the\n        day after, and so on... but as the name suggests,\n        it IS permanent.\n    TODO: replace with realistic function.\n    \"\"\"\n\n    def __init__(self, init_val, is_enabled):\n        super().__init__(init_val, is_enabled)\n        self.permanent_lockdown = False\n\n    def update_current_val(self, state, params):\n        if np.sum(sum([state.ISR, state.ISH])) / np.sum(params.total_pop_age_risk) &gt; 0.05:\n            self.current_val = .5\n            self.permanent_lockdown = True\n        else:\n            if not self.permanent_lockdown:\n                self.current_val = 0.0\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.DailyVaccines","title":"<code>DailyVaccines</code>","text":"<p>               Bases: <code>Schedule</code></p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class DailyVaccines(clt.Schedule):\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n                correspond to consecutive calendar days and must either\n                be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n                objects -- \"value\" entries correspond to historical\n                number vaccinated on those days. Identical to\n                `FluSubpopSchedules` field of same name.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self, params, current_date: datetime.date) -&gt; None:\n        self.current_val = self.timeseries_df.loc[\n            self.timeseries_df[\"date\"] == current_date, \"daily_vaccines\"].values[0]\n\n    def postprocess_data_input(self) -&gt; None:\n        \"\"\"\n            Converts daily_vaccines column from\n            a string representation of a list of lists\n            (each day) of format AxR into np.ndarray. \n        \"\"\"\n\n        self.timeseries_df['daily_vaccines'] = \\\n            self.timeseries_df['daily_vaccines'].apply(json.loads)\n        self.timeseries_df.loc[:, 'daily_vaccines'] = \\\n            self.timeseries_df['daily_vaccines'].apply(\n                lambda x: np.asarray(x)\n                )\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.DailyVaccines.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: pd.DataFrame = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>must have \"date\" and \"daily_vaccines\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to historical number vaccinated on those days. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <code>None</code> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: pd.DataFrame = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n            correspond to consecutive calendar days and must either\n            be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n            objects -- \"value\" entries correspond to historical\n            number vaccinated on those days. Identical to\n            `FluSubpopSchedules` field of same name.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.DailyVaccines.postprocess_data_input","title":"<code>postprocess_data_input() -&gt; None</code>","text":"<p>Converts daily_vaccines column from a string representation of a list of lists (each day) of format AxR into np.ndarray.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def postprocess_data_input(self) -&gt; None:\n    \"\"\"\n        Converts daily_vaccines column from\n        a string representation of a list of lists\n        (each day) of format AxR into np.ndarray. \n    \"\"\"\n\n    self.timeseries_df['daily_vaccines'] = \\\n        self.timeseries_df['daily_vaccines'].apply(json.loads)\n    self.timeseries_df.loc[:, 'daily_vaccines'] = \\\n        self.timeseries_df['daily_vaccines'].apply(\n            lambda x: np.asarray(x)\n            )\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToAsymp","title":"<code>ExposedToAsymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IA\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToAsymp instance forms a TransitionVariableGroup with a corresponding ExposedToPresymp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class ExposedToAsymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IA\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToAsymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToPresymp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToAsymp.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.E_to_I_rate * params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToPresymp","title":"<code>ExposedToPresymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IP\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToPresymp instance forms a TransitionVariableGroup with a corresponding ExposedToAsymp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class ExposedToPresymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IP\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToPresymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToAsymp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * (1 - params.E_to_IA_prop))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToPresymp.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.E_to_I_rate * (1 - params.E_to_IA_prop))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluContactMatrix","title":"<code>FluContactMatrix</code>","text":"<p>               Bases: <code>Schedule</code></p> <p>Flu contact matrix.</p> <p>Attributes:</p> Name Type Description <code>timeseries_df</code> <code>DataFrame</code> <p>must have columns \"date\", \"is_school_day\", and \"is_work_day\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> object and \"is_school_day\" and \"is_work_day\" entries are floats between 0 and 1 indicating if  that date is a school day or work day. Identical to  <code>FluSubpopSchedules</code> field of same name.</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluContactMatrix(clt.Schedule):\n    \"\"\"\n    Flu contact matrix.\n\n    Attributes:\n        timeseries_df (pd.DataFrame):\n            must have columns \"date\", \"is_school_day\", and \"is_work_day\"\n            -- \"date\" entries must correspond to consecutive calendar\n            days and must either be strings with `\"YYYY-MM-DD\"` format\n            or `datetime.date` object and \"is_school_day\" and\n            \"is_work_day\" entries are floats between 0 and 1 indicating if \n            that date is a school day or work day. Identical to \n            `FluSubpopSchedules` field of same name.\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self,\n                           subpop_params: FluSubpopParams,\n                           current_date: datetime.date) -&gt; None:\n\n        df = self.timeseries_df\n\n        try:\n            current_row = df[df[\"date\"] == current_date].iloc[0]\n            self.current_val = subpop_params.total_contact_matrix - \\\n                               (1 - current_row[\"is_school_day\"]) * subpop_params.school_contact_matrix - \\\n                               (1 - current_row[\"is_work_day\"]) * subpop_params.work_contact_matrix\n        except IndexError:\n            # print(f\"Error: {current_date} is not in `timeseries_df`. Using total contact matrix.\")\n            self.current_val = subpop_params.total_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopParamsTensors","title":"<code>FluFullMetapopParamsTensors</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FluTravelParamsTensors</code></p> <p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from parameters on each location/subpopulation model, as well as from the metapopulation's associated <code>FluMixingParams</code> instance). Note that in contrast to <code>FluTravelParamsTensors</code>, ALL fields in <code>FluSubpopParams</code> are included -- this is for running the simulation via torch.</p> <p>Attributes:</p> Name Type Description <code>num_locations</code> <code>(Tensor, 0 - dimensional)</code> <p>number of locations (subpopulations) in the metapopulation model and therefore the travel model.</p> <code>travel_proportions</code> <code>Tensor</code> <p>L x L array, where L is the number of locations or subpopulations, where element i,j corresponds to the proportion of the population in location i who travels to location j (on average).</p> <p>See <code>FluSubpopParams</code> docstring for other attributes. Other fields are analogous except they are size (L, A, R) tensors or size 0 tensors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopParamsTensors(FluTravelParamsTensors):\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays that\n    contain data across all subpopulations (collected from parameters\n    on each location/subpopulation model, as well as from the\n    metapopulation's associated `FluMixingParams` instance).\n    Note that in contrast to `FluTravelParamsTensors`,\n    ALL fields in `FluSubpopParams` are included --\n    this is for running the simulation via torch.\n\n    Attributes:\n        num_locations (torch.Tensor, 0-dimensional):\n            number of locations (subpopulations) in the\n            metapopulation model and therefore the travel\n            model.\n        travel_proportions (torch.Tensor):\n            L x L array, where L is the number of locations\n            or subpopulations, where element i,j corresponds\n            to the proportion of the population in location i\n            who travels to location j (on average).\n\n    See `FluSubpopParams` docstring for other attributes.\n    Other fields are analogous except they are size (L, A, R)\n    tensors or size 0 tensors.\n    \"\"\"\n\n    beta_baseline: Optional[torch.Tensor] = None\n    total_pop_age_risk: Optional[torch.Tensor] = None\n    humidity_impact: Optional[torch.Tensor] = None\n\n    inf_induced_saturation: Optional[torch.Tensor] = None\n    inf_induced_immune_wane: Optional[torch.Tensor] = None\n    vax_induced_saturation: Optional[torch.Tensor] = None\n    vax_induced_immune_wane: Optional[torch.Tensor] = None\n    inf_induced_inf_risk_reduce: Optional[torch.Tensor] = None\n    inf_induced_hosp_risk_reduce: Optional[torch.Tensor] = None\n    inf_induced_death_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_inf_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_hosp_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_death_risk_reduce: Optional[torch.Tensor] = None\n\n    R_to_S_rate: Optional[torch.Tensor] = None\n    E_to_I_rate: Optional[torch.Tensor] = None\n    IP_to_IS_rate: Optional[torch.Tensor] = None\n    ISR_to_R_rate: Optional[float] = None\n    IA_to_R_rate: Optional[float] = None\n    ISH_to_H_rate: Optional[float] = None\n    HR_to_R_rate: Optional[float] = None\n    HD_to_D_rate: Optional[float] = None\n\n    E_to_IA_prop: Optional[torch.Tensor] = None\n    IP_to_ISH_prop: Optional[torch.Tensor] = None\n    ISH_to_HD_prop: Optional[torch.Tensor] = None\n\n    IP_relative_inf: Optional[torch.Tensor] = None\n    IA_relative_inf: Optional[torch.Tensor] = None\n\n    relative_suscept: Optional[torch.Tensor] = None\n    mobility_modifier: Optional[torch.Tensor] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopScheduleTensors","title":"<code>FluFullMetapopScheduleTensors</code>  <code>dataclass</code>","text":"Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopScheduleTensors:\n\n    absolute_humidity: Optional[list[torch.tensor]] = None\n    is_school_day: Optional[list[torch.tensor]] = None\n    is_work_day: Optional[list[torch.tensor]] = None\n    daily_vaccines: Optional[list[torch.tensor]] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopStateTensors","title":"<code>FluFullMetapopStateTensors</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FluTravelStateTensors</code></p> <p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from each location/subpopulation model). In contrast to <code>FluTravelStateTensors</code>, ALL fields in <code>FluSubpopState</code> are included -- this is for running the simulation via torch.</p> <p>Attributes:</p> Name Type Description <code>flu_contact_matrix</code> <code>torch.Tensor of nonnegative integers</code> <p>contact matrix for location-age-risk groups -- the lth element holds current_val of <code>FluContactMatrix</code> <code>Schedule</code> for subpopulation l -- this value is a combination of the total contact matrix, the work contact matrix, and the school contact matrix (and the value is adjusted depending on whether the date is a work or school day)</p> <code>init_vals</code> <code>dict</code> <p>dictionary of torch.Tensor instances, where keys correspond to \"IP\", \"ISR\", \"ISH\" \"IA\", \"HR\", and \"HD\", and values correspond to their initial values for location-age-risk groups.</p> <p>See <code>FluSubpopState</code> and <code>FluTravelStateTensors</code> for other     attributes -- other attributes here correspond to     <code>FluSubpopState</code>, but are size (L, A, R) tensors for     location-age-risk or size 0 tensors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopStateTensors(FluTravelStateTensors):\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays that\n    contain data across all subpopulations (collected from each\n    location/subpopulation model). In contrast to `FluTravelStateTensors`,\n    ALL fields in `FluSubpopState` are included -- this is\n    for running the simulation via torch.\n\n    Attributes:\n        flu_contact_matrix (torch.Tensor of nonnegative integers):\n            contact matrix for location-age-risk groups -- the\n            lth element holds current_val of `FluContactMatrix`\n            `Schedule` for subpopulation l -- this value is a\n            combination of the total contact matrix, the\n            work contact matrix, and the school contact matrix\n            (and the value is adjusted depending on whether\n            the date is a work or school day)\n        init_vals (dict):\n            dictionary of torch.Tensor instances, where keys\n            correspond to \"IP\", \"ISR\", \"ISH\" \"IA\", \"HR\", and \"HD\", and values\n            correspond to their initial values for location-age-risk\n            groups.\n\n    See `FluSubpopState` and `FluTravelStateTensors` for other\n        attributes -- other attributes here correspond to\n        `FluSubpopState`, but are size (L, A, R) tensors for\n        location-age-risk or size 0 tensors.\n    \"\"\"\n\n    # `IP`, `ISR`, `ISH`, `IA`, `HR`, `HD`, `flu_contact_matrix` already in\n    #   parent class\n    # Same with `init_vals`\n\n    S: Optional[torch.Tensor] = None\n    E: Optional[torch.Tensor] = None\n    R: Optional[torch.Tensor] = None\n    D: Optional[torch.Tensor] = None\n\n    M: Optional[torch.Tensor] = None\n    MV: Optional[torch.Tensor] = None\n\n    absolute_humidity: Optional[float] = None\n    daily_vaccines: Optional[torch.Tensor] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel","title":"<code>FluMetapopModel</code>","text":"<p>               Bases: <code>MetapopModel</code>, <code>ABC</code></p> <p>MetapopModel-derived class specific to flu model.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluMetapopModel(clt.MetapopModel, ABC):\n    \"\"\"\n    MetapopModel-derived class specific to flu model.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_models: list[dict],\n                 mixing_params: FluMixingParams,\n                 name: str = \"\"):\n\n        super().__init__(subpop_models,\n                         mixing_params,\n                         name)\n\n        # Confirm validity and consistency of `FluMixingParams`\n        try:\n            num_locations = mixing_params.num_locations\n        except KeyError:\n            raise FluMetapopModelError(\"'mixing_params' must contain the key 'num_locations'. \\n\"\n                                       \"Please specify it before continuing.\")\n        if num_locations != len(subpop_models):\n            raise FluMetapopModelError(\"'num_locations' should equal the number of items in \\n\"\n                                       \"'subpop_models'. Please amend before continuing.\")\n\n        self.travel_state_tensors = FluTravelStateTensors()\n        self.update_travel_state_tensors()\n\n        # `FluMixingParams` info is stored on `FluTravelParamsTensors` --\n        # this order of operations below is important, because\n        # `mixing_params` attribute must be defined before `update_travel_params_tensors()`\n        # is called.\n        self.mixing_params = mixing_params\n        self.travel_params_tensors = FluTravelParamsTensors()\n        self.update_travel_params_tensors()\n\n        total_pop_LAR_tensor = self.compute_total_pop_LAR_tensor()\n\n        self.precomputed = FluPrecomputedTensors(total_pop_LAR_tensor,\n                                                 self.travel_params_tensors)\n\n        # Generally not used unless using torch version\n        self._full_metapop_params_tensors = None\n        self._full_metapop_state_tensors = None\n        self._full_metapop_schedule_tensors = None\n\n    def check_mobility_input(self) -&gt; None:\n        \"\"\"\n        Check that all elements of the mobility matrix are positive,\n        and that rows sum to 1.\n        \"\"\"\n\n        travel_proportions = self.mixing_params.travel_proportions\n        if np.any(travel_proportions &lt; 0):\n            raise FluSubpopModelError(\n                f'All entries of the travel matrix must be non-negative:\\n {travel_proportions}.')\n\n        if not(np.allclose(travel_proportions.sum(axis=1), 1)):\n            raise FluSubpopModelError(\n                f'Rows of the travel matrix must all sum to 1:\\n {travel_proportions}.')\n\n    def run_input_checks(self) -&gt; None:\n        \"\"\"\n        Check the following:\n            - rows of mobility matrix must sum to 1\n            - mobility matrix entries are between 0 and 1\n        \"\"\"\n\n        # Mobility matrix check\n        self.check_mobility_input()\n\n    def modify_subpop_params(self,\n                             subpop_name: str,\n                             updates_dict: dict):\n        \"\"\"\n        This method lets users safely modify a single subpopulation\n        parameters field; the metapopulation-wide tensors are updated\n        automatically afterward.\n\n        In a `FluMetapopModel`, subpopulation parameters are combined into\n        (L, A, R) tensors across L subpopulations.`FluSubpopParams` is a frozen\n        dataclass to avoid users naively changing parameter values and getting\n        undesirable results -- thus, `FluSubpopParams` on a subpopulation\n        model cannot be updated directly.\n\n        Parameters:\n            subpop_name (str):\n               Value must match the `name` attribute of one of the\n               `FluSubpopModel` instances contained in this metapopulation\n                model's `subpop_models` attribute.\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`.\n        \"\"\"\n\n        # Since `FluSubpopParams` is frozen, we return a new instance\n        #   with the reflected updates\n        self.subpop_models[subpop_name].params = clt.updated_dataclass(\n            self.subpop_models[subpop_name].params, updates_dict\n        )\n\n        self.update_travel_params_tensors()\n\n        # Adding this for extra safety in case the user does not\n        # call `get_flu_torch_inputs` for accessing the\n        # `FullMetapopParams` instance.\n\n        # If this attribute is not `None`, it means we are using\n        # the `torch` implementation, and we should update the\n        # corresponding `FullMetapopParams` instance with the new\n        # `FluMixingParams` values.\n        if self._full_metapop_params_tensors:\n            self.update_full_metapop_params_tensors()\n\n    def modify_mixing_params(self,\n                             updates_dict: dict):\n        \"\"\"\n        This method lets users safely modify flu mixing parameters;\n        the metapopulation-wide tensors are updated automatically afterward.\n        `FluMixingParams` is a frozen dataclass to avoid users\n        naively changing parameter values and getting undesirable results --\n        thus, `FluMixingParams` cannot be updated directly.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`. \n        \"\"\"\n\n        self.mixing_params = clt.updated_dataclass(self.mixing_params, updates_dict)\n        self.update_travel_params_tensors()\n\n        nonlocal_travel_prop = self.travel_params_tensors.travel_proportions.clone().fill_diagonal_(0.0)\n\n        self.precomputed.sum_residents_nonlocal_travel_prop = nonlocal_travel_prop.sum(dim=1)\n\n        # Adding this for extra safety in case the user does not\n        # call `get_flu_torch_inputs` for accessing the\n        # `FullMetapopParams` instance.\n\n        # If this attribute is not `None`, it means we are using\n        # the `torch` implementation, and we should update the\n        # corresponding `FullMetapopParams` instance with the new\n        # `FluMixingParams` values.\n        if self._full_metapop_params_tensors:\n            self.update_full_metapop_params_tensors()\n\n    def compute_total_pop_LAR_tensor(self) -&gt; torch.tensor:\n        \"\"\"\n        For each subpopulation, sum initial values of population\n        in each compartment for age-risk groups. Store all information\n        as tensor and return tensor.\n\n        Returns:\n        --------\n        torch.tensor of size (L, A, R):\n            Total population (across all compartments) for\n            location-age-risk (l, a, r).\n        \"\"\"\n\n        # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n        #   to preserve correct index order in tensors!\n        #   See `update_travel_params_tensors` for detailed note.\n        subpop_models_ordered = self._subpop_models_ordered\n\n        total_pop_LAR_tensor = torch.zeros(self.travel_params_tensors.num_locations,\n                                           self.travel_params_tensors.num_age_groups,\n                                           self.travel_params_tensors.num_risk_groups)\n\n        # All subpop models should have the same compartments' keys\n        for name in subpop_models_ordered[0].compartments.keys():\n\n            metapop_vals = []\n\n            for model in subpop_models_ordered.values():\n                compartment = getattr(model.compartments, name)\n                metapop_vals.append(compartment.current_val)\n\n            total_pop_LAR_tensor = total_pop_LAR_tensor + torch.tensor(np.asarray(metapop_vals))\n\n        return total_pop_LAR_tensor\n\n    def update_state_tensors(self,\n                             target: FluTravelStateTensors) -&gt; None:\n        \"\"\"\n        Update `target` instance in-place with current simulation\n        values. Each field of `target` corresponds to a field in\n        `FluSubpopState`, and contains either a tensor of size\n        (L, A, R) or a tensor of size (L), where (l, a, r) refers to\n        location-age-risk.\n        \"\"\"\n\n        # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n        #   to preserve correct index order in tensors!\n        #   See `update_travel_params_tensors` for detailed note.\n        subpop_models_ordered = self._subpop_models_ordered\n\n        for field in fields(target):\n\n            name = field.name\n\n            # FluTravelStateTensors has an attribute\n            #   that is a dictionary called `init_vals` --\n            #   disregard, as this only used to store\n            #   initial values for resetting, but is not\n            #   used in the travel model computation\n            if name == \"init_vals\":\n                continue\n\n            metapop_vals = []\n\n            for model in subpop_models_ordered.values():\n                current_val = getattr(model.state, name)\n                metapop_vals.append(current_val)\n\n            # Probably want to update this to be cleaner...\n            # `SubpopState` fields that correspond to `Schedule` instances\n            # have initial values of `None` -- but we cannot build a tensor\n            # with `None` values, so we convert values to 0s.\n            if any(v is None for v in metapop_vals):\n                setattr(target, name, torch.tensor(np.full(np.shape(metapop_vals), 0.0)))\n            else:\n                setattr(target, name, torch.tensor(np.asarray(metapop_vals)))\n\n            # Only fields corresponding to `Schedule` instances can be\n            # size (L) -- this is because the schedule value may be scalar for\n            # each subpopulation. Other fields should all be size (L, A, R). \n\n    def update_travel_state_tensors(self) -&gt; None:\n        \"\"\"\n        Update `travel_state_tensors` attribute in-place.\n        `FluTravelStateTensors` only has fields corresponding\n        to state variables relevant for the travel model.\n        Converts subpopulation-specific state to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        self.update_state_tensors(self.travel_state_tensors)\n\n    def update_full_metapop_state_tensors(self) -&gt; None:\n        \"\"\"\n        Update `_full_metapop_state_tensors` attribute in-place.\n        `FluFullMetapopStateTensors` has fields corresponding\n        to all state variables in the simulation.\n        Converts subpopulation-specific state to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        if self._full_metapop_state_tensors is None:\n            self._full_metapop_state_tensors = FluFullMetapopStateTensors()\n        self.update_state_tensors(self._full_metapop_state_tensors)\n\n    def update_params_tensors(self,\n                              target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors:\n        \"\"\"\n        Update `target` in-place. Converts subpopulation-specific\n        parameters to tensors of size (L, A, R) for location-age-risk,\n        except for `num_locations` and `travel_proportions`, which\n        have size 1 and (L, L) respectively.\n        \"\"\"\n\n        # USE THE ORDERED DICTIONARY HERE FOR SAFETY!\n        #   AGAIN, ORDER MATTERS BECAUSE ORDER DETERMINES\n        #   THE SUBPOPULATION INDEX IN THE METAPOPULATION\n        #   TENSOR!\n        subpop_models_ordered = self._subpop_models_ordered\n\n        # Subpop models should have the same A, R so grab\n        #   from the first subpop model\n        A = subpop_models_ordered[0].params.num_age_groups\n        R = subpop_models_ordered[0].params.num_risk_groups\n\n        for field in fields(target):\n\n            name = field.name\n\n            metapop_vals = []\n\n            if name == \"num_locations\" or name == \"travel_proportions\":\n                setattr(target, name, torch.tensor(getattr(self.mixing_params, name)))\n\n            else:\n                for model in subpop_models_ordered.values():\n                    metapop_vals.append(getattr(model.params, name))\n\n                # If all values are equal to each other, then\n                #   simply store the first value (since its value is common\n                #   across metapopulations)\n                first_val = metapop_vals[0]\n                if all(np.allclose(x, first_val) for x in metapop_vals):\n                    metapop_vals = first_val\n\n                # Converting list of arrays to tensors is slow --\n                #   better to convert to array first\n                if isinstance(metapop_vals, list):\n                    metapop_vals = np.asarray(metapop_vals)\n                    # metapop_vals = np.stack([clt.to_AR_array(x, A, R) for x in metapop_vals])\n\n                setattr(target, name, torch.tensor(metapop_vals))\n\n        # Convert all tensors to correct size!\n        target.standardize_shapes()\n\n    def update_travel_params_tensors(self) -&gt; None:\n        \"\"\"\n        Update `travel_params_tensors` attribute in-place.\n        `FluTravelParamsTensors` only has fields corresponding\n        to parameters relevant for the travel model.\n        Converts subpopulation-specific parameters to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        self.update_params_tensors(target=self.travel_params_tensors)\n\n    def update_full_metapop_params_tensors(self) -&gt; None:\n        \"\"\"\n        Update `_full_metapop_params_tensors` attribute in-place.\n        `FluFullMetapopParamsTensors` has fields corresponding\n        to all parameters in the simulation. Converts subpopulation-specific\n        parameters to tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        if self._full_metapop_params_tensors is None:\n            self._full_metapop_params_tensors = FluFullMetapopParamsTensors()\n        self.update_params_tensors(target=self._full_metapop_params_tensors)\n\n    def apply_inter_subpop_updates(self) -&gt; None:\n        \"\"\"\n        Update the `FluTravelStateTensors` according to the simulation state\n        and compute the total mixing exposure, which includes across-subpopulation\n        mixing/travel. Update the `total_mixing_exposure` attribute on each\n        subpopulation's `SusceptibleToExposed` instance accordingly, so each\n        of these transition variables can compute its transition rate.\n\n        See `apply_inter_subpop_updates` on `MetapopModel` base class\n        for logic of how/when this is called in the simulation.\n        \"\"\"\n\n        self.update_travel_state_tensors()\n\n        total_mixing_exposure = compute_total_mixing_exposure(self.travel_state_tensors,\n                                                              self.travel_params_tensors,\n                                                              self.precomputed)\n\n        # Again, `self.subpop_models` is an ordered dictionary --\n        #   so iterating over the dictionary like this is well-defined\n        #   and responsible -- the order is important because it\n        #   determines the order (index) in any metapopulation tensors\n        subpop_models = self._subpop_models_ordered\n\n        # Updates `total_mixing_exposure` attribute on each `SusceptibleToExposed`\n        # instance -- this value captures across-population travel/mixing.\n        for i in range(len(subpop_models)):\n            subpop_models.values()[i].transition_variables.S_to_E.total_mixing_exposure = \\\n                total_mixing_exposure[i, :, :]\n\n    def setup_full_metapop_schedule_tensors(self):\n        \"\"\"\n        Creates `FluFullMetapopScheduleTensors` instance and assigns to\n        `_full_metapop_schedule_tensors` attribute.\n\n        For the metapopulation model's L locations/subpopulations, for each day,\n        each value-related column in each schedule is either a float or\n        array of size (A, R) for age-risk groups.\n\n        We aggregate and reformat this schedule information and put it\n        into a `FluFullMetapopScheduleTensors` instance, where fields\n        correspond to a schedule value, and values are lists of tensors of\n        size (L, A, R). The ith element of each list corresponds to the\n        ith simulation day.\n        \"\"\"\n\n        self._full_metapop_schedule_tensors = FluFullMetapopScheduleTensors()\n\n        L = self.precomputed.L\n        A = self.precomputed.A\n        R = self.precomputed.R\n\n        # Note: there is probably a more consistent way to do this,\n        # because now `flu_contact_matrix` has two values: \"is_school_day\"\n        # and \"is_work_day\" -- other schedules' dataframes only have one\n        # relevant column value rather than two\n        for item in [(\"absolute_humidity\", \"absolute_humidity\"),\n                     (\"flu_contact_matrix\", \"is_school_day\"),\n                     (\"flu_contact_matrix\", \"is_work_day\"),\n                     (\"daily_vaccines\", \"daily_vaccines\")]:\n\n            schedule_name = item[0]\n            values_column_name = item[1]\n\n            metapop_vals = []\n\n            for subpop_model in self._subpop_models_ordered.values():\n                df = subpop_model.schedules[schedule_name].timeseries_df\n\n                # Using the `start_real_date` specification given in subpop's `SimulationSettings`,\n                # extract the relevant part of the dataframe with dates &gt;= the simulation start date.\n                # Note that `start_real_date` should be the same for each subpopulation\n                start_date = datetime.datetime.strptime(subpop_model.simulation_settings.start_real_date, \"%Y-%m-%d\")\n                df[\"simulation_day\"] = (pd.to_datetime(df[\"date\"], format=\"%Y-%m-%d\") - start_date).dt.days\n                df = df[df[\"simulation_day\"] &gt;= 0]\n\n                # Make each day's value an A x R array\n                # Pandas complains about `SettingWithCopyWarning` so we work on a copy explicitly to stop it\n                #   from complaining...\n                df = df.copy()\n\n                if schedule_name == 'daily_vaccines':\n                    # Daily vaccines are already given as A x R arrays\n                    if df[values_column_name].values[0].shape != (A, R):\n                        raise ValueError(f\"Error: daily vaccines arrays must have shape ({A}, {R}). \" \\\n                            f\"Current input has shape {df[values_column_name].values[0].shape}.\")\n                else:\n                    df[values_column_name] = df[values_column_name].astype(object)\n                    df.loc[:, values_column_name] = df[values_column_name].apply(\n                        lambda x, A=A, R=R: np.broadcast_to(np.asarray(x).reshape(1, 1), (A, R))\n                    )\n\n                metapop_vals.append(np.asarray(df[values_column_name]))\n\n            # IMPORTANT: tedious array/tensor shape/size manipulation here\n            # metapop_vals: list of L arrays, each shape (num_days, A, R)\n            # We need to transpose this... to be a list of num_days tensors, of size L x A x R\n            num_items = metapop_vals[0].shape[0]\n\n            # This is ugly and inefficient -- but at least we only do this once, when we get the initial\n            #   state of a metapopulation model in tensor form\n            transposed_metapop_vals = [torch.tensor(np.array([metapop_vals[l][i] for l in range(L)])) for i in\n                                       range(num_items)]\n\n            setattr(self._full_metapop_schedule_tensors, values_column_name, transposed_metapop_vals)\n\n    def get_flu_torch_inputs(self) -&gt; dict:\n        \"\"\"\n        Prepares and returns metapopulation simulation data in tensor format\n        that can be directly used for `torch` implementation.\n\n        Returns:\n             d (dict):\n                Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\",\n                and \"precomputed\". Corresponds to `FluFullMetapopStateTensors`,\n                `FluFullMetapopParamsTensors`, `FluFullMetapopScheduleTensors`,\n                and `FluPrecomputedTensors` instances respectively.\n        \"\"\"\n\n        # Note: does not support dynamic variables (yet). If want to\n        #   run pytorch with dynamic variables, will need to create\n        #   a method similar to `setup_full_metapop_schedule_tensors`\n        #   but for dynamic variables. Also note that we cannot differentiate\n        #   with respect to dynamic variables that are discontinuous\n        #   (e.g. a 0-1 intervention) -- so we cannot optimize discontinuous\n        #   dynamic variables.\n\n        self.update_full_metapop_state_tensors()\n        self.update_full_metapop_params_tensors()\n        self._full_metapop_params_tensors.standardize_shapes()\n        self.setup_full_metapop_schedule_tensors()\n\n        d = {}\n\n        d[\"state_tensors\"] = copy.deepcopy(self._full_metapop_state_tensors)\n        d[\"params_tensors\"] = copy.deepcopy(self._full_metapop_params_tensors)\n        d[\"schedule_tensors\"] = copy.deepcopy(self._full_metapop_schedule_tensors)\n        d[\"precomputed\"] = copy.deepcopy(self.precomputed)\n\n        return d\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.apply_inter_subpop_updates","title":"<code>apply_inter_subpop_updates() -&gt; None</code>","text":"<p>Update the <code>FluTravelStateTensors</code> according to the simulation state and compute the total mixing exposure, which includes across-subpopulation mixing/travel. Update the <code>total_mixing_exposure</code> attribute on each subpopulation's <code>SusceptibleToExposed</code> instance accordingly, so each of these transition variables can compute its transition rate.</p> <p>See <code>apply_inter_subpop_updates</code> on <code>MetapopModel</code> base class for logic of how/when this is called in the simulation.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def apply_inter_subpop_updates(self) -&gt; None:\n    \"\"\"\n    Update the `FluTravelStateTensors` according to the simulation state\n    and compute the total mixing exposure, which includes across-subpopulation\n    mixing/travel. Update the `total_mixing_exposure` attribute on each\n    subpopulation's `SusceptibleToExposed` instance accordingly, so each\n    of these transition variables can compute its transition rate.\n\n    See `apply_inter_subpop_updates` on `MetapopModel` base class\n    for logic of how/when this is called in the simulation.\n    \"\"\"\n\n    self.update_travel_state_tensors()\n\n    total_mixing_exposure = compute_total_mixing_exposure(self.travel_state_tensors,\n                                                          self.travel_params_tensors,\n                                                          self.precomputed)\n\n    # Again, `self.subpop_models` is an ordered dictionary --\n    #   so iterating over the dictionary like this is well-defined\n    #   and responsible -- the order is important because it\n    #   determines the order (index) in any metapopulation tensors\n    subpop_models = self._subpop_models_ordered\n\n    # Updates `total_mixing_exposure` attribute on each `SusceptibleToExposed`\n    # instance -- this value captures across-population travel/mixing.\n    for i in range(len(subpop_models)):\n        subpop_models.values()[i].transition_variables.S_to_E.total_mixing_exposure = \\\n            total_mixing_exposure[i, :, :]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.check_mobility_input","title":"<code>check_mobility_input() -&gt; None</code>","text":"<p>Check that all elements of the mobility matrix are positive, and that rows sum to 1.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def check_mobility_input(self) -&gt; None:\n    \"\"\"\n    Check that all elements of the mobility matrix are positive,\n    and that rows sum to 1.\n    \"\"\"\n\n    travel_proportions = self.mixing_params.travel_proportions\n    if np.any(travel_proportions &lt; 0):\n        raise FluSubpopModelError(\n            f'All entries of the travel matrix must be non-negative:\\n {travel_proportions}.')\n\n    if not(np.allclose(travel_proportions.sum(axis=1), 1)):\n        raise FluSubpopModelError(\n            f'Rows of the travel matrix must all sum to 1:\\n {travel_proportions}.')\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.compute_total_pop_LAR_tensor","title":"<code>compute_total_pop_LAR_tensor() -&gt; torch.tensor</code>","text":"<p>For each subpopulation, sum initial values of population in each compartment for age-risk groups. Store all information as tensor and return tensor.</p>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.compute_total_pop_LAR_tensor--returns","title":"Returns:","text":"<p>torch.tensor of size (L, A, R):     Total population (across all compartments) for     location-age-risk (l, a, r).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_total_pop_LAR_tensor(self) -&gt; torch.tensor:\n    \"\"\"\n    For each subpopulation, sum initial values of population\n    in each compartment for age-risk groups. Store all information\n    as tensor and return tensor.\n\n    Returns:\n    --------\n    torch.tensor of size (L, A, R):\n        Total population (across all compartments) for\n        location-age-risk (l, a, r).\n    \"\"\"\n\n    # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n    #   to preserve correct index order in tensors!\n    #   See `update_travel_params_tensors` for detailed note.\n    subpop_models_ordered = self._subpop_models_ordered\n\n    total_pop_LAR_tensor = torch.zeros(self.travel_params_tensors.num_locations,\n                                       self.travel_params_tensors.num_age_groups,\n                                       self.travel_params_tensors.num_risk_groups)\n\n    # All subpop models should have the same compartments' keys\n    for name in subpop_models_ordered[0].compartments.keys():\n\n        metapop_vals = []\n\n        for model in subpop_models_ordered.values():\n            compartment = getattr(model.compartments, name)\n            metapop_vals.append(compartment.current_val)\n\n        total_pop_LAR_tensor = total_pop_LAR_tensor + torch.tensor(np.asarray(metapop_vals))\n\n    return total_pop_LAR_tensor\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.get_flu_torch_inputs","title":"<code>get_flu_torch_inputs() -&gt; dict</code>","text":"<p>Prepares and returns metapopulation simulation data in tensor format that can be directly used for <code>torch</code> implementation.</p> <p>Returns:</p> Name Type Description <code>d</code> <code>dict</code> <p>Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\", and \"precomputed\". Corresponds to <code>FluFullMetapopStateTensors</code>, <code>FluFullMetapopParamsTensors</code>, <code>FluFullMetapopScheduleTensors</code>, and <code>FluPrecomputedTensors</code> instances respectively.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_flu_torch_inputs(self) -&gt; dict:\n    \"\"\"\n    Prepares and returns metapopulation simulation data in tensor format\n    that can be directly used for `torch` implementation.\n\n    Returns:\n         d (dict):\n            Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\",\n            and \"precomputed\". Corresponds to `FluFullMetapopStateTensors`,\n            `FluFullMetapopParamsTensors`, `FluFullMetapopScheduleTensors`,\n            and `FluPrecomputedTensors` instances respectively.\n    \"\"\"\n\n    # Note: does not support dynamic variables (yet). If want to\n    #   run pytorch with dynamic variables, will need to create\n    #   a method similar to `setup_full_metapop_schedule_tensors`\n    #   but for dynamic variables. Also note that we cannot differentiate\n    #   with respect to dynamic variables that are discontinuous\n    #   (e.g. a 0-1 intervention) -- so we cannot optimize discontinuous\n    #   dynamic variables.\n\n    self.update_full_metapop_state_tensors()\n    self.update_full_metapop_params_tensors()\n    self._full_metapop_params_tensors.standardize_shapes()\n    self.setup_full_metapop_schedule_tensors()\n\n    d = {}\n\n    d[\"state_tensors\"] = copy.deepcopy(self._full_metapop_state_tensors)\n    d[\"params_tensors\"] = copy.deepcopy(self._full_metapop_params_tensors)\n    d[\"schedule_tensors\"] = copy.deepcopy(self._full_metapop_schedule_tensors)\n    d[\"precomputed\"] = copy.deepcopy(self.precomputed)\n\n    return d\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.modify_mixing_params","title":"<code>modify_mixing_params(updates_dict: dict)</code>","text":"<p>This method lets users safely modify flu mixing parameters; the metapopulation-wide tensors are updated automatically afterward. <code>FluMixingParams</code> is a frozen dataclass to avoid users naively changing parameter values and getting undesirable results -- thus, <code>FluMixingParams</code> cannot be updated directly.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_mixing_params(self,\n                         updates_dict: dict):\n    \"\"\"\n    This method lets users safely modify flu mixing parameters;\n    the metapopulation-wide tensors are updated automatically afterward.\n    `FluMixingParams` is a frozen dataclass to avoid users\n    naively changing parameter values and getting undesirable results --\n    thus, `FluMixingParams` cannot be updated directly.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`. \n    \"\"\"\n\n    self.mixing_params = clt.updated_dataclass(self.mixing_params, updates_dict)\n    self.update_travel_params_tensors()\n\n    nonlocal_travel_prop = self.travel_params_tensors.travel_proportions.clone().fill_diagonal_(0.0)\n\n    self.precomputed.sum_residents_nonlocal_travel_prop = nonlocal_travel_prop.sum(dim=1)\n\n    # Adding this for extra safety in case the user does not\n    # call `get_flu_torch_inputs` for accessing the\n    # `FullMetapopParams` instance.\n\n    # If this attribute is not `None`, it means we are using\n    # the `torch` implementation, and we should update the\n    # corresponding `FullMetapopParams` instance with the new\n    # `FluMixingParams` values.\n    if self._full_metapop_params_tensors:\n        self.update_full_metapop_params_tensors()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.modify_subpop_params","title":"<code>modify_subpop_params(subpop_name: str, updates_dict: dict)</code>","text":"<p>This method lets users safely modify a single subpopulation parameters field; the metapopulation-wide tensors are updated automatically afterward.</p> <p>In a <code>FluMetapopModel</code>, subpopulation parameters are combined into (L, A, R) tensors across L subpopulations.<code>FluSubpopParams</code> is a frozen dataclass to avoid users naively changing parameter values and getting undesirable results -- thus, <code>FluSubpopParams</code> on a subpopulation model cannot be updated directly.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_name</code> <code>str</code> <p>Value must match the <code>name</code> attribute of one of the <code>FluSubpopModel</code> instances contained in this metapopulation model's <code>subpop_models</code> attribute.</p> required <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_subpop_params(self,\n                         subpop_name: str,\n                         updates_dict: dict):\n    \"\"\"\n    This method lets users safely modify a single subpopulation\n    parameters field; the metapopulation-wide tensors are updated\n    automatically afterward.\n\n    In a `FluMetapopModel`, subpopulation parameters are combined into\n    (L, A, R) tensors across L subpopulations.`FluSubpopParams` is a frozen\n    dataclass to avoid users naively changing parameter values and getting\n    undesirable results -- thus, `FluSubpopParams` on a subpopulation\n    model cannot be updated directly.\n\n    Parameters:\n        subpop_name (str):\n           Value must match the `name` attribute of one of the\n           `FluSubpopModel` instances contained in this metapopulation\n            model's `subpop_models` attribute.\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`.\n    \"\"\"\n\n    # Since `FluSubpopParams` is frozen, we return a new instance\n    #   with the reflected updates\n    self.subpop_models[subpop_name].params = clt.updated_dataclass(\n        self.subpop_models[subpop_name].params, updates_dict\n    )\n\n    self.update_travel_params_tensors()\n\n    # Adding this for extra safety in case the user does not\n    # call `get_flu_torch_inputs` for accessing the\n    # `FullMetapopParams` instance.\n\n    # If this attribute is not `None`, it means we are using\n    # the `torch` implementation, and we should update the\n    # corresponding `FullMetapopParams` instance with the new\n    # `FluMixingParams` values.\n    if self._full_metapop_params_tensors:\n        self.update_full_metapop_params_tensors()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.run_input_checks","title":"<code>run_input_checks() -&gt; None</code>","text":"Check the following <ul> <li>rows of mobility matrix must sum to 1</li> <li>mobility matrix entries are between 0 and 1</li> </ul> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def run_input_checks(self) -&gt; None:\n    \"\"\"\n    Check the following:\n        - rows of mobility matrix must sum to 1\n        - mobility matrix entries are between 0 and 1\n    \"\"\"\n\n    # Mobility matrix check\n    self.check_mobility_input()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.setup_full_metapop_schedule_tensors","title":"<code>setup_full_metapop_schedule_tensors()</code>","text":"<p>Creates <code>FluFullMetapopScheduleTensors</code> instance and assigns to <code>_full_metapop_schedule_tensors</code> attribute.</p> <p>For the metapopulation model's L locations/subpopulations, for each day, each value-related column in each schedule is either a float or array of size (A, R) for age-risk groups.</p> <p>We aggregate and reformat this schedule information and put it into a <code>FluFullMetapopScheduleTensors</code> instance, where fields correspond to a schedule value, and values are lists of tensors of size (L, A, R). The ith element of each list corresponds to the ith simulation day.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def setup_full_metapop_schedule_tensors(self):\n    \"\"\"\n    Creates `FluFullMetapopScheduleTensors` instance and assigns to\n    `_full_metapop_schedule_tensors` attribute.\n\n    For the metapopulation model's L locations/subpopulations, for each day,\n    each value-related column in each schedule is either a float or\n    array of size (A, R) for age-risk groups.\n\n    We aggregate and reformat this schedule information and put it\n    into a `FluFullMetapopScheduleTensors` instance, where fields\n    correspond to a schedule value, and values are lists of tensors of\n    size (L, A, R). The ith element of each list corresponds to the\n    ith simulation day.\n    \"\"\"\n\n    self._full_metapop_schedule_tensors = FluFullMetapopScheduleTensors()\n\n    L = self.precomputed.L\n    A = self.precomputed.A\n    R = self.precomputed.R\n\n    # Note: there is probably a more consistent way to do this,\n    # because now `flu_contact_matrix` has two values: \"is_school_day\"\n    # and \"is_work_day\" -- other schedules' dataframes only have one\n    # relevant column value rather than two\n    for item in [(\"absolute_humidity\", \"absolute_humidity\"),\n                 (\"flu_contact_matrix\", \"is_school_day\"),\n                 (\"flu_contact_matrix\", \"is_work_day\"),\n                 (\"daily_vaccines\", \"daily_vaccines\")]:\n\n        schedule_name = item[0]\n        values_column_name = item[1]\n\n        metapop_vals = []\n\n        for subpop_model in self._subpop_models_ordered.values():\n            df = subpop_model.schedules[schedule_name].timeseries_df\n\n            # Using the `start_real_date` specification given in subpop's `SimulationSettings`,\n            # extract the relevant part of the dataframe with dates &gt;= the simulation start date.\n            # Note that `start_real_date` should be the same for each subpopulation\n            start_date = datetime.datetime.strptime(subpop_model.simulation_settings.start_real_date, \"%Y-%m-%d\")\n            df[\"simulation_day\"] = (pd.to_datetime(df[\"date\"], format=\"%Y-%m-%d\") - start_date).dt.days\n            df = df[df[\"simulation_day\"] &gt;= 0]\n\n            # Make each day's value an A x R array\n            # Pandas complains about `SettingWithCopyWarning` so we work on a copy explicitly to stop it\n            #   from complaining...\n            df = df.copy()\n\n            if schedule_name == 'daily_vaccines':\n                # Daily vaccines are already given as A x R arrays\n                if df[values_column_name].values[0].shape != (A, R):\n                    raise ValueError(f\"Error: daily vaccines arrays must have shape ({A}, {R}). \" \\\n                        f\"Current input has shape {df[values_column_name].values[0].shape}.\")\n            else:\n                df[values_column_name] = df[values_column_name].astype(object)\n                df.loc[:, values_column_name] = df[values_column_name].apply(\n                    lambda x, A=A, R=R: np.broadcast_to(np.asarray(x).reshape(1, 1), (A, R))\n                )\n\n            metapop_vals.append(np.asarray(df[values_column_name]))\n\n        # IMPORTANT: tedious array/tensor shape/size manipulation here\n        # metapop_vals: list of L arrays, each shape (num_days, A, R)\n        # We need to transpose this... to be a list of num_days tensors, of size L x A x R\n        num_items = metapop_vals[0].shape[0]\n\n        # This is ugly and inefficient -- but at least we only do this once, when we get the initial\n        #   state of a metapopulation model in tensor form\n        transposed_metapop_vals = [torch.tensor(np.array([metapop_vals[l][i] for l in range(L)])) for i in\n                                   range(num_items)]\n\n        setattr(self._full_metapop_schedule_tensors, values_column_name, transposed_metapop_vals)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_full_metapop_params_tensors","title":"<code>update_full_metapop_params_tensors() -&gt; None</code>","text":"<p>Update <code>_full_metapop_params_tensors</code> attribute in-place. <code>FluFullMetapopParamsTensors</code> has fields corresponding to all parameters in the simulation. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_full_metapop_params_tensors(self) -&gt; None:\n    \"\"\"\n    Update `_full_metapop_params_tensors` attribute in-place.\n    `FluFullMetapopParamsTensors` has fields corresponding\n    to all parameters in the simulation. Converts subpopulation-specific\n    parameters to tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    if self._full_metapop_params_tensors is None:\n        self._full_metapop_params_tensors = FluFullMetapopParamsTensors()\n    self.update_params_tensors(target=self._full_metapop_params_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_full_metapop_state_tensors","title":"<code>update_full_metapop_state_tensors() -&gt; None</code>","text":"<p>Update <code>_full_metapop_state_tensors</code> attribute in-place. <code>FluFullMetapopStateTensors</code> has fields corresponding to all state variables in the simulation. Converts subpopulation-specific state to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_full_metapop_state_tensors(self) -&gt; None:\n    \"\"\"\n    Update `_full_metapop_state_tensors` attribute in-place.\n    `FluFullMetapopStateTensors` has fields corresponding\n    to all state variables in the simulation.\n    Converts subpopulation-specific state to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    if self._full_metapop_state_tensors is None:\n        self._full_metapop_state_tensors = FluFullMetapopStateTensors()\n    self.update_state_tensors(self._full_metapop_state_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_params_tensors","title":"<code>update_params_tensors(target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors</code>","text":"<p>Update <code>target</code> in-place. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk, except for <code>num_locations</code> and <code>travel_proportions</code>, which have size 1 and (L, L) respectively.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_params_tensors(self,\n                          target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors:\n    \"\"\"\n    Update `target` in-place. Converts subpopulation-specific\n    parameters to tensors of size (L, A, R) for location-age-risk,\n    except for `num_locations` and `travel_proportions`, which\n    have size 1 and (L, L) respectively.\n    \"\"\"\n\n    # USE THE ORDERED DICTIONARY HERE FOR SAFETY!\n    #   AGAIN, ORDER MATTERS BECAUSE ORDER DETERMINES\n    #   THE SUBPOPULATION INDEX IN THE METAPOPULATION\n    #   TENSOR!\n    subpop_models_ordered = self._subpop_models_ordered\n\n    # Subpop models should have the same A, R so grab\n    #   from the first subpop model\n    A = subpop_models_ordered[0].params.num_age_groups\n    R = subpop_models_ordered[0].params.num_risk_groups\n\n    for field in fields(target):\n\n        name = field.name\n\n        metapop_vals = []\n\n        if name == \"num_locations\" or name == \"travel_proportions\":\n            setattr(target, name, torch.tensor(getattr(self.mixing_params, name)))\n\n        else:\n            for model in subpop_models_ordered.values():\n                metapop_vals.append(getattr(model.params, name))\n\n            # If all values are equal to each other, then\n            #   simply store the first value (since its value is common\n            #   across metapopulations)\n            first_val = metapop_vals[0]\n            if all(np.allclose(x, first_val) for x in metapop_vals):\n                metapop_vals = first_val\n\n            # Converting list of arrays to tensors is slow --\n            #   better to convert to array first\n            if isinstance(metapop_vals, list):\n                metapop_vals = np.asarray(metapop_vals)\n                # metapop_vals = np.stack([clt.to_AR_array(x, A, R) for x in metapop_vals])\n\n            setattr(target, name, torch.tensor(metapop_vals))\n\n    # Convert all tensors to correct size!\n    target.standardize_shapes()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_state_tensors","title":"<code>update_state_tensors(target: FluTravelStateTensors) -&gt; None</code>","text":"<p>Update <code>target</code> instance in-place with current simulation values. Each field of <code>target</code> corresponds to a field in <code>FluSubpopState</code>, and contains either a tensor of size (L, A, R) or a tensor of size (L), where (l, a, r) refers to location-age-risk.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_state_tensors(self,\n                         target: FluTravelStateTensors) -&gt; None:\n    \"\"\"\n    Update `target` instance in-place with current simulation\n    values. Each field of `target` corresponds to a field in\n    `FluSubpopState`, and contains either a tensor of size\n    (L, A, R) or a tensor of size (L), where (l, a, r) refers to\n    location-age-risk.\n    \"\"\"\n\n    # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n    #   to preserve correct index order in tensors!\n    #   See `update_travel_params_tensors` for detailed note.\n    subpop_models_ordered = self._subpop_models_ordered\n\n    for field in fields(target):\n\n        name = field.name\n\n        # FluTravelStateTensors has an attribute\n        #   that is a dictionary called `init_vals` --\n        #   disregard, as this only used to store\n        #   initial values for resetting, but is not\n        #   used in the travel model computation\n        if name == \"init_vals\":\n            continue\n\n        metapop_vals = []\n\n        for model in subpop_models_ordered.values():\n            current_val = getattr(model.state, name)\n            metapop_vals.append(current_val)\n\n        # Probably want to update this to be cleaner...\n        # `SubpopState` fields that correspond to `Schedule` instances\n        # have initial values of `None` -- but we cannot build a tensor\n        # with `None` values, so we convert values to 0s.\n        if any(v is None for v in metapop_vals):\n            setattr(target, name, torch.tensor(np.full(np.shape(metapop_vals), 0.0)))\n        else:\n            setattr(target, name, torch.tensor(np.asarray(metapop_vals)))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_travel_params_tensors","title":"<code>update_travel_params_tensors() -&gt; None</code>","text":"<p>Update <code>travel_params_tensors</code> attribute in-place. <code>FluTravelParamsTensors</code> only has fields corresponding to parameters relevant for the travel model. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_travel_params_tensors(self) -&gt; None:\n    \"\"\"\n    Update `travel_params_tensors` attribute in-place.\n    `FluTravelParamsTensors` only has fields corresponding\n    to parameters relevant for the travel model.\n    Converts subpopulation-specific parameters to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    self.update_params_tensors(target=self.travel_params_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_travel_state_tensors","title":"<code>update_travel_state_tensors() -&gt; None</code>","text":"<p>Update <code>travel_state_tensors</code> attribute in-place. <code>FluTravelStateTensors</code> only has fields corresponding to state variables relevant for the travel model. Converts subpopulation-specific state to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_travel_state_tensors(self) -&gt; None:\n    \"\"\"\n    Update `travel_state_tensors` attribute in-place.\n    `FluTravelStateTensors` only has fields corresponding\n    to state variables relevant for the travel model.\n    Converts subpopulation-specific state to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    self.update_state_tensors(self.travel_state_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModelError","title":"<code>FluMetapopModelError</code>","text":"<p>               Bases: <code>MetapopModelError</code></p> <p>Custom exceptions for flu metapopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluMetapopModelError(clt.MetapopModelError):\n    \"\"\"Custom exceptions for flu metapopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMixingParams","title":"<code>FluMixingParams</code>  <code>dataclass</code>","text":"<p>Contains parameters corresponding to inter-subpopulation (metapopulation model) specifications: the number of subpopulations included, and the travel proportions between them.</p> <p>Parameters:</p> Name Type Description Default <code>num_locations</code> <code>int</code> <p>Number of locations (subpopulations) in the metapopulation model.</p> required <code>travel_proportions</code> <code>np.ndarray of shape (A, R</code> <p>L x L array of floats in [0,1], where L is the number of locations (subpopulations), and the i-jth element is the proportion of people in subpopulation i that travel to subpopulation j.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass FluMixingParams:\n    \"\"\"\n    Contains parameters corresponding to inter-subpopulation\n    (metapopulation model) specifications: the number of\n    subpopulations included, and the travel proportions between them.\n\n    Params:\n        num_locations (int):\n            Number of locations (subpopulations) in the\n            metapopulation model.\n        travel_proportions (np.ndarray of shape (A, R)):\n            L x L array of floats in [0,1], where L is the number\n            of locations (subpopulations), and the i-jth element\n            is the proportion of people in subpopulation i that\n            travel to subpopulation j.\n    \"\"\"\n\n    num_locations: Optional[int]\n    travel_proportions: Optional[np.ndarray]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluPrecomputedTensors","title":"<code>FluPrecomputedTensors</code>","text":"<p>Stores precomputed quantities that are repeatedly used, for computational efficiency.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>class FluPrecomputedTensors:\n    \"\"\"\n    Stores precomputed quantities that are repeatedly\n    used, for computational efficiency.\n    \"\"\"\n\n    def __init__(self,\n                 total_pop_LAR_tensor: torch.Tensor,\n                 params: FluTravelParamsTensors) -&gt; None:\n\n        self.total_pop_LAR_tensor = total_pop_LAR_tensor\n\n        self.L = int(params.num_locations.item())\n        self.A = int(params.num_age_groups.item())\n        self.R = int(params.num_risk_groups.item())\n\n        self.total_pop_LA = torch.sum(self.total_pop_LAR_tensor, dim=2)\n\n        # Remove the diagonal!\n        self.nonlocal_travel_prop = params.travel_proportions.clone().fill_diagonal_(0.0)\n\n        # We don't need einsum for residents traveling\n        #   -- Dave and Remy helped me check this\n        # \\sum_{k \\not = \\ell} v^{\\ell \\rightarrow k}\n        # Note we already have k \\not = \\ell because we set the diagonal of\n        #   nonlocal_travel_prop to 0\n        self.sum_residents_nonlocal_travel_prop = self.nonlocal_travel_prop.sum(dim=1)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel","title":"<code>FluSubpopModel</code>","text":"<p>               Bases: <code>SubpopModel</code></p> <p>Class for creating ImmunoSEIRS flu model with predetermined fixed structure -- initial values and epidemiological structure are populated by user-specified <code>JSON</code> files.</p> <p>Key method create_transmission_model returns a <code>SubpopModel</code> instance with S-E-I-H-R-D compartments and M and MV epi metrics.</p> The update structure is as follows <ul> <li>S &lt;- S + R_to_S - S_to_E</li> <li>E &lt;- E + S_to_E - E_to_IP - E_to_IA</li> <li>IA &lt;- IA + E_to_IA - IA_to_R </li> <li>IP &lt;- IP + E_to_IP - IP_to_ISR - IP_to_ISH</li> <li>ISR &lt;- ISR + IP_to_ISR - ISR_to_R</li> <li>ISH &lt;- ISH + IP_to_ISH - ISH_to_HR - ISH_to_HD</li> <li>HR &lt;- HR + ISH_to_HR - HR_to_R</li> <li>HD &lt;- HD + ISH_to_HD - HD_to_D</li> <li>R &lt;- R + ISR_to_R + HR_to_R - R_to_S</li> <li>D &lt;- D + HD_to_D</li> </ul> The following are TransitionVariable instances <ul> <li>R_to_S is a RecoveredToSusceptible instance</li> <li>S_to_E is a SusceptibleToExposed instance</li> <li>IP_to_ISR is a PresympToSympRecover instance</li> <li>IP_to_ISH is a PresympToSympHospital instance</li> <li>ISH_to_HR is a SympHospitalToHospRecover instance</li> <li>ISH_to_HD is a SympHospitalToHospDead instance</li> <li>ISR_to_R is a SympRecoverToRecovered instance</li> <li>HR_to_R is a HospRecoverToRecovered instance </li> <li>HD_to_D is a HospDeadToDead instance</li> </ul> There are three TransitionVariableGroups <ul> <li>E_out (handles E_to_IP and E_to_IA)</li> <li>IP_out (handles IP_to_ISR and IP_to_ISH)</li> <li>ISH_out (handles ISH_to_HR and ISH_to_HD)</li> </ul> The following are EpiMetric instances <ul> <li>M is a InfInducedImmunity instance</li> <li>MV is a VaxInducedImmunity instance</li> </ul> <p>Transition rates and update formulas are specified in corresponding classes.</p> <p>See parent class <code>SubpopModel</code>'s docstring for additional attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluSubpopModel(clt.SubpopModel):\n    \"\"\"\n    Class for creating ImmunoSEIRS flu model with predetermined fixed\n    structure -- initial values and epidemiological structure are\n    populated by user-specified `JSON` files.\n\n    Key method create_transmission_model returns a `SubpopModel`\n    instance with S-E-I-H-R-D compartments and M\n    and MV epi metrics.\n\n    The update structure is as follows:\n        - S &lt;- S + R_to_S - S_to_E\n        - E &lt;- E + S_to_E - E_to_IP - E_to_IA\n        - IA &lt;- IA + E_to_IA - IA_to_R \n        - IP &lt;- IP + E_to_IP - IP_to_ISR - IP_to_ISH\n        - ISR &lt;- ISR + IP_to_ISR - ISR_to_R\n        - ISH &lt;- ISH + IP_to_ISH - ISH_to_HR - ISH_to_HD\n        - HR &lt;- HR + ISH_to_HR - HR_to_R\n        - HD &lt;- HD + ISH_to_HD - HD_to_D\n        - R &lt;- R + ISR_to_R + HR_to_R - R_to_S\n        - D &lt;- D + HD_to_D\n\n    The following are TransitionVariable instances:\n        - R_to_S is a RecoveredToSusceptible instance\n        - S_to_E is a SusceptibleToExposed instance\n        - IP_to_ISR is a PresympToSympRecover instance\n        - IP_to_ISH is a PresympToSympHospital instance\n        - ISH_to_HR is a SympHospitalToHospRecover instance\n        - ISH_to_HD is a SympHospitalToHospDead instance\n        - ISR_to_R is a SympRecoverToRecovered instance\n        - HR_to_R is a HospRecoverToRecovered instance \n        - HD_to_D is a HospDeadToDead instance\n\n    There are three TransitionVariableGroups:\n        - E_out (handles E_to_IP and E_to_IA)\n        - IP_out (handles IP_to_ISR and IP_to_ISH)\n        - ISH_out (handles ISH_to_HR and ISH_to_HD)\n\n    The following are EpiMetric instances:\n        - M is a InfInducedImmunity instance\n        - MV is a VaxInducedImmunity instance\n\n    Transition rates and update formulas are specified in\n    corresponding classes.\n\n    See parent class `SubpopModel`'s docstring for additional attributes.\n    \"\"\"\n\n    def __init__(self,\n                 state: FluSubpopState,\n                 params: FluSubpopParams,\n                 simulation_settings: FluSubpopSchedules,\n                 RNG: np.random.Generator,\n                 schedules_spec: FluSubpopSchedules,\n                 name: str):\n        \"\"\"\n        Args:\n            state (FluSubpopState):\n                holds current simulation state information,\n                such as current values of epidemiological compartments\n                and epi metrics.\n            params (FluSubpopParams):\n                holds epidemiological parameter values.\n            simulation_settings (SimulationSettings):\n                holds simulation settings.\n            RNG (np.random.Generator):\n                numpy random generator object used to obtain\n                random numbers.\n            schedules_spec (FluSubpopSchedules):\n                holds dataframes that specify `Schedule` instances.\n            name (str):\n                unique name of MetapopModel instance.\n        \"\"\"\n\n        self.schedules_spec = schedules_spec\n\n        # IMPORTANT NOTE: as always, we must be careful with mutable objects\n        # and generally use deep copies to avoid modification of the same\n        # object. But in this function call, using deep copies is unnecessary\n        # (redundant) because the parent class `SubpopModel`'s `__init__`\n        # creates deep copies.\n        super().__init__(state, params, simulation_settings, RNG, name)\n\n    def check_humidity_input(self) -&gt; None:\n        \"\"\"\n        Check that absolute humidity values are non-negative.\n        \"\"\"\n\n        humidity_values = self.schedules['absolute_humidity'].timeseries_df['absolute_humidity'].values\n        if np.any(humidity_values &lt; 0):\n            raise FluSubpopModelError(\"Error: absolute humidity values must be non-negative.\")\n\n    def check_vaccination_input(self) -&gt; None:\n        \"\"\"\n        Check that vaccination values are positive.\n        If vaccinations exceed 100% over a year, issue a warning.\n        \"\"\"\n\n        df_vaccine = self.schedules['daily_vaccines'].timeseries_df.copy()\n\n        ## Check all entries are positive\n        all_positive = all([\n            (x &gt;= 0).all() for x in df_vaccine['daily_vaccines'].values\n            ])\n        if not(all_positive):\n            raise FluSubpopModelError(\"Error: vaccination values must be non-negative.\")\n\n        ## Check cumulative vaccination never exceeds 100% over 365 days\n        df_vaccine['datetime'] = pd.to_datetime(df_vaccine['date'])\n        df_vaccine.set_index('datetime', inplace=True)\n\n        # Ensure there is one row per day within time range\n        full_date_range = pd.date_range(start=df_vaccine.index.min(), end=df_vaccine.index.max(), freq='D')\n        df_vaccine = df_vaccine.reindex(full_date_range)\n\n        # Replace NAs due to reindexing (if any)\n        na_rows = df_vaccine['daily_vaccines'].isna()\n        value_shape = df_vaccine['daily_vaccines'].values[0].shape\n        df_vaccine.loc[na_rows, 'daily_vaccines'] = \\\n            pd.Series(\n                [np.zeros(value_shape)] * na_rows.sum(), \n                index=df_vaccine.loc[na_rows].index\n                )\n\n        # Calculate rolling 1-year sum of vaccination rates\n        window_size_days = min(365, len(df_vaccine))\n\n        data_windows = np.lib.stride_tricks.sliding_window_view(\n            df_vaccine['daily_vaccines'].values, \n            window_size_days\n            )\n        vaccines_rolling_sum = np.sum(data_windows, axis=-1)\n\n        # Check whether any cumulative vaccinations exceed 100%\n        max_values_above_one = [x.max() &gt; 1 for x in vaccines_rolling_sum]\n\n        # Find first index rolling sum exceeds 100% for some age group (if there is one)\n        if sum(max_values_above_one) &gt; 0:\n            first_exceeds_idx = max_values_above_one.index(True)\n\n            vaccines_cml_exceeds = vaccines_rolling_sum[first_exceeds_idx]\n            exceeds_first_date = df_vaccine['date'].values[first_exceeds_idx + window_size_days - 1]\n\n            msg = 'Cumulative vaccination over a 365-day period exceeds 100% on (at least) ' +\\\n                f'the following date: {exceeds_first_date}. Cumulative vaccination by that date is \\n' +\\\n                str(vaccines_cml_exceeds)\n            warnings.warn(msg)\n\n    def check_calendar_variables_input(self) -&gt; None:\n        \"\"\"\n        Check school and calendar variables in flu_contact_matrix\n        schedule are between 0 and 1\n        \"\"\"\n\n        flu_contact_matrix = self.schedules['flu_contact_matrix'].timeseries_df\n\n        for variable in ['is_school_day', 'is_work_day']:\n            values = flu_contact_matrix[variable].values\n\n            if (values.min() &lt; 0) or (values.max() &gt; 1):\n                msg = f'Error: {variable} values must be between 0 and 1.'\n                raise FluSubpopModelError(msg)\n\n    def check_contact_matrix_input(self) -&gt; None:\n        \"\"\"\n        Check contact matrix entries are non-negative.\n        Check total contact is greater than the sum of the\n        school and work matrices.\n        \"\"\"   \n\n        if not(np.all(self.params.total_contact_matrix &gt;= 0)):\n            raise FluSubpopModelError(\n                'Some entries of the total contact matrix are negative \\n'+\\\n                f'{self.params.total_contact_matrix}'\n                )\n\n        if not(np.all(self.params.school_contact_matrix &gt;= 0)):\n            raise FluSubpopModelError(\n                'Some entries of the school contact matrix are negative \\n'+\\\n                f'{self.params.school_contact_matrix}'\n                )\n\n        if not(np.all(self.params.work_contact_matrix &gt;= 0)):\n            raise FluSubpopModelError(\n                'Some entries of the work contact matrix are negative \\n'+\\\n                f'{self.params.work_contact_matrix}'\n                )\n\n        if not(np.all((\n            self.params.total_contact_matrix - self.params.school_contact_matrix - \n            self.params.work_contact_matrix) &gt;= 0)):\n            raise FluSubpopModelError(\n                'The total contact matrix must be at least greater than the sum of ' +\\\n                'the work and school contact matrices.'\n            )\n\n    def check_rate_input(self) -&gt; None:\n        \"\"\"\n        Ensure all rate values are strictly positive, and other\n        variables (waning, saturation, reductions) are non-negative.\n        \"\"\"\n\n        p = self.params\n        rates_list = [\n            p.R_to_S_rate, p.E_to_I_rate, p.IP_to_IS_rate, p.ISH_to_H_rate,\n            p.ISR_to_R_rate, p.IA_to_R_rate, p.HR_to_R_rate, p.HD_to_D_rate,\n            p.E_to_IA_prop]\n\n        other_params_list = [\n            p.humidity_impact, p.inf_induced_saturation, p.inf_induced_immune_wane,\n            p.vax_induced_saturation, p.vax_induced_immune_wane, p.inf_induced_inf_risk_reduce,\n            p.inf_induced_hosp_risk_reduce, p.inf_induced_death_risk_reduce, \n            p.vax_induced_inf_risk_reduce, p.vax_induced_hosp_risk_reduce,\n            p.vax_induced_death_risk_reduce, p.IP_relative_inf,\n            p.IA_relative_inf, p.relative_suscept,\n            p.ISH_to_HD_prop, p.IP_to_ISH_prop, p.beta_baseline\n        ]\n\n        for value in rates_list:\n            if not(np.all(value &gt; 0)):\n                raise FluSubpopModelError('All transition rates must be strictly positive values.')\n\n        for value in other_params_list:\n            if not(np.all(value &gt;= 0)):\n                raise FluSubpopModelError('Some parameter values are negative.')\n\n    def check_initial_compartment_input(self) -&gt; None:\n        \"\"\"\n        Ensure all initial compartment and saturation values are non-negative.\n        \"\"\"\n\n        compartments_list = [\"S\", \"E\", \"IP\", \"ISR\", \"ISH\", \"IA\", \"HR\", \"HD\", \"R\", \"D\"]\n        immunity_values_list = [\"M\", \"MV\"]\n\n        for state_name in compartments_list + immunity_values_list:\n            if not(np.all(getattr(self.state, state_name) &gt;= 0)):\n                raise FluSubpopModelError(\n                    'Initial compartment and immunity values must be non-negative. ' +\\\n                    f'{state_name} is negative: {getattr(self.state, state_name)} for subpopulation ' +\\\n                    f'{self.name}.'\n                )\n\n    def run_input_checks(self) -&gt; None:\n        \"\"\"\n        Check the following:\n            - if total vaccinations exceed 100% over a year we issue a warning\n            - school and work calendar variables must be between 0 and 1\n            - absolute humidity values, contact matrix entries, daily vaccination\n              must be non-negative\n            - total contact matrix must be greater than the sum of the school\n              and work contact matrices\n            - all rate values must be strictly positive\n            - initial compartmental values must be non-negative\n        \"\"\"\n\n        self.check_humidity_input()\n        self.check_vaccination_input()\n        self.check_calendar_variables_input()\n        self.check_contact_matrix_input()\n        self.check_rate_input()\n        self.check_initial_compartment_input()\n\n    def create_compartments(self) -&gt; sc.objdict[str, clt.Compartment]:\n\n        # Create `Compartment` instances S-E-IA-IP-IS-H-R-D (7 compartments total)\n        # Save instances in `sc.objdict` and return objdict\n\n        compartments = sc.objdict()\n\n        for name in (\"S\", \"E\", \"IP\", \"ISR\", \"ISH\", \"IA\", \"HR\", \"HD\", \"R\", \"D\"):\n            compartments[name] = clt.Compartment(getattr(self.state, name))\n\n        return compartments\n\n    def create_dynamic_vals(self) -&gt; sc.objdict[str, clt.DynamicVal]:\n        \"\"\"\n        Create all `DynamicVal` instances, save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        dynamic_vals = sc.objdict()\n\n        dynamic_vals[\"beta_reduce\"] = BetaReduce(init_val=0.0,\n                                                 is_enabled=False)\n\n        return dynamic_vals\n\n    def create_schedules(self) -&gt; sc.objdict[str, clt.Schedule]:\n        \"\"\"\n        Create all `Schedule` instances, save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        schedules = sc.objdict()\n\n        schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n        schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n        schedules[\"daily_vaccines\"] = DailyVaccines()\n\n        for field, df in asdict(self.schedules_spec).items():\n\n            try:\n                df[\"date\"] = pd.to_datetime(df[\"date\"], format='%Y-%m-%d').dt.date\n            except ValueError as e:\n                raise ValueError(\"Error: dates should be strings in YYYY-MM-DD format or \"\n                                 \"`date.datetime` objects.\") from e\n\n            schedules[field].timeseries_df = df\n            schedules[field].postprocess_data_input()\n\n        return schedules\n\n    def create_transition_variables(self) -&gt; sc.objdict[str, clt.TransitionVariable]:\n        \"\"\"\n        Create all `TransitionVariable` instances,\n        save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        # NOTE: see the parent class `SubpopModel`'s `__init__` --\n        # `create_transition_variables` is called after\n        # `simulation_settings` is assigned\n\n        transition_type = self.simulation_settings.transition_type\n\n        transition_variables = sc.objdict()\n\n        S = self.compartments.S\n        E = self.compartments.E\n        IP = self.compartments.IP\n        ISR = self.compartments.ISR\n        ISH = self.compartments.ISH\n        IA = self.compartments.IA\n        HR = self.compartments.HR\n        HD = self.compartments.HD\n        R = self.compartments.R\n        D = self.compartments.D\n\n        transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n        transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n        transition_variables.IP_to_ISR = PresympToSympRecover(IP, ISR, transition_type, True)\n        transition_variables.IP_to_ISH = PresympToSympHospital(IP, ISH, transition_type, True)\n        transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n        transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n        transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n        transition_variables.ISR_to_R = SympRecoverToRecovered(ISR, R, transition_type)\n        transition_variables.ISH_to_HR = SympHospitalToHospRecover(ISH, HR, transition_type, True)\n        transition_variables.ISH_to_HD = SympHospitalToHospDead(ISH, HD, transition_type, True)\n        transition_variables.HR_to_R = HospRecoverToRecovered(HR, R, transition_type)\n        transition_variables.HD_to_D = HospDeadToDead(HD, D, transition_type)\n\n        return transition_variables\n\n    def create_transition_variable_groups(self) -&gt; sc.objdict[str, clt.TransitionVariableGroup]:\n        \"\"\"\n        Create all transition variable groups described in docstring (3 transition\n        variable groups total), save in `sc.objdict`, return objdict\n        \"\"\"\n\n        # Shortcuts for attribute access\n        # NOTE: see the parent class `SubpopModel`'s `__init__` --\n        # `create_transition_variable_groups` is called after\n        # `simulation_settings` is assigned\n\n        transition_type = self.simulation_settings.transition_type\n\n        transition_variable_groups = sc.objdict()\n\n        transition_variable_groups.E_out = clt.TransitionVariableGroup(self.compartments.E,\n                                                                       transition_type,\n                                                                       (self.transition_variables.E_to_IP,\n                                                                        self.transition_variables.E_to_IA))\n\n        transition_variable_groups.IP_out = clt.TransitionVariableGroup(self.compartments.IP,\n                                                                        transition_type,\n                                                                        (self.transition_variables.IP_to_ISR,\n                                                                         self.transition_variables.IP_to_ISH))\n\n        transition_variable_groups.ISH_out = clt.TransitionVariableGroup(self.compartments.ISH,\n                                                                         transition_type,\n                                                                         (self.transition_variables.ISH_to_HR,\n                                                                          self.transition_variables.ISH_to_HD))\n\n        return transition_variable_groups\n\n    def create_epi_metrics(self) -&gt; sc.objdict[str, clt.EpiMetric]:\n        \"\"\"\n        Create all epi metric described in docstring (2 state\n        variables total), save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        epi_metrics = sc.objdict()\n\n        epi_metrics.M = \\\n            InfInducedImmunity(getattr(self.state, \"M\"),\n                               self.transition_variables.R_to_S)\n\n        epi_metrics.MV = \\\n            VaxInducedImmunity(getattr(self.state, \"MV\"))\n\n        return epi_metrics\n\n    def modify_subpop_params(self,\n                             updates_dict: dict):\n        \"\"\"\n        This method lets users safely modify a single subpopulation\n        parameters field; if this subpop model is associated with\n        a metapop model, the metapopulation-wide tensors are updated\n        automatically afterward. See also `modify_subpop_params` method on\n        `FluMetapopModel`.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`.\n        \"\"\"\n\n        # If associated with metapop model, run this method\n        #   on the metapop model itself to handle metapopulation-wide\n        #   tensor updating\n        if self.metapop_model:\n            self.metapop_model.modify_subpop_params(self.name,\n                                                    updates_dict)\n        else:\n            # Since `SubpopParams` is frozen, we return a new instance\n            #   with the reflected updates\n            self.params = clt.updated_dataclass(self.params, updates_dict)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.__init__","title":"<code>__init__(state: FluSubpopState, params: FluSubpopParams, simulation_settings: FluSubpopSchedules, RNG: np.random.Generator, schedules_spec: FluSubpopSchedules, name: str)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>FluSubpopState</code> <p>holds current simulation state information, such as current values of epidemiological compartments and epi metrics.</p> required <code>params</code> <code>FluSubpopParams</code> <p>holds epidemiological parameter values.</p> required <code>simulation_settings</code> <code>SimulationSettings</code> <p>holds simulation settings.</p> required <code>RNG</code> <code>Generator</code> <p>numpy random generator object used to obtain random numbers.</p> required <code>schedules_spec</code> <code>FluSubpopSchedules</code> <p>holds dataframes that specify <code>Schedule</code> instances.</p> required <code>name</code> <code>str</code> <p>unique name of MetapopModel instance.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             state: FluSubpopState,\n             params: FluSubpopParams,\n             simulation_settings: FluSubpopSchedules,\n             RNG: np.random.Generator,\n             schedules_spec: FluSubpopSchedules,\n             name: str):\n    \"\"\"\n    Args:\n        state (FluSubpopState):\n            holds current simulation state information,\n            such as current values of epidemiological compartments\n            and epi metrics.\n        params (FluSubpopParams):\n            holds epidemiological parameter values.\n        simulation_settings (SimulationSettings):\n            holds simulation settings.\n        RNG (np.random.Generator):\n            numpy random generator object used to obtain\n            random numbers.\n        schedules_spec (FluSubpopSchedules):\n            holds dataframes that specify `Schedule` instances.\n        name (str):\n            unique name of MetapopModel instance.\n    \"\"\"\n\n    self.schedules_spec = schedules_spec\n\n    # IMPORTANT NOTE: as always, we must be careful with mutable objects\n    # and generally use deep copies to avoid modification of the same\n    # object. But in this function call, using deep copies is unnecessary\n    # (redundant) because the parent class `SubpopModel`'s `__init__`\n    # creates deep copies.\n    super().__init__(state, params, simulation_settings, RNG, name)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.check_calendar_variables_input","title":"<code>check_calendar_variables_input() -&gt; None</code>","text":"<p>Check school and calendar variables in flu_contact_matrix schedule are between 0 and 1</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def check_calendar_variables_input(self) -&gt; None:\n    \"\"\"\n    Check school and calendar variables in flu_contact_matrix\n    schedule are between 0 and 1\n    \"\"\"\n\n    flu_contact_matrix = self.schedules['flu_contact_matrix'].timeseries_df\n\n    for variable in ['is_school_day', 'is_work_day']:\n        values = flu_contact_matrix[variable].values\n\n        if (values.min() &lt; 0) or (values.max() &gt; 1):\n            msg = f'Error: {variable} values must be between 0 and 1.'\n            raise FluSubpopModelError(msg)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.check_contact_matrix_input","title":"<code>check_contact_matrix_input() -&gt; None</code>","text":"<p>Check contact matrix entries are non-negative. Check total contact is greater than the sum of the school and work matrices.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def check_contact_matrix_input(self) -&gt; None:\n    \"\"\"\n    Check contact matrix entries are non-negative.\n    Check total contact is greater than the sum of the\n    school and work matrices.\n    \"\"\"   \n\n    if not(np.all(self.params.total_contact_matrix &gt;= 0)):\n        raise FluSubpopModelError(\n            'Some entries of the total contact matrix are negative \\n'+\\\n            f'{self.params.total_contact_matrix}'\n            )\n\n    if not(np.all(self.params.school_contact_matrix &gt;= 0)):\n        raise FluSubpopModelError(\n            'Some entries of the school contact matrix are negative \\n'+\\\n            f'{self.params.school_contact_matrix}'\n            )\n\n    if not(np.all(self.params.work_contact_matrix &gt;= 0)):\n        raise FluSubpopModelError(\n            'Some entries of the work contact matrix are negative \\n'+\\\n            f'{self.params.work_contact_matrix}'\n            )\n\n    if not(np.all((\n        self.params.total_contact_matrix - self.params.school_contact_matrix - \n        self.params.work_contact_matrix) &gt;= 0)):\n        raise FluSubpopModelError(\n            'The total contact matrix must be at least greater than the sum of ' +\\\n            'the work and school contact matrices.'\n        )\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.check_humidity_input","title":"<code>check_humidity_input() -&gt; None</code>","text":"<p>Check that absolute humidity values are non-negative.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def check_humidity_input(self) -&gt; None:\n    \"\"\"\n    Check that absolute humidity values are non-negative.\n    \"\"\"\n\n    humidity_values = self.schedules['absolute_humidity'].timeseries_df['absolute_humidity'].values\n    if np.any(humidity_values &lt; 0):\n        raise FluSubpopModelError(\"Error: absolute humidity values must be non-negative.\")\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.check_initial_compartment_input","title":"<code>check_initial_compartment_input() -&gt; None</code>","text":"<p>Ensure all initial compartment and saturation values are non-negative.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def check_initial_compartment_input(self) -&gt; None:\n    \"\"\"\n    Ensure all initial compartment and saturation values are non-negative.\n    \"\"\"\n\n    compartments_list = [\"S\", \"E\", \"IP\", \"ISR\", \"ISH\", \"IA\", \"HR\", \"HD\", \"R\", \"D\"]\n    immunity_values_list = [\"M\", \"MV\"]\n\n    for state_name in compartments_list + immunity_values_list:\n        if not(np.all(getattr(self.state, state_name) &gt;= 0)):\n            raise FluSubpopModelError(\n                'Initial compartment and immunity values must be non-negative. ' +\\\n                f'{state_name} is negative: {getattr(self.state, state_name)} for subpopulation ' +\\\n                f'{self.name}.'\n            )\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.check_rate_input","title":"<code>check_rate_input() -&gt; None</code>","text":"<p>Ensure all rate values are strictly positive, and other variables (waning, saturation, reductions) are non-negative.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def check_rate_input(self) -&gt; None:\n    \"\"\"\n    Ensure all rate values are strictly positive, and other\n    variables (waning, saturation, reductions) are non-negative.\n    \"\"\"\n\n    p = self.params\n    rates_list = [\n        p.R_to_S_rate, p.E_to_I_rate, p.IP_to_IS_rate, p.ISH_to_H_rate,\n        p.ISR_to_R_rate, p.IA_to_R_rate, p.HR_to_R_rate, p.HD_to_D_rate,\n        p.E_to_IA_prop]\n\n    other_params_list = [\n        p.humidity_impact, p.inf_induced_saturation, p.inf_induced_immune_wane,\n        p.vax_induced_saturation, p.vax_induced_immune_wane, p.inf_induced_inf_risk_reduce,\n        p.inf_induced_hosp_risk_reduce, p.inf_induced_death_risk_reduce, \n        p.vax_induced_inf_risk_reduce, p.vax_induced_hosp_risk_reduce,\n        p.vax_induced_death_risk_reduce, p.IP_relative_inf,\n        p.IA_relative_inf, p.relative_suscept,\n        p.ISH_to_HD_prop, p.IP_to_ISH_prop, p.beta_baseline\n    ]\n\n    for value in rates_list:\n        if not(np.all(value &gt; 0)):\n            raise FluSubpopModelError('All transition rates must be strictly positive values.')\n\n    for value in other_params_list:\n        if not(np.all(value &gt;= 0)):\n            raise FluSubpopModelError('Some parameter values are negative.')\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.check_vaccination_input","title":"<code>check_vaccination_input() -&gt; None</code>","text":"<p>Check that vaccination values are positive. If vaccinations exceed 100% over a year, issue a warning.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def check_vaccination_input(self) -&gt; None:\n    \"\"\"\n    Check that vaccination values are positive.\n    If vaccinations exceed 100% over a year, issue a warning.\n    \"\"\"\n\n    df_vaccine = self.schedules['daily_vaccines'].timeseries_df.copy()\n\n    ## Check all entries are positive\n    all_positive = all([\n        (x &gt;= 0).all() for x in df_vaccine['daily_vaccines'].values\n        ])\n    if not(all_positive):\n        raise FluSubpopModelError(\"Error: vaccination values must be non-negative.\")\n\n    ## Check cumulative vaccination never exceeds 100% over 365 days\n    df_vaccine['datetime'] = pd.to_datetime(df_vaccine['date'])\n    df_vaccine.set_index('datetime', inplace=True)\n\n    # Ensure there is one row per day within time range\n    full_date_range = pd.date_range(start=df_vaccine.index.min(), end=df_vaccine.index.max(), freq='D')\n    df_vaccine = df_vaccine.reindex(full_date_range)\n\n    # Replace NAs due to reindexing (if any)\n    na_rows = df_vaccine['daily_vaccines'].isna()\n    value_shape = df_vaccine['daily_vaccines'].values[0].shape\n    df_vaccine.loc[na_rows, 'daily_vaccines'] = \\\n        pd.Series(\n            [np.zeros(value_shape)] * na_rows.sum(), \n            index=df_vaccine.loc[na_rows].index\n            )\n\n    # Calculate rolling 1-year sum of vaccination rates\n    window_size_days = min(365, len(df_vaccine))\n\n    data_windows = np.lib.stride_tricks.sliding_window_view(\n        df_vaccine['daily_vaccines'].values, \n        window_size_days\n        )\n    vaccines_rolling_sum = np.sum(data_windows, axis=-1)\n\n    # Check whether any cumulative vaccinations exceed 100%\n    max_values_above_one = [x.max() &gt; 1 for x in vaccines_rolling_sum]\n\n    # Find first index rolling sum exceeds 100% for some age group (if there is one)\n    if sum(max_values_above_one) &gt; 0:\n        first_exceeds_idx = max_values_above_one.index(True)\n\n        vaccines_cml_exceeds = vaccines_rolling_sum[first_exceeds_idx]\n        exceeds_first_date = df_vaccine['date'].values[first_exceeds_idx + window_size_days - 1]\n\n        msg = 'Cumulative vaccination over a 365-day period exceeds 100% on (at least) ' +\\\n            f'the following date: {exceeds_first_date}. Cumulative vaccination by that date is \\n' +\\\n            str(vaccines_cml_exceeds)\n        warnings.warn(msg)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_dynamic_vals","title":"<code>create_dynamic_vals() -&gt; sc.objdict[str, clt.DynamicVal]</code>","text":"<p>Create all <code>DynamicVal</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_dynamic_vals(self) -&gt; sc.objdict[str, clt.DynamicVal]:\n    \"\"\"\n    Create all `DynamicVal` instances, save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    dynamic_vals = sc.objdict()\n\n    dynamic_vals[\"beta_reduce\"] = BetaReduce(init_val=0.0,\n                                             is_enabled=False)\n\n    return dynamic_vals\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_epi_metrics","title":"<code>create_epi_metrics() -&gt; sc.objdict[str, clt.EpiMetric]</code>","text":"<p>Create all epi metric described in docstring (2 state variables total), save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_epi_metrics(self) -&gt; sc.objdict[str, clt.EpiMetric]:\n    \"\"\"\n    Create all epi metric described in docstring (2 state\n    variables total), save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    epi_metrics = sc.objdict()\n\n    epi_metrics.M = \\\n        InfInducedImmunity(getattr(self.state, \"M\"),\n                           self.transition_variables.R_to_S)\n\n    epi_metrics.MV = \\\n        VaxInducedImmunity(getattr(self.state, \"MV\"))\n\n    return epi_metrics\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_schedules","title":"<code>create_schedules() -&gt; sc.objdict[str, clt.Schedule]</code>","text":"<p>Create all <code>Schedule</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_schedules(self) -&gt; sc.objdict[str, clt.Schedule]:\n    \"\"\"\n    Create all `Schedule` instances, save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    schedules = sc.objdict()\n\n    schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n    schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n    schedules[\"daily_vaccines\"] = DailyVaccines()\n\n    for field, df in asdict(self.schedules_spec).items():\n\n        try:\n            df[\"date\"] = pd.to_datetime(df[\"date\"], format='%Y-%m-%d').dt.date\n        except ValueError as e:\n            raise ValueError(\"Error: dates should be strings in YYYY-MM-DD format or \"\n                             \"`date.datetime` objects.\") from e\n\n        schedules[field].timeseries_df = df\n        schedules[field].postprocess_data_input()\n\n    return schedules\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_transition_variable_groups","title":"<code>create_transition_variable_groups() -&gt; sc.objdict[str, clt.TransitionVariableGroup]</code>","text":"<p>Create all transition variable groups described in docstring (3 transition variable groups total), save in <code>sc.objdict</code>, return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_transition_variable_groups(self) -&gt; sc.objdict[str, clt.TransitionVariableGroup]:\n    \"\"\"\n    Create all transition variable groups described in docstring (3 transition\n    variable groups total), save in `sc.objdict`, return objdict\n    \"\"\"\n\n    # Shortcuts for attribute access\n    # NOTE: see the parent class `SubpopModel`'s `__init__` --\n    # `create_transition_variable_groups` is called after\n    # `simulation_settings` is assigned\n\n    transition_type = self.simulation_settings.transition_type\n\n    transition_variable_groups = sc.objdict()\n\n    transition_variable_groups.E_out = clt.TransitionVariableGroup(self.compartments.E,\n                                                                   transition_type,\n                                                                   (self.transition_variables.E_to_IP,\n                                                                    self.transition_variables.E_to_IA))\n\n    transition_variable_groups.IP_out = clt.TransitionVariableGroup(self.compartments.IP,\n                                                                    transition_type,\n                                                                    (self.transition_variables.IP_to_ISR,\n                                                                     self.transition_variables.IP_to_ISH))\n\n    transition_variable_groups.ISH_out = clt.TransitionVariableGroup(self.compartments.ISH,\n                                                                     transition_type,\n                                                                     (self.transition_variables.ISH_to_HR,\n                                                                      self.transition_variables.ISH_to_HD))\n\n    return transition_variable_groups\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_transition_variables","title":"<code>create_transition_variables() -&gt; sc.objdict[str, clt.TransitionVariable]</code>","text":"<p>Create all <code>TransitionVariable</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_transition_variables(self) -&gt; sc.objdict[str, clt.TransitionVariable]:\n    \"\"\"\n    Create all `TransitionVariable` instances,\n    save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    # NOTE: see the parent class `SubpopModel`'s `__init__` --\n    # `create_transition_variables` is called after\n    # `simulation_settings` is assigned\n\n    transition_type = self.simulation_settings.transition_type\n\n    transition_variables = sc.objdict()\n\n    S = self.compartments.S\n    E = self.compartments.E\n    IP = self.compartments.IP\n    ISR = self.compartments.ISR\n    ISH = self.compartments.ISH\n    IA = self.compartments.IA\n    HR = self.compartments.HR\n    HD = self.compartments.HD\n    R = self.compartments.R\n    D = self.compartments.D\n\n    transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n    transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n    transition_variables.IP_to_ISR = PresympToSympRecover(IP, ISR, transition_type, True)\n    transition_variables.IP_to_ISH = PresympToSympHospital(IP, ISH, transition_type, True)\n    transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n    transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n    transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n    transition_variables.ISR_to_R = SympRecoverToRecovered(ISR, R, transition_type)\n    transition_variables.ISH_to_HR = SympHospitalToHospRecover(ISH, HR, transition_type, True)\n    transition_variables.ISH_to_HD = SympHospitalToHospDead(ISH, HD, transition_type, True)\n    transition_variables.HR_to_R = HospRecoverToRecovered(HR, R, transition_type)\n    transition_variables.HD_to_D = HospDeadToDead(HD, D, transition_type)\n\n    return transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.modify_subpop_params","title":"<code>modify_subpop_params(updates_dict: dict)</code>","text":"<p>This method lets users safely modify a single subpopulation parameters field; if this subpop model is associated with a metapop model, the metapopulation-wide tensors are updated automatically afterward. See also <code>modify_subpop_params</code> method on <code>FluMetapopModel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_subpop_params(self,\n                         updates_dict: dict):\n    \"\"\"\n    This method lets users safely modify a single subpopulation\n    parameters field; if this subpop model is associated with\n    a metapop model, the metapopulation-wide tensors are updated\n    automatically afterward. See also `modify_subpop_params` method on\n    `FluMetapopModel`.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`.\n    \"\"\"\n\n    # If associated with metapop model, run this method\n    #   on the metapop model itself to handle metapopulation-wide\n    #   tensor updating\n    if self.metapop_model:\n        self.metapop_model.modify_subpop_params(self.name,\n                                                updates_dict)\n    else:\n        # Since `SubpopParams` is frozen, we return a new instance\n        #   with the reflected updates\n        self.params = clt.updated_dataclass(self.params, updates_dict)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.run_input_checks","title":"<code>run_input_checks() -&gt; None</code>","text":"Check the following <ul> <li>if total vaccinations exceed 100% over a year we issue a warning</li> <li>school and work calendar variables must be between 0 and 1</li> <li>absolute humidity values, contact matrix entries, daily vaccination   must be non-negative</li> <li>total contact matrix must be greater than the sum of the school   and work contact matrices</li> <li>all rate values must be strictly positive</li> <li>initial compartmental values must be non-negative</li> </ul> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def run_input_checks(self) -&gt; None:\n    \"\"\"\n    Check the following:\n        - if total vaccinations exceed 100% over a year we issue a warning\n        - school and work calendar variables must be between 0 and 1\n        - absolute humidity values, contact matrix entries, daily vaccination\n          must be non-negative\n        - total contact matrix must be greater than the sum of the school\n          and work contact matrices\n        - all rate values must be strictly positive\n        - initial compartmental values must be non-negative\n    \"\"\"\n\n    self.check_humidity_input()\n    self.check_vaccination_input()\n    self.check_calendar_variables_input()\n    self.check_contact_matrix_input()\n    self.check_rate_input()\n    self.check_initial_compartment_input()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModelError","title":"<code>FluSubpopModelError</code>","text":"<p>               Bases: <code>SubpopModelError</code></p> <p>Custom exceptions for flu subpopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluSubpopModelError(clt.SubpopModelError):\n    \"\"\"Custom exceptions for flu subpopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopParams","title":"<code>FluSubpopParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopParams</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in <code>FluSubpopModel</code>.</p> <p>Each field of datatype np.ndarray must be A x R, where A is the number of age groups and R is the number of risk groups. Note: this means all arrays should be 2D. See FluSubpopState docstring for important formatting note on 2D arrays.</p> <p>Note: the user does not have to specify <code>total_pop_age_risk</code> -- this is automatically computed when a <code>FluSubpopModel</code> is instantiated. This is to ensure that the total population (summed across all compartments) actually equals <code>total_pop_age_risk</code> -- and the user doesn't change one without updating the other.</p> <p>Attributes:</p> Name Type Description <code>num_age_groups</code> <code>positive int</code> <p>number of age groups.</p> <code>num_risk_groups</code> <code>positive int</code> <p>number of risk groups.</p> <code>beta_baseline</code> <code>positive float</code> <p>transmission rate.</p> <code>total_pop_age_risk</code> <code>np.ndarray of positive ints</code> <p>total number in population, summed across all age-risk groups.</p> <code>humidity_impact</code> <code>positive float</code> <p>coefficient that determines how much absolute humidity affects beta_baseline.</p> <code>inf_induced_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of infected individuals.</p> <code>inf_induced_immune_wane</code> <code>positive float</code> <p>rate at which infection-induced immunity against infection wanes.</p> <code>vax_induced_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of vaccinated individuals.</p> <code>vax_induced_immune_wane</code> <code>positive float</code> <p>rate at which vaccine-induced immunity against infection wanes.</p> <code>inf_induced_inf_risk_reduce</code> <code>positive float</code> <p>reduction in risk of getting infected after getting infected</p> <code>inf_induced_hosp_risk_reduce</code> <code>positive float</code> <p>reduction in risk of hospitalization after getting infected</p> <code>inf_induced_death_risk_reduce</code> <code>positive float</code> <p>reduction in risk of death after getting infected</p> <code>vax_induced_inf_risk_reduce</code> <code>positive float</code> <p>reduction in risk of getting infected after getting vaccinated</p> <code>vax_induced_hosp_risk_reduce</code> <code>positive float</code> <p>reduction in risk of hospitalization after getting vaccinated</p> <code>vax_induced_death_risk_reduce</code> <code>positive float</code> <p>reduction in risk of death after getting vaccinated</p> <code>R_to_S_rate</code> <code>positive float</code> <p>rate at which people in R move to S.</p> <code>E_to_I_rate</code> <code>positive float</code> <p>rate at which people in E move to I (both IP and IA, infected pre-symptomatic and infected asymptomatic)</p> <code>IP_to_IS_rate</code> <code>positive float</code> <p>rate a which people in IP (infected pre-symptomatic) move to IS (infected symptomatic)</p> <code>ISR_to_R_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to R.</p> <code>IA_to_R_rate</code> <code>positive float</code> <p>rate at which people in IA (infected asymptomatic) move to R</p> <code>ISH_to_H_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to H.</p> <code>HR_to_R_rate</code> <code>positive float</code> <p>rate at which people in H move to R.</p> <code>HD_to_D_rate</code> <code>positive float</code> <p>rate at which people in H move to D.</p> <code>E_to_IA_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>proportion exposed who are asymptomatic based on age-risk groups.</p> <code>IP_to_ISH_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>proportion infected who are hospitalized based on age-risk groups.</p> <code>ISH_to_HD_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>proportion hospitalized who die based on age-risk groups.</p> <code>IP_relative_inf</code> <code>positive float</code> <p>relative infectiousness of pre-symptomatic to symptomatic people (IP to IS compartment).</p> <code>IA_relative_inf</code> <code>positive float</code> <p>relative infectiousness of asymptomatic to symptomatic people (IA to IS compartment).</p> <code>relative_suscept</code> <code>np.ndarray of positive floats in [0,1]</code> <p>relative susceptibility to infection by age group</p> <code>mobility_modifier</code> <code>np.ndarray of positive floats in [0,1]</code> <p>total proportion of time spent away from home by age group</p> <code>total_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has</p> <code>school_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at school -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> <code>work_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at work -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass FluSubpopParams(clt.SubpopParams):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in `FluSubpopModel`.\n\n    Each field of datatype np.ndarray must be A x R,\n    where A is the number of age groups and R is the number of\n    risk groups. Note: this means all arrays should be 2D.\n    See FluSubpopState docstring for important formatting note\n    on 2D arrays.\n\n    Note: the user does not have to specify `total_pop_age_risk` --\n    this is automatically computed when a `FluSubpopModel` is\n    instantiated. This is to ensure that the total population\n    (summed across all compartments) actually equals `total_pop_age_risk` --\n    and the user doesn't change one without updating the other.\n\n    Attributes:\n        num_age_groups (positive int):\n            number of age groups.\n        num_risk_groups (positive int):\n            number of risk groups.\n        beta_baseline (positive float): transmission rate.\n        total_pop_age_risk (np.ndarray of positive ints):\n            total number in population, summed across all\n            age-risk groups.\n        humidity_impact (positive float):\n            coefficient that determines how much absolute\n            humidity affects beta_baseline.\n        inf_induced_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of infected individuals.\n        inf_induced_immune_wane (positive float):\n            rate at which infection-induced immunity\n            against infection wanes.\n        vax_induced_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of vaccinated individuals.\n        vax_induced_immune_wane (positive float):\n            rate at which vaccine-induced immunity\n            against infection wanes.\n        inf_induced_inf_risk_reduce (positive float):\n            reduction in risk of getting infected\n            after getting infected\n        inf_induced_hosp_risk_reduce (positive float):\n            reduction in risk of hospitalization\n            after getting infected\n        inf_induced_death_risk_reduce (positive float):\n            reduction in risk of death\n            after getting infected\n        vax_induced_inf_risk_reduce (positive float):\n            reduction in risk of getting infected\n            after getting vaccinated\n        vax_induced_hosp_risk_reduce (positive float):\n            reduction in risk of hospitalization\n            after getting vaccinated\n        vax_induced_death_risk_reduce (positive float):\n            reduction in risk of death\n            after getting vaccinated\n        R_to_S_rate (positive float):\n            rate at which people in R move to S.\n        E_to_I_rate (positive float):\n            rate at which people in E move to I (both\n            IP and IA, infected pre-symptomatic and infected\n            asymptomatic)\n        IP_to_IS_rate (positive float):\n            rate a which people in IP (infected pre-symptomatic)\n            move to IS (infected symptomatic)\n        ISR_to_R_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to R.\n        IA_to_R_rate (positive float):\n            rate at which people in IA (infected asymptomatic)\n            move to R\n        ISH_to_H_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to H.\n        HR_to_R_rate (positive float):\n            rate at which people in H move to R.\n        HD_to_D_rate (positive float):\n            rate at which people in H move to D.\n        E_to_IA_prop (np.ndarray of positive floats in [0,1]):\n            proportion exposed who are asymptomatic based on\n            age-risk groups.\n        IP_to_ISH_prop (np.ndarray of positive floats in [0,1]):\n            proportion infected who are hospitalized\n            based on age-risk groups.\n        ISH_to_HD_prop (np.ndarray of positive floats in [0,1]):\n            proportion hospitalized who die based on\n            age-risk groups.\n        IP_relative_inf (positive float):\n            relative infectiousness of pre-symptomatic to symptomatic\n            people (IP to IS compartment).\n        IA_relative_inf (positive float):\n            relative infectiousness of asymptomatic to symptomatic\n            people (IA to IS compartment).\n        relative_suscept (np.ndarray of positive floats in [0,1]):\n            relative susceptibility to infection by age group\n        mobility_modifier (np.ndarray of positive floats in [0,1]):\n            total proportion of time spent away from home by age group\n        total_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has\n        school_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at school -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n        work_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at work -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n    \"\"\"\n\n    num_age_groups: Optional[int] = None\n    num_risk_groups: Optional[int] = None\n    beta_baseline: Optional[float] = None\n    total_pop_age_risk: Optional[np.ndarray] = None\n    humidity_impact: Optional[float] = None\n\n    inf_induced_saturation: Optional[float] = None\n    inf_induced_immune_wane: Optional[float] = None\n    vax_induced_saturation: Optional[float] = None\n    vax_induced_immune_wane: Optional[float] = None\n    inf_induced_inf_risk_reduce: Optional[float] = None\n    inf_induced_hosp_risk_reduce: Optional[float] = None\n    inf_induced_death_risk_reduce: Optional[float] = None\n    vax_induced_inf_risk_reduce: Optional[float] = None\n    vax_induced_hosp_risk_reduce: Optional[float] = None\n    vax_induced_death_risk_reduce: Optional[float] = None\n\n    R_to_S_rate: Optional[float] = None\n    E_to_I_rate: Optional[float] = None\n    IP_to_IS_rate: Optional[float] = None\n    ISR_to_R_rate: Optional[float] = None\n    IA_to_R_rate: Optional[float] = None\n    ISH_to_H_rate: Optional[float] = None\n    HR_to_R_rate: Optional[float] = None\n    HD_to_D_rate: Optional[float] = None\n\n    E_to_IA_prop: Optional[np.ndarray] = None\n    IP_to_ISH_prop: Optional[torch.Tensor] = None\n    ISH_to_HD_prop: Optional[torch.Tensor] = None\n\n    IP_relative_inf: Optional[float] = None\n    IA_relative_inf: Optional[float] = None\n\n    relative_suscept: Optional[np.ndarray] = None\n\n    mobility_modifier: Optional[np.ndarray] = None\n\n    total_contact_matrix: Optional[np.ndarray] = None\n    school_contact_matrix: Optional[np.ndarray] = None\n    work_contact_matrix: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopSchedules","title":"<code>FluSubpopSchedules</code>  <code>dataclass</code>","text":"<p>Data container for dataframes used to specify schedules for each <code>FluSubpopModel</code> instance.</p> <p>THE FORMAT FOR EACH DATAFRAME IS VERY IMPORTANT -- please read and implement carefully.</p> <p>Attributes:</p> Name Type Description <code>absolute_humidity</code> <code>DataFrame</code> <p>must have columns \"date\" and \"absolute_humidity\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to absolute humidity on those days</p> <code>flu_contact_matrix</code> <code>DataFrame</code> <p>must have columns \"date\", \"is_school_day\", and \"is_work_day\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> object and \"is_school_day\" and \"is_work_day\" entries are are floats between 0 and 1  indicating if that date is a school day or work day</p> <code>daily_vaccines</code> <code>DataFrame</code> <p>must have \"date\" and \"daily_vaccines\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to historical proportion vaccinated on those days</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluSubpopSchedules:\n    \"\"\"\n    Data container for dataframes used to specify schedules\n    for each `FluSubpopModel` instance.\n\n    THE FORMAT FOR EACH DATAFRAME IS VERY IMPORTANT -- please\n    read and implement carefully.\n\n    Attributes:\n        absolute_humidity (pd.DataFrame):\n            must have columns \"date\" and \"absolute_humidity\" --\n            \"date\" entries must correspond to consecutive calendar days\n            and must either be strings with `\"YYYY-MM-DD\"` format or\n            `datetime.date` objects -- \"value\" entries correspond to\n            absolute humidity on those days\n        flu_contact_matrix (pd.DataFrame):\n            must have columns \"date\", \"is_school_day\", and \"is_work_day\"\n            -- \"date\" entries must correspond to consecutive calendar\n            days and must either be strings with `\"YYYY-MM-DD\"` format\n            or `datetime.date` object and \"is_school_day\" and\n            \"is_work_day\" entries are are floats between 0 and 1 \n            indicating if that date is a school day or work day\n        daily_vaccines (pd.DataFrame):\n            must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n            correspond to consecutive calendar days and must either\n            be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n            objects -- \"value\" entries correspond to historical\n            proportion vaccinated on those days\n    \"\"\"\n\n    absolute_humidity: Optional[pd.DataFrame] = None\n    flu_contact_matrix: Optional[pd.DataFrame] = None\n    daily_vaccines: Optional[pd.DataFrame] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopState","title":"<code>FluSubpopState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopState</code></p> <p>Data container for pre-specified and fixed set of Compartment initial values and EpiMetric initial values for <code>FluSubpopModel</code>.</p> <p>Each field below should be A x R np.ndarray, where A is the number of age groups and R is the number of risk groups. Note: this means all arrays should be 2D. Even if there is 1 age group and 1 risk group (no group stratification), each array should be 1x1, which is two-dimensional. For example, np.array([[100]]) is correct -- np.array([100]) is wrong.</p> <p>Attributes:</p> Name Type Description <code>S</code> <code>np.ndarray of nonnegative integers</code> <p>susceptible compartment for age-risk groups -- (holds current_val of Compartment \"S\").</p> <code>E</code> <code>np.ndarray of nonnegative integers</code> <p>exposed compartment for age-risk groups -- (holds current_val of Compartment \"E\").</p> <code>IP</code> <code>np.ndarray of nonnegative integers</code> <p>infected pre-symptomatic compartment for age-risk groups (holds current_val of Compartment \"IP\").</p> <code>ISR</code> <code>np.ndarray of nonnegative integers</code> <p>infected symptomatic (that will recover) compartment for age-risk groups (holds current_val of Compartment \"ISR\").</p> <code>ISH</code> <code>np.ndarray of nonnegative integers</code> <p>infected symptomatic compartment (that will be hospitalized) for age-risk groups (holds current_val of Compartment \"ISH\").</p> <code>IA</code> <code>np.ndarray of nonnegative integers</code> <p>infected asymptomatic compartment for age-risk groups (holds current_val of Compartment \"IA\").</p> <code>HR</code> <code>np.ndarray of nonnegative integers</code> <p>hospital compartment (that will recover) for age-risk groups (holds current_val of Compartment \"HR\").</p> <code>HD</code> <code>np.ndarray of nonnegative integers</code> <p>hospital compartment (that will die) for age-risk groups (holds current_val of Compartment \"HD\").</p> <code>R</code> <code>np.ndarray of nonnegative integers</code> <p>recovered compartment for age-risk groups (holds current_val of Compartment \"R\").</p> <code>D</code> <code>np.ndarray of nonnegative integers</code> <p>dead compartment for age-risk groups (holds current_val of Compartment \"D\").</p> <code>M</code> <code>np.ndarray of nonnegative floats</code> <p>infection-induced population-level immunity for age-risk groups (holds current_val of EpiMetric \"M\").</p> <code>MV</code> <code>np.ndarray of nonnegative floats</code> <p>vaccine-induced population-level immunity for age-risk groups (holds current_val of EpiMetric \"MV\").</p> <code>absolute_humidity</code> <code>positive float</code> <p>grams of water vapor per cubic meter g/m^3, used as seasonality parameter that influences transmission rate beta_baseline.</p> <code>flu_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A array, where A is the number of age groups -- element (a, a') corresponds to the number of contacts that a person in age group a has with people in age-risk group a'.</p> <code>beta_reduce</code> <code>float in [0, 1]</code> <p>starting value of DynamicVal \"beta_reduce\" on starting day of simulation -- this DynamicVal emulates a simple staged-alert policy</p> <code>daily_vaccines</code> <code>np.ndarray of positive ints</code> <p>holds current value of DailyVaccines instance, corresponding proportion of individuals in each age and risk group who received influenza vaccine on that day (generally derived from historical data)</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluSubpopState(clt.SubpopState):\n    \"\"\"\n    Data container for pre-specified and fixed set of\n    Compartment initial values and EpiMetric initial values\n    for `FluSubpopModel`.\n\n    Each field below should be A x R np.ndarray, where\n    A is the number of age groups and R is the number of risk groups.\n    Note: this means all arrays should be 2D. Even if there is\n    1 age group and 1 risk group (no group stratification),\n    each array should be 1x1, which is two-dimensional.\n    For example, np.array([[100]]) is correct --\n    np.array([100]) is wrong.\n\n    Attributes:\n        S (np.ndarray of nonnegative integers):\n            susceptible compartment for age-risk groups --\n            (holds current_val of Compartment \"S\").\n        E (np.ndarray of nonnegative integers):\n            exposed compartment for age-risk groups --\n            (holds current_val of Compartment \"E\").\n        IP (np.ndarray of nonnegative integers):\n            infected pre-symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IP\").\n        ISR (np.ndarray of nonnegative integers):\n            infected symptomatic (that will recover) compartment\n            for age-risk groups\n            (holds current_val of Compartment \"ISR\").\n        ISH (np.ndarray of nonnegative integers):\n            infected symptomatic compartment (that will be hospitalized)\n            for age-risk groups\n            (holds current_val of Compartment \"ISH\").\n        IA (np.ndarray of nonnegative integers):\n            infected asymptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IA\").\n        HR (np.ndarray of nonnegative integers):\n            hospital compartment (that will recover)\n            for age-risk groups\n            (holds current_val of Compartment \"HR\").\n        HD (np.ndarray of nonnegative integers):\n            hospital compartment (that will die)\n            for age-risk groups\n            (holds current_val of Compartment \"HD\").\n        R (np.ndarray of nonnegative integers):\n            recovered compartment for age-risk groups\n            (holds current_val of Compartment \"R\").\n        D (np.ndarray of nonnegative integers):\n            dead compartment for age-risk groups\n            (holds current_val of Compartment \"D\").\n        M (np.ndarray of nonnegative floats):\n            infection-induced population-level immunity\n            for age-risk groups (holds current_val\n            of EpiMetric \"M\").\n        MV (np.ndarray of nonnegative floats):\n            vaccine-induced population-level immunity\n            for age-risk groups (holds current_val\n            of EpiMetric \"MV\").\n        absolute_humidity (positive float):\n            grams of water vapor per cubic meter g/m^3,\n            used as seasonality parameter that influences\n            transmission rate beta_baseline.\n        flu_contact_matrix (np.ndarray of positive floats):\n            A x A array, where A is the number of age\n            groups -- element (a, a') corresponds to the number\n            of contacts that a person in age group a\n            has with people in age-risk group a'.\n        beta_reduce (float in [0,1]):\n            starting value of DynamicVal \"beta_reduce\" on\n            starting day of simulation -- this DynamicVal\n            emulates a simple staged-alert policy\n        daily_vaccines (np.ndarray of positive ints):\n            holds current value of DailyVaccines instance,\n            corresponding proportion of individuals in each\n            age and risk group who received influenza\n            vaccine on that day (generally derived from\n            historical data)\n    \"\"\"\n\n    S: Optional[np.ndarray] = None\n    E: Optional[np.ndarray] = None\n    IP: Optional[np.ndarray] = None\n    ISR: Optional[np.ndarray] = None\n    ISH: Optional[np.ndarray] = None\n    IA: Optional[np.ndarray] = None\n    HR: Optional[np.ndarray] = None\n    HD: Optional[np.ndarray] = None\n    R: Optional[np.ndarray] = None\n    D: Optional[np.ndarray] = None\n\n    M: Optional[np.ndarray] = None\n    MV: Optional[np.ndarray] = None\n\n    absolute_humidity: Optional[float] = None\n    flu_contact_matrix: Optional[np.ndarray] = None\n    beta_reduce: Optional[float] = 0.0\n\n    daily_vaccines: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelParamsTensors","title":"<code>FluTravelParamsTensors</code>  <code>dataclass</code>","text":"<p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from parameters on each location/subpopulation model, as well as from the metapopulation's associated <code>FluMixingParams</code> instance). Note that not all fields in <code>FluSubpopParams</code> are included -- we only include parameters needed for the travel model computation, for efficiency.</p> <p>Attributes:</p> Name Type Description <code>num_locations</code> <code>(Tensor, 0 - dimensional)</code> <p>number of locations (subpopulations) in the metapopulation model and therefore the travel model.</p> <code>travel_proportions</code> <code>Tensor</code> <p>L x L array, where L is the number of locations or subpopulations, where element i,j corresponds to the proportion of the population in location i who travels to location j (on average).</p> <p>See <code>FluSubpopParams</code> docstring for other attributes.</p> <p>Fields are analogous -- but (most) are size (L, A, R) for location-age-risk or size 0 tensors. Exceptions are <code>travel_proportions</code>, which is size (L, L), and any of the contact matrices, which are size (L, A, A).</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluTravelParamsTensors:\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays\n    that contain data across all subpopulations (collected from parameters\n    on each location/subpopulation model, as well as from the\n    metapopulation's associated `FluMixingParams` instance).\n    Note that not all fields in `FluSubpopParams` are included\n    -- we only include parameters needed for the travel model\n    computation, for efficiency.\n\n    Attributes:\n        num_locations (torch.Tensor, 0-dimensional):\n            number of locations (subpopulations) in the\n            metapopulation model and therefore the travel\n            model.\n        travel_proportions (torch.Tensor):\n            L x L array, where L is the number of locations\n            or subpopulations, where element i,j corresponds\n            to the proportion of the population in location i\n            who travels to location j (on average).\n\n    See `FluSubpopParams` docstring for other attributes.\n\n    Fields are analogous -- but (most) are size (L, A, R) for\n    location-age-risk or size 0 tensors. Exceptions are\n    `travel_proportions`, which is size (L, L),\n    and any of the contact matrices, which are size (L, A, A).\n    \"\"\"\n\n    num_locations: Optional[torch.tensor] = None\n    num_age_groups: Optional[torch.tensor] = None\n    num_risk_groups: Optional[torch.tensor] = None\n\n    travel_proportions: torch.Tensor = None\n\n    IP_relative_inf: torch.Tensor = None\n    IA_relative_inf: torch.Tensor = None\n\n    relative_suscept: torch.Tensor = None\n    mobility_modifier: torch.Tensor = None\n\n    total_contact_matrix: Optional[torch.Tensor] = None\n    school_contact_matrix: Optional[torch.Tensor] = None\n    work_contact_matrix: Optional[torch.Tensor] = None\n\n    def standardize_shapes(self) -&gt; None:\n        \"\"\"\n        If field is size (L, A, R) for location-age-risk or size 0 tensors,\n            or is not a special variable listed below, then apply dimension\n            expansion so that fields are size (L, A, R) tensors for tensor multiplication.\n\n        Exceptions are `travel_proportions`, which is size (L, L),\n        and any of the contact matrices, which are size (L, A, A).\n\n        Not all dimension combinations are considered not all make sense --\n        we assume that we only have risk IF we have age, for example.\n        \"\"\"\n\n        L = int(self.num_locations.item())\n        A = int(self.num_age_groups.item())\n        R = int(self.num_risk_groups.item())\n\n        error_str = \" Each SubpopParams field must have size (L, A, R) \" \\\n                    \"(for location-age-risk groups) or size 0 -- please check files \" \\\n                    \"and inputs, then try again.\"\n\n        for name, value in vars(self).items():\n\n            # Ignore the field that corresponds to a dictionary\n            if name == \"init_vals\":\n                continue\n\n            elif name == \"travel_proportions\":\n                if value.size() != torch.Size([L, L]):\n                    raise Exception(str(name) + error_str)\n\n            # `total_contact_matrix`, `school_contact_matrix`, `work_contact_matrix`\n            elif \"contact_matrix\" in name:\n                if value.size() == torch.Size([L, A, A]):\n                    continue\n                elif value.size() != torch.Size([A, A]):\n                    raise Exception(str(name) + error_str)\n                else:\n                    setattr(self, name, value.view(1, A, A).expand(L, A, A))\n\n            # If scalar or already L x A x R, do not need to adjust\n            #   dimensions\n            elif value.size() == torch.Size([]):\n                continue\n\n            elif value.size() == torch.Size([L, A, R]):\n                continue\n\n            elif value.size() == torch.Size([L]):\n                setattr(self, name, value.view(L, 1, 1).expand(L, A, R))\n\n            elif value.size() == torch.Size([A, R]):\n                setattr(self, name, value.view(1, A, R).expand(L, A, R))\n\n            else:\n                value_size = str(value.size())\n                raise Exception(str(name) + ' with size ' + value_size + error_str)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelParamsTensors.standardize_shapes","title":"<code>standardize_shapes() -&gt; None</code>","text":"<p>If field is size (L, A, R) for location-age-risk or size 0 tensors,     or is not a special variable listed below, then apply dimension     expansion so that fields are size (L, A, R) tensors for tensor multiplication.</p> <p>Exceptions are <code>travel_proportions</code>, which is size (L, L), and any of the contact matrices, which are size (L, A, A).</p> <p>Not all dimension combinations are considered not all make sense -- we assume that we only have risk IF we have age, for example.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>def standardize_shapes(self) -&gt; None:\n    \"\"\"\n    If field is size (L, A, R) for location-age-risk or size 0 tensors,\n        or is not a special variable listed below, then apply dimension\n        expansion so that fields are size (L, A, R) tensors for tensor multiplication.\n\n    Exceptions are `travel_proportions`, which is size (L, L),\n    and any of the contact matrices, which are size (L, A, A).\n\n    Not all dimension combinations are considered not all make sense --\n    we assume that we only have risk IF we have age, for example.\n    \"\"\"\n\n    L = int(self.num_locations.item())\n    A = int(self.num_age_groups.item())\n    R = int(self.num_risk_groups.item())\n\n    error_str = \" Each SubpopParams field must have size (L, A, R) \" \\\n                \"(for location-age-risk groups) or size 0 -- please check files \" \\\n                \"and inputs, then try again.\"\n\n    for name, value in vars(self).items():\n\n        # Ignore the field that corresponds to a dictionary\n        if name == \"init_vals\":\n            continue\n\n        elif name == \"travel_proportions\":\n            if value.size() != torch.Size([L, L]):\n                raise Exception(str(name) + error_str)\n\n        # `total_contact_matrix`, `school_contact_matrix`, `work_contact_matrix`\n        elif \"contact_matrix\" in name:\n            if value.size() == torch.Size([L, A, A]):\n                continue\n            elif value.size() != torch.Size([A, A]):\n                raise Exception(str(name) + error_str)\n            else:\n                setattr(self, name, value.view(1, A, A).expand(L, A, A))\n\n        # If scalar or already L x A x R, do not need to adjust\n        #   dimensions\n        elif value.size() == torch.Size([]):\n            continue\n\n        elif value.size() == torch.Size([L, A, R]):\n            continue\n\n        elif value.size() == torch.Size([L]):\n            setattr(self, name, value.view(L, 1, 1).expand(L, A, R))\n\n        elif value.size() == torch.Size([A, R]):\n            setattr(self, name, value.view(1, A, R).expand(L, A, R))\n\n        else:\n            value_size = str(value.size())\n            raise Exception(str(name) + ' with size ' + value_size + error_str)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelStateTensors","title":"<code>FluTravelStateTensors</code>  <code>dataclass</code>","text":"<p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from each location/subpopulation model). Note that not all fields in <code>FluSubpopState</code> are included -- we only include compartments needed for the travel model computation, for efficiency.</p> <p>Attributes:</p> Name Type Description <code>IP</code> <code>torch.Tensor of nonnegative integers</code> <p>presymptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IP\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>ISR</code> <code>torch.Tensor of nonnegative integers</code> <p>symptomatic infected compartment (that will recover) for location-age-risk groups -- the lth element holds current_val of Compartment \"ISR\" on the lth  location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>ISH</code> <code>torch.Tensor of nonnegative integers</code> <p>symptomatic infected compartment (that will be hospitalized) for location-age-risk groups -- the lth element holds current_val of Compartment \"ISH\" on the lth  location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>IA</code> <code>torch.Tensor of nonnegative integers</code> <p>asymptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IA\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>HR</code> <code>torch.Tensor of nonnegative integers</code> <p>hospital compartment (that will recover) for location-age-risk groups -- the lth element holds current_val of Compartment \"HR\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>HD</code> <code>torch.Tensor of nonnegative integers</code> <p>hospital compartment (that will die) for location-age-risk groups -- the lth element holds current_val of Compartment \"HD\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>flu_contact_matrix</code> <code>torch.Tensor of nonnegative integers</code> <p>contact matrix for location-age-risk groups -- the lth element holds current_val of <code>FluContactMatrix</code> <code>Schedule</code> for subpopulation l -- this value is a combination of the total contact matrix, the work contact matrix, and the school contact matrix (and the value is adjusted depending on whether the date is a work or school day)</p> <code>init_vals</code> <code>dict</code> <p>dictionary of torch.Tensor instances, where keys correspond to \"IP\", \"ISR\", \"ISH\", \"IA\", \"HR\", and \"HD\", and  values correspond to their initial values for location-age-risk groups.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluTravelStateTensors:\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays\n    that contain data across all subpopulations (collected from each\n    location/subpopulation model). Note that not all fields in\n    `FluSubpopState` are included -- we only include compartments\n    needed for the travel model computation, for efficiency.\n\n    Attributes:\n        IP (torch.Tensor of nonnegative integers):\n            presymptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IP\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        ISR (torch.Tensor of nonnegative integers):\n            symptomatic infected compartment (that will recover)\n            for location-age-risk groups -- the lth element holds\n            current_val of Compartment \"ISR\" on the lth \n            location / subpopulation on the associated `MetapopModel`.\n        ISH (torch.Tensor of nonnegative integers):\n            symptomatic infected compartment (that will be hospitalized)\n            for location-age-risk groups -- the lth element holds\n            current_val of Compartment \"ISH\" on the lth \n            location / subpopulation on the associated `MetapopModel`.\n        IA (torch.Tensor of nonnegative integers):\n            asymptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IA\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        HR (torch.Tensor of nonnegative integers):\n            hospital compartment (that will recover) for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"HR\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        HD (torch.Tensor of nonnegative integers):\n            hospital compartment (that will die) for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"HD\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        flu_contact_matrix (torch.Tensor of nonnegative integers):\n            contact matrix for location-age-risk groups -- the\n            lth element holds current_val of `FluContactMatrix`\n            `Schedule` for subpopulation l -- this value is a\n            combination of the total contact matrix, the\n            work contact matrix, and the school contact matrix\n            (and the value is adjusted depending on whether\n            the date is a work or school day)\n        init_vals (dict):\n            dictionary of torch.Tensor instances, where keys\n            correspond to \"IP\", \"ISR\", \"ISH\", \"IA\", \"HR\", and \"HD\", and \n            values correspond to their initial values for\n            location-age-risk groups.\n    \"\"\"\n\n    IP: torch.Tensor = None\n    ISR: torch.Tensor = None\n    ISH: torch.Tensor = None\n    IA: torch.Tensor = None\n    HR: torch.Tensor = None\n    HD: torch.Tensor = None\n\n    flu_contact_matrix: torch.Tensor = None\n\n    init_vals: dict = field(default_factory=dict)\n\n    # Note: `init_vals: dict = {}` does NOT work --\n    #   gives \"mutable default\" argument\n\n    def save_current_vals_as_init_vals(self):\n\n        for field in fields(self):\n            if field.name == \"init_vals\":\n                continue\n            self.init_vals[field.name] = getattr(self, field.name).clone()\n\n    def reset_to_init_vals(self):\n\n        for name, val in self.init_vals.items():\n            setattr(self, name, val.clone())\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospDeadToDead","title":"<code>HospDeadToDead</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"HD\" to \"D\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class HospDeadToDead(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"HD\" to \"D\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.HD_to_D_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospDeadToDead.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.HD_to_D_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospRecoverToRecovered","title":"<code>HospRecoverToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"HR\" to \"R\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class HospRecoverToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"HR\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.HR_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospRecoverToRecovered.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.HR_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.InfInducedImmunity","title":"<code>InfInducedImmunity</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for infection-induced population-level immunity.</p> <p>Population-level immunity increases as people move from \"R\" to \"S\" -- this is a design choice intended to avoid \"double-counting.\" People in \"R\" cannot be infected at all. People who move from \"R\" to \"S\" are susceptible again, but these recently-recovered people should have partial immunity. To handle this phenomenon, this epi metric increases as people move from \"R\" to \"S.\"</p> <p>Parameters:</p> Name Type Description Default <code>R_to_S</code> <code>RecoveredToSusceptible</code> <p>RecoveredToSusceptible TransitionVariable in the SubpopModel -- it is an attribute because the population-level immunity increases as people move from \"R\" to \"S\".</p> required <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class InfInducedImmunity(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for infection-induced\n    population-level immunity.\n\n    Population-level immunity increases as people move\n    from \"R\" to \"S\" -- this is a design choice intended\n    to avoid \"double-counting.\" People in \"R\" cannot be\n    infected at all. People who move from \"R\" to \"S\"\n    are susceptible again, but these recently-recovered people\n    should have partial immunity. To handle this phenomenon,\n    this epi metric increases as people move from \"R\" to \"S.\"\n\n    Params:\n        R_to_S (RecoveredToSusceptible):\n            RecoveredToSusceptible TransitionVariable\n            in the SubpopModel -- it is an attribute\n            because the population-level immunity\n            increases as people move from \"R\" to \"S\".\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self, init_val, R_to_S):\n        super().__init__(init_val)\n        self.R_to_S = R_to_S\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        # Note: the current values of transition variables already include\n        #   discretization (division by the number of timesteps) -- therefore,\n        #   we do not divide the first part of this equation by the number of\n        #   timesteps -- see `TransitionVariable` class's methods for getting\n        #   various realizations for more information\n\n        return (self.R_to_S.current_val / params.total_pop_age_risk) * \\\n               (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n               params.inf_induced_immune_wane * state.M / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.InfInducedImmunity.get_change_in_current_val","title":"<code>get_change_in_current_val(state: FluSubpopState, params: FluSubpopParams, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_change_in_current_val(self,\n                              state: FluSubpopState,\n                              params: FluSubpopParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # Note: the current values of transition variables already include\n    #   discretization (division by the number of timesteps) -- therefore,\n    #   we do not divide the first part of this equation by the number of\n    #   timesteps -- see `TransitionVariable` class's methods for getting\n    #   various realizations for more information\n\n    return (self.R_to_S.current_val / params.total_pop_age_risk) * \\\n           (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n           params.inf_induced_immune_wane * state.M / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.PresympToSympHospital","title":"<code>PresympToSympHospital</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IP\" to \"ISH\" compartment. The functional form is the same across subpopulations.</p> <p>Each PresympToSympHospital instance forms a TransitionVariableGroup with a corresponding PresympToSympRecover instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class PresympToSympHospital(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IP\" to \"ISH\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each PresympToSympHospital instance forms a TransitionVariableGroup with\n    a corresponding PresympToSympRecover instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n        vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray((params.IP_to_ISH_prop / immunity_force) * params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.PresympToSympHospital.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.asarray((params.IP_to_ISH_prop / immunity_force) * params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.PresympToSympRecover","title":"<code>PresympToSympRecover</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IP\" to \"ISR\" compartment. The functional form is the same across subpopulations.</p> <p>Each PresympToSympRecover instance forms a TransitionVariableGroup with a corresponding PresympToSympHospital instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class PresympToSympRecover(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IP\" to \"ISR\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each PresympToSympRecover instance forms a TransitionVariableGroup with\n    a corresponding PresympToSympHospital instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n        vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray((1 - params.IP_to_ISH_prop / immunity_force) * params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.PresympToSympRecover.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.asarray((1 - params.IP_to_ISH_prop / immunity_force) * params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.RecoveredToSusceptible","title":"<code>RecoveredToSusceptible</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"R\" to \"S\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class RecoveredToSusceptible(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"R\" to \"S\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.R_to_S_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.RecoveredToSusceptible.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.R_to_S_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SusceptibleToExposed","title":"<code>SusceptibleToExposed</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"S\" to \"E\" compartment. The functional form is the same across subpopulations.</p> <p>The rate depends on the corresponding subpopulation's contact matrix, transmission rate beta, number infected (symptomatic, asymptomatic, and pre-symptomatic), and population-level immunity against infection, among other parameters.</p> <p>This is the most complicated transition variable in the flu model. If using metapopulation model (travel model), then the rate depends on the <code>total_mixing_exposure</code> attribute, which is a function of other subpopulations' states and parameters, and travel between subpopulations.</p> <p>If there is no metapopulation model, the rate is much simpler.</p> <p>Attributes:</p> Name Type Description <code>total_mixing_exposure</code> <code>np.ndarray of positive floats</code> <p>weighted infectious count (exposure) from movement within home location, travel to other locations, and visitors from other locations</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SusceptibleToExposed(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"S\" to \"E\" compartment. The functional form is the same across\n    subpopulations.\n\n    The rate depends on the corresponding subpopulation's\n    contact matrix, transmission rate beta, number\n    infected (symptomatic, asymptomatic, and pre-symptomatic),\n    and population-level immunity against infection,\n    among other parameters.\n\n    This is the most complicated transition variable in the\n    flu model. If using metapopulation model (travel model), then\n    the rate depends on the `total_mixing_exposure` attribute,\n    which is a function of other subpopulations' states and\n    parameters, and travel between subpopulations.\n\n    If there is no metapopulation model, the rate\n    is much simpler.\n\n    Attributes:\n        total_mixing_exposure (np.ndarray of positive floats):\n            weighted infectious count (exposure) from movement\n            within home location, travel to other locations,\n            and visitors from other locations\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: clt.Compartment,\n                 destination: clt.Compartment,\n                 transition_type: clt.TransitionTypes,\n                 is_jointly_distributed: str = False):\n\n        super().__init__(origin,\n                         destination,\n                         transition_type,\n                         is_jointly_distributed)\n\n        self.total_mixing_exposure = None\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        # If `total_mixing_exposure` has not been updated,\n        #   then there is no travel model -- so, simulate\n        #   this subpopulation entirely independently and\n        #   use the simplified transition rate that does not\n        #   depend on travel dynamics\n\n        beta_adjusted = compute_beta_adjusted(state, params)\n\n        inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n        vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n        immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                        vax_induced_proportional_risk_reduce * state.MV)\n\n        if self.total_mixing_exposure is not None:\n\n            # Note here `self.total_mixing_exposure` includes\n            #   `suscept_by_age` -- see `compute_total_mixing_exposure_prop`\n            #   in `flu_travel_functions`\n\n            # Need to convert tensor into array because combining np.ndarrays and\n            #   tensors doesn't work, and everything else is an array\n            return np.asarray(beta_adjusted * self.total_mixing_exposure / immune_force)\n\n        else:\n            wtd_presymp_asymp_by_age = compute_wtd_presymp_asymp_by_age(state, params)\n\n            # Super confusing syntax... but this is the pain of having A x R,\n            #   but having the contact matrix (contact patterns) be for\n            #   ONLY age groups\n            wtd_infectious_prop = np.divide(np.sum(sum([state.ISR, state.ISH]), axis=1, keepdims=True) + wtd_presymp_asymp_by_age, # Remy TODO check the sum works\n                                            compute_pop_by_age(params))\n\n            raw_total_exposure = np.matmul(state.flu_contact_matrix, wtd_infectious_prop)\n\n            # The total rate is only age-dependent -- it's the same rate across age groups\n            return params.relative_suscept * (beta_adjusted * raw_total_exposure / immune_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SusceptibleToExposed.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # If `total_mixing_exposure` has not been updated,\n    #   then there is no travel model -- so, simulate\n    #   this subpopulation entirely independently and\n    #   use the simplified transition rate that does not\n    #   depend on travel dynamics\n\n    beta_adjusted = compute_beta_adjusted(state, params)\n\n    inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n    vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n    immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                    vax_induced_proportional_risk_reduce * state.MV)\n\n    if self.total_mixing_exposure is not None:\n\n        # Note here `self.total_mixing_exposure` includes\n        #   `suscept_by_age` -- see `compute_total_mixing_exposure_prop`\n        #   in `flu_travel_functions`\n\n        # Need to convert tensor into array because combining np.ndarrays and\n        #   tensors doesn't work, and everything else is an array\n        return np.asarray(beta_adjusted * self.total_mixing_exposure / immune_force)\n\n    else:\n        wtd_presymp_asymp_by_age = compute_wtd_presymp_asymp_by_age(state, params)\n\n        # Super confusing syntax... but this is the pain of having A x R,\n        #   but having the contact matrix (contact patterns) be for\n        #   ONLY age groups\n        wtd_infectious_prop = np.divide(np.sum(sum([state.ISR, state.ISH]), axis=1, keepdims=True) + wtd_presymp_asymp_by_age, # Remy TODO check the sum works\n                                        compute_pop_by_age(params))\n\n        raw_total_exposure = np.matmul(state.flu_contact_matrix, wtd_infectious_prop)\n\n        # The total rate is only age-dependent -- it's the same rate across age groups\n        return params.relative_suscept * (beta_adjusted * raw_total_exposure / immune_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympHospitalToHospDead","title":"<code>SympHospitalToHospDead</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"ISH\" to \"HD\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympHospitalToHospDead instance forms a TransitionVariableGroup with a corresponding SympHospitalToHospRecover instance (these two transition variables are jointly distributed).</p> <p>The rate of SympHospitalToHospDead decreases as population-level immunity against hospitalization increases.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SympHospitalToHospDead(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"ISH\" to \"HD\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympHospitalToHospDead instance forms a TransitionVariableGroup with\n    a corresponding SympHospitalToHospRecover instance (these two\n    transition variables are jointly distributed).\n\n    The rate of SympHospitalToHospDead decreases as population-level immunity\n    against hospitalization increases.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n        vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n        inf_induced_proportional_risk_reduce = \\\n            inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n        vax_induced_proportional_risk_reduce = \\\n            vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       (params.ISH_to_HD_prop / immunity_force) * params.ISH_to_H_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympHospitalToHospDead.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   (params.ISH_to_HD_prop / immunity_force) * params.ISH_to_H_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympHospitalToHospRecover","title":"<code>SympHospitalToHospRecover</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"ISH\" to \"HR\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympHospitalToHospRecover instance forms a TransitionVariableGroup with a corresponding SympHospitalToHospDead instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SympHospitalToHospRecover(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"ISH\" to \"HR\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympHospitalToHospRecover instance forms a TransitionVariableGroup with\n    a corresponding SympHospitalToHospDead instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n        vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n        inf_induced_proportional_risk_reduce = \\\n            inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n        vax_induced_proportional_risk_reduce = \\\n            vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       (1 - params.ISH_to_HD_prop / immunity_force) * params.ISH_to_H_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympHospitalToHospRecover.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   (1 - params.ISH_to_HD_prop / immunity_force) * params.ISH_to_H_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympRecoverToRecovered","title":"<code>SympRecoverToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"ISR\" to \"R\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SympRecoverToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"ISR\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.ISR_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympRecoverToRecovered.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    return np.full((params.num_age_groups, params.num_risk_groups),\n                   params.ISR_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.VaxInducedImmunity","title":"<code>VaxInducedImmunity</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for vaccine-induced population-level immunity.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class VaxInducedImmunity(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for vaccine-induced\n    population-level immunity.\n    \"\"\"\n\n    def __init__(self, init_val):\n        super().__init__(init_val)\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        # Note: `state.daily_vaccines` (based on the value of the `DailyVaccines`\n        #   `Schedule` is NOT divided by the number of timesteps -- so we need to\n        #   do this division in the equation here.\n\n        return state.daily_vaccines / (num_timesteps) - \\\n               params.vax_induced_immune_wane * state.MV / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.VaxInducedImmunity.get_change_in_current_val","title":"<code>get_change_in_current_val(state: FluSubpopState, params: FluSubpopParams, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_change_in_current_val(self,\n                              state: FluSubpopState,\n                              params: FluSubpopParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # Note: `state.daily_vaccines` (based on the value of the `DailyVaccines`\n    #   `Schedule` is NOT divided by the number of timesteps -- so we need to\n    #   do this division in the equation here.\n\n    return state.daily_vaccines / (num_timesteps) - \\\n           params.vax_induced_immune_wane * state.MV / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.accept_reject_admits","title":"<code>accept_reject_admits(metapop_model: FluMetapopModel, sampling_RNG: np.random.Generator, sampling_info: dict[str, dict[str, clt.UniformSamplingSpec]], total_daily_target_admits: list[np.ndarray], num_days: int = 50, target_accepted_reps: int = int(100.0), max_reps: int = int(1000.0), early_stop_percent: float = 0.5, target_rsquared: float = 0.75)</code>","text":"<p>Accept-reject sampler for a metapopulation model.</p> <p>This function repeatedly samples parameters from uniform distributions (as specified in <code>spec</code>) and simulates the model until the R-squared between simulated total admits and reference data exceeds <code>target_rsquared</code>. Accepted parameter sets and simulation states are saved as JSON files.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>FluMetapopModel</code> <p>The metapopulation model to simulate and sample parameters for.</p> required <code>sampling_RNG</code> <code>Generator</code> <p>Random number generator used for uniform sampling.</p> required <code>sampling_info</code> <code>dict[str, dict[str, UniformSamplingSpec]]</code> <p>See <code>clt_toolkit / sampling / sample_uniform_metapop_params / sampling_info</code> parameter for description.</p> required <code>total_daily_target_admits</code> <code>list[ndarray]</code> <p>\"Target\" time series of total admits (across subpopulations) for computing R-squared -- we would like parameters and sample paths that give simulated admits close to <code>total_daily_target_admits</code>. Must have length equal to <code>num_days</code>.</p> required <code>num_days</code> <code>int, default=50</code> <p>Total number of days to simulate for accepted parameter sets.</p> <code>50</code> <code>target_accepted_reps</code> <code>int, default=100</code> <p>Target number of accepted parameter sets (replicates) to collect.</p> <code>int(100.0)</code> <code>max_reps</code> <code>int, default=1000</code> <p>Maximum number of sampling attempts before stopping.</p> <code>int(1000.0)</code> <code>early_stop_percent</code> <code>float, default=0.5</code> <p>Fraction of <code>num_days</code> to simulate initially for early R-squared check.</p> <code>0.5</code> <code>target_rsquared</code> <code>float, default=0.75</code> <p>Minimum R-squared required between simulated and reference admits for acceptance.</p> <code>0.75</code> <p>Notes: - Early stopping is performed at <code>num_days * early_stop_percent</code> to     quickly reject poor parameter samples. - Accepted samples (and the state of the simulation at day     <code>num_days</code>) are saved to JSON files per subpopulation.     Note that for efficiency, NOT ALL PARAMETERS ARE SAVED!     Only the parameters that are randomly sampled (and thus are     different between replications). - Running this function can be slow -- test this function with a small     number of replications or simulation days to start.</p> Source code in <code>CLT_BaseModel/flu_core/flu_accept_reject.py</code> <pre><code>def accept_reject_admits(metapop_model: FluMetapopModel,\n                         sampling_RNG: np.random.Generator,\n                         sampling_info: dict[str, dict[str, clt.UniformSamplingSpec]],\n                         total_daily_target_admits: list[np.ndarray],\n                         num_days: int = 50,\n                         target_accepted_reps: int = int(1e2),\n                         max_reps: int = int(1e3),\n                         early_stop_percent: float = 0.5,\n                         target_rsquared: float = 0.75):\n    \"\"\"\n    Accept-reject sampler for a metapopulation model.\n\n    This function repeatedly samples parameters from uniform distributions\n    (as specified in `spec`) and simulates the model until the R-squared between\n    simulated total admits and reference data exceeds `target_rsquared`.\n    Accepted parameter sets and simulation states are saved as JSON files.\n\n    Parameters:\n        metapop_model (flu.FluMetapopModel):\n            The metapopulation model to simulate and sample parameters for.\n        sampling_RNG (np.random.Generator):\n            Random number generator used for uniform sampling.\n        sampling_info (dict[str, dict[str, clt.UniformSamplingSpec]]):\n            See `clt_toolkit / sampling / sample_uniform_metapop_params / sampling_info`\n            parameter for description.\n        total_daily_target_admits (list[np.ndarray]):\n            \"Target\" time series of total admits (across subpopulations)\n            for computing R-squared -- we would like parameters and\n            sample paths that give simulated admits close to\n            `total_daily_target_admits`. Must have length equal to `num_days`.\n        num_days (int, default=50):\n            Total number of days to simulate for accepted parameter sets.\n        target_accepted_reps (int, default=100):\n            Target number of accepted parameter sets (replicates) to collect.\n        max_reps (int, default=1000):\n            Maximum number of sampling attempts before stopping.\n        early_stop_percent (float, default=0.5):\n            Fraction of `num_days` to simulate initially for early R-squared check.\n        target_rsquared (float, default=0.75):\n            Minimum R-squared required between simulated and reference admits for acceptance.\n\n    Notes:\n    - Early stopping is performed at `num_days * early_stop_percent` to\n        quickly reject poor parameter samples.\n    - Accepted samples (and the state of the simulation at day\n        `num_days`) are saved to JSON files per subpopulation.\n        Note that for efficiency, NOT ALL PARAMETERS ARE SAVED!\n        Only the parameters that are randomly sampled (and thus are\n        different between replications).\n    - Running this function can be slow -- test this function with a small\n        number of replications or simulation days to start.\n    \"\"\"\n\n    if target_accepted_reps &gt; max_reps:\n        max_reps = 10 * target_accepted_reps\n\n    num_days_early_stop = int(num_days * early_stop_percent)\n\n    reps_counter = 0\n    accepted_reps_counter = 0\n\n    while reps_counter &lt; max_reps and accepted_reps_counter &lt; target_accepted_reps:\n\n        reps_counter += 1\n\n        metapop_model.reset_simulation()\n\n        param_samples = clt.sample_uniform_metapop_params(metapop_model,\n                                                          sampling_RNG,\n                                                          sampling_info)\n\n        # Save IS to H transition variable history\n        # But do not save daily (compartment) history for efficiency\n        for subpop_name, updates_dict in param_samples.items():\n            metapop_model.modify_subpop_params(subpop_name, updates_dict)\n            metapop_model.modify_simulation_settings({\"transition_variables_to_save\": [\"ISH_to_HR\", \"ISH_to_HD\"],\n                                                      \"save_daily_history\": False})\n\n        metapop_model.simulate_until_day(num_days_early_stop)\n        total_simulated_admits = clt.aggregate_daily_tvar_history(metapop_model, [\"ISH_to_HR\", \"ISH_to_HD\"])\n        current_rsquared = compute_rsquared(reference_timeseries=total_daily_target_admits[:num_days_early_stop],\n                                            simulated_timeseries=total_simulated_admits)\n        if current_rsquared &lt; target_rsquared:\n            continue\n\n        else:\n            metapop_model.simulate_until_day(num_days)\n            total_simulated_admits = clt.aggregate_daily_tvar_history(metapop_model, [\"ISH_to_HR\", \"ISH_to_HD\"])\n            current_rsquared = compute_rsquared(reference_timeseries=total_daily_target_admits,\n                                                simulated_timeseries=total_simulated_admits)\n            if current_rsquared &lt; target_rsquared:\n                continue\n            else:\n                accepted_reps_counter += 1\n\n                for subpop_name, subpop in metapop_model.subpop_models.items():\n                    with open(\"subpop_\" + str(subpop_name) + \"_rep_\" + str(accepted_reps_counter) +\n                              \"_accepted_sample_params.json\", \"w\") as f:\n                        json.dump(clt.serialize_dataclass(param_samples[subpop_name]), f, indent=4)\n                    with open(\"subpop_\" + str(subpop_name) + \"_rep_\" + str(accepted_reps_counter) +\n                              \"_accepted_state.json\", \"w\") as f:\n                        json.dump(clt.serialize_dataclass(subpop.state), f, indent=4)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.advance_timestep","title":"<code>advance_timestep(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float, save_calibration_targets: bool = False, save_tvar_history: bool = False) -&gt; Tuple[FluFullMetapopStateTensors, dict, dict]</code>","text":"<p>Advance the simulation one timestep, with length <code>dt</code>. Updates state corresponding to compartments and epidemiological metrics after computing transition variables and metric changes.</p> <p>Note that in this torch \"mean\" deterministic implementation... - We compute rates in the same way as the     <code>get_binom_deterministic_no_round</code>     transition type in the OOP code -- see     <code>TransitionVariables</code> class in     <code>clt_toolkit / base_components</code> for more details. - We also implement a \"mean\" deterministic analog     of the multinomial distribution to handle     multiple outflows from the same compartment - We do not round the transition variables - We also use <code>softplus</code>, a smooth approximation to the     ReLU function, to ensure that compartments are     nonnegative (which is not guaranteed using     the mean of a binomial/multinomial random variable     rather than sampling from those distributions).</p> <p>Returns:</p> Type Description <code>Tuple[FluFullMetapopStateTensors, dict, dict]</code> <p>New <code>FluFullMetapopStateTensors</code> with updated state, <code>dict</code> of calibration targets corresponding to state values or transition variable values used for calibration, and <code>dict</code> of transition variable values to save this history. If <code>save_calibration_targets</code> is <code>False</code>, then the corresponding <code>dict</code> is empty, and similarly with <code>save_tvar_history</code>.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def advance_timestep(state: FluFullMetapopStateTensors,\n                     params: FluFullMetapopParamsTensors,\n                     precomputed: FluPrecomputedTensors,\n                     dt: float,\n                     save_calibration_targets: bool=False,\n                     save_tvar_history: bool=False) -&gt; Tuple[FluFullMetapopStateTensors, dict, dict]:\n    \"\"\"\n    Advance the simulation one timestep, with length `dt`.\n    Updates state corresponding to compartments and\n    epidemiological metrics after computing transition variables\n    and metric changes.\n\n    Note that in this torch \"mean\" deterministic implementation...\n    - We compute rates in the same way as the\n        `get_binom_deterministic_no_round`\n        transition type in the OOP code -- see\n        `TransitionVariables` class in\n        `clt_toolkit / base_components` for more details.\n    - We also implement a \"mean\" deterministic analog\n        of the multinomial distribution to handle\n        multiple outflows from the same compartment\n    - We do not round the transition variables\n    - We also use `softplus`, a smooth approximation to the\n        ReLU function, to ensure that compartments are\n        nonnegative (which is not guaranteed using\n        the mean of a binomial/multinomial random variable\n        rather than sampling from those distributions).\n\n    Returns:\n        (Tuple[FluFullMetapopStateTensors, dict, dict]):\n            New `FluFullMetapopStateTensors` with updated state,\n            `dict` of calibration targets corresponding to state\n            values or transition variable values used for calibration,\n            and `dict` of transition variable values to save this\n            history. If `save_calibration_targets` is `False`,\n            then the corresponding `dict` is empty, and similarly with\n            `save_tvar_history`.\n    \"\"\" \n\n    S_to_E = compute_S_to_E(state, params, precomputed, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    E_to_IP_rate = compute_E_to_IP_rate(params)\n    E_to_IA_rate = compute_E_to_IA_rate(params)\n    E_outgoing_total_rate = E_to_IP_rate + E_to_IA_rate\n    E_outgoing_total = state.E * \\\n        torch_approx_binom_probability_from_rate(E_outgoing_total_rate, dt)\n    E_to_IA = E_outgoing_total * (E_to_IA_rate / E_outgoing_total_rate)              \n    E_to_IP = E_outgoing_total * (E_to_IP_rate / E_outgoing_total_rate)\n\n    IA_to_R = compute_IA_to_R(state, params, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    IP_to_ISR_rate = compute_IP_to_ISR_rate(state, params)\n    IP_to_ISH_rate = compute_IP_to_ISH_rate(state, params)\n    IP_outgoing_total_rate = IP_to_ISR_rate + IP_to_ISH_rate\n    IP_outgoing_total = state.IP * \\\n        torch_approx_binom_probability_from_rate(IP_outgoing_total_rate, dt)\n    IP_to_ISR = IP_outgoing_total * (IP_to_ISR_rate / IP_outgoing_total_rate)\n    IP_to_ISH = IP_outgoing_total * (IP_to_ISH_rate / IP_outgoing_total_rate)\n\n    ISR_to_R = compute_ISR_to_R(state, params, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    ISH_to_HR_rate = compute_ISH_to_HR_rate(state, params)\n    ISH_to_HD_rate = compute_ISH_to_HD_rate(state, params)\n    ISH_outgoing_total_rate = ISH_to_HR_rate + ISH_to_HD_rate\n    ISH_outgoing_total = state.ISH * \\\n        torch_approx_binom_probability_from_rate(ISH_outgoing_total_rate, dt)\n    ISH_to_HR = ISH_outgoing_total * (ISH_to_HR_rate / ISH_outgoing_total_rate)\n    ISH_to_HD = ISH_outgoing_total * (ISH_to_HD_rate / ISH_outgoing_total_rate)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    HR_to_R = compute_HR_to_R(state, params, dt)\n    HD_to_D = compute_HD_to_D(state, params, dt)\n\n    R_to_S = compute_R_to_S(state, params, dt)\n\n\n    # Make sure compartments are nonnegative\n    S_new = torch.nn.functional.softplus(state.S + R_to_S - S_to_E)\n    E_new = torch.nn.functional.softplus(state.E + S_to_E - E_to_IP - E_to_IA)\n    IP_new = torch.nn.functional.softplus(state.IP + E_to_IP - IP_to_ISR - IP_to_ISH)\n    ISR_new = torch.nn.functional.softplus(state.ISR + IP_to_ISR - ISR_to_R)\n    ISH_new = torch.nn.functional.softplus(state.ISH + IP_to_ISH - ISH_to_HR - ISH_to_HD)\n    IA_new = torch.nn.functional.softplus(state.IA + E_to_IA - IA_to_R)\n    HR_new = torch.nn.functional.softplus(state.HR + ISH_to_HR - HR_to_R)\n    HD_new = torch.nn.functional.softplus(state.HD + ISH_to_HD - HD_to_D)\n    R_new = torch.nn.functional.softplus(state.R + ISR_to_R + IA_to_R + HR_to_R - R_to_S)\n    D_new = torch.nn.functional.softplus(state.D + HD_to_D)\n\n    # Update immunity variables\n    M_change = compute_M_change(state, params, precomputed, dt)\n    MV_change = compute_MV_change(state, params, precomputed, dt)\n    M_new = state.M + M_change\n    MV_new = state.MV + MV_change\n\n    state_new = FluFullMetapopStateTensors(S=S_new,\n                                           E=E_new,\n                                           IP=IP_new,\n                                           ISR=ISR_new,\n                                           ISH=ISH_new,\n                                           IA=IA_new,\n                                           HR=HR_new,\n                                           HD=HD_new,\n                                           R=R_new,\n                                           D=D_new,\n                                           M=M_new,\n                                           MV=MV_new,\n                                           absolute_humidity=state.absolute_humidity,\n                                           daily_vaccines=state.daily_vaccines,\n                                           flu_contact_matrix=state.flu_contact_matrix)\n\n    calibration_targets = {}\n    if save_calibration_targets:\n        calibration_targets[\"ISH_to_H\"] = ISH_to_HR + ISH_to_HD\n\n    transition_variables = {}\n    if save_tvar_history:\n        transition_variables[\"S_to_E\"] = S_to_E\n        transition_variables[\"E_to_IP\"] = E_to_IP\n        transition_variables[\"E_to_IA\"] = E_to_IA\n        transition_variables[\"IA_to_R\"] = IA_to_R\n        transition_variables[\"IP_to_ISR\"] = IP_to_ISR\n        transition_variables[\"IP_to_ISH\"] = IP_to_ISH\n        transition_variables[\"ISR_to_R\"] = ISR_to_R\n        transition_variables[\"ISH_to_HR\"] = ISH_to_HR\n        transition_variables[\"ISH_to_HD\"] = ISH_to_HD\n        transition_variables[\"HR_to_R\"] = HR_to_R\n        transition_variables[\"HD_to_D\"] = HD_to_D\n        transition_variables[\"R_to_S\"] = R_to_S\n        transition_variables[\"M_change\"] = M_change\n        transition_variables[\"MV_change\"] = MV_change\n\n    return state_new, calibration_targets, transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_E_to_IA_rate","title":"<code>compute_E_to_IA_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_E_to_IA_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    return params.E_to_I_rate * params.E_to_IA_prop\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_E_to_IP_rate","title":"<code>compute_E_to_IP_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_E_to_IP_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    return params.E_to_I_rate * (1 - params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_HD_to_D","title":"<code>compute_HD_to_D(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_HD_to_D(state: FluFullMetapopStateTensors,\n                    params: FluFullMetapopParamsTensors,\n                    dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.HD_to_D_rate\n\n    HD_to_D = state.HD * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return HD_to_D\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_HR_to_R","title":"<code>compute_HR_to_R(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_HR_to_R(state: FluFullMetapopStateTensors,\n                    params: FluFullMetapopParamsTensors,\n                    dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.HR_to_R_rate\n\n    HR_to_R = state.HR * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return HR_to_R\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IA_to_R","title":"<code>compute_IA_to_R(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IA_to_R(state: FluFullMetapopStateTensors,\n                    params: FluFullMetapopParamsTensors,\n                    dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.IA_to_R_rate\n\n    IA_to_R = state.IA * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return IA_to_R\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IP_to_ISH_rate","title":"<code>compute_IP_to_ISH_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IP_to_ISH_rate(state: FluFullMetapopStateTensors,\n                           params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.IP_to_IS_rate * (params.IP_to_ISH_prop / immunity_force)\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IP_to_ISR_rate","title":"<code>compute_IP_to_ISR_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IP_to_ISR_rate(state: FluFullMetapopStateTensors,\n                           params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.IP_to_IS_rate * (1 - params.IP_to_ISH_prop / immunity_force)\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_ISH_to_HD_rate","title":"<code>compute_ISH_to_HD_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_ISH_to_HD_rate(state: FluFullMetapopStateTensors,\n                           params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.ISH_to_HD_prop / immunity_force * params.ISH_to_H_rate\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_ISH_to_HR_rate","title":"<code>compute_ISH_to_HR_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_ISH_to_HR_rate(state: FluFullMetapopStateTensors,\n                           params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = (1 - params.ISH_to_HD_prop / immunity_force) * params.ISH_to_H_rate\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_ISR_to_R","title":"<code>compute_ISR_to_R(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_ISR_to_R(state: FluFullMetapopStateTensors,\n                     params: FluFullMetapopParamsTensors,\n                     dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.ISR_to_R_rate\n\n    ISR_to_R = state.ISR * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return ISR_to_R\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_MV_change","title":"<code>compute_MV_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_MV_change(state: FluFullMetapopStateTensors,\n                      params: FluFullMetapopParamsTensors,\n                      precomputed: FluPrecomputedTensors,\n                      dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    MV_change = state.daily_vaccines - \\\n                params.vax_induced_immune_wane * state.MV\n\n    return MV_change * dt\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_M_change","title":"<code>compute_M_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_M_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors,\n                     precomputed: FluPrecomputedTensors,\n                     dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    # Note: already includes dt\n    R_to_S = state.R * torch_approx_binom_probability_from_rate(params.R_to_S_rate, dt)\n\n    M_change = (R_to_S / precomputed.total_pop_LAR_tensor) * \\\n               (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n               params.inf_induced_immune_wane * state.M * dt\n\n    # Because R_to_S includes dt already, we do not return M_change * dt -- we only multiply\n    #   the last term in the expression above by dt\n    return M_change\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_R_to_S","title":"<code>compute_R_to_S(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_R_to_S(state: FluFullMetapopStateTensors,\n                   params: FluFullMetapopParamsTensors,\n                   dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.R_to_S_rate\n\n    R_to_S = state.R * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return R_to_S\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_S_to_E","title":"<code>compute_S_to_E(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_S_to_E(state: FluFullMetapopStateTensors,\n                   params: FluFullMetapopParamsTensors,\n                   precomputed: FluPrecomputedTensors,\n                   dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    # Needs flu_contact_matrix to be in state for this\n    total_mixing_exposure = compute_total_mixing_exposure(state, params, precomputed)\n\n    if total_mixing_exposure.size() != torch.Size([precomputed.L,\n                                                   precomputed.A,\n                                                   precomputed.R]):\n        raise Exception(\"force_of_infection must be L x A x R corresponding \\n\"\n                        \"to number of locations (subpopulations), age groups, \\n\"\n                        \"and risk groups.\")\n\n    beta_adjusted = compute_beta_adjusted(state, params)\n\n    inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n    vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n    immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                    vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = beta_adjusted * total_mixing_exposure / immune_force\n\n    S_to_E = state.S * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return S_to_E\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_active_pop_LAR","title":"<code>compute_active_pop_LAR(state: FluTravelStateTensors, _params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Compute the active population for location-age-risk (l, a, r) as a tensor. Used to compute the effective population in the travel model, which is the population size adjusted for incoming visitors, residents traveling, and assuming hospitalized individuals are not mobile enough to infect others.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A, R): Active population: those who are not hospitalized (i.e. those who are not too sick to move and travel regularly)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_active_pop_LAR(state: FluTravelStateTensors,\n                           _params: FluTravelParamsTensors,\n                           precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Compute the active population for location-age-risk\n    (l, a, r) as a tensor. Used to compute the\n    effective population in the travel model, which is\n    the population size adjusted for incoming visitors,\n    residents traveling, and assuming hospitalized\n    individuals are not mobile enough to infect others.\n\n    Returns:\n        torch.Tensor of size (L, A, R):\n            Active population: those who are not\n            hospitalized (i.e. those who are not too sick\n            to move and travel regularly)\n    \"\"\"\n\n    # _params is not used now -- but this is included for\n    #   function signature consistency with other\n    #   similar computation functions\n\n    return precomputed.total_pop_LAR_tensor - state.HR - state.HD\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_beta_adjusted","title":"<code>compute_beta_adjusted(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Computes beta-adjusted humidity.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_beta_adjusted(state: FluFullMetapopStateTensors,\n                          params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Computes beta-adjusted humidity.\n\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    absolute_humidity = state.absolute_humidity\n    beta_adjusted = params.beta_baseline * (1 + params.humidity_impact * np.exp(-180 * absolute_humidity))\n\n    return beta_adjusted\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_effective_pop_LA","title":"<code>compute_effective_pop_LA(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A): Effective population, summed over risk groups. See <code>compute_active_pop_LAR</code> docstring for more information.</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_effective_pop_LA(state: FluTravelStateTensors,\n                             params: FluTravelParamsTensors,\n                             precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, A):\n            Effective population, summed over risk groups.\n            See `compute_active_pop_LAR` docstring for more\n            information.\n    \"\"\"\n\n    active_pop_LAR = compute_active_pop_LAR(state, params, precomputed)\n\n    # Nonlocal travel proportions is L x L\n    # Active population LAR is L x A x R\n    outside_visitors_LAR = torch.einsum(\"kl,kar-&gt;lar\",\n                                        precomputed.nonlocal_travel_prop,\n                                        active_pop_LAR)\n\n    # This is correct -- Dave checked in meeting -- we don't need Einstein\n    #   notation here!\n    # In computation, broadcast sum_residents_nonlocal_travel_prop to be L x 1 x 1\n    traveling_residents_LAR = precomputed.sum_residents_nonlocal_travel_prop[:, None, None] * \\\n                              active_pop_LAR\n\n    mobility_modifier = params.mobility_modifier[0, :, 0]\n\n    effective_pop_LA = precomputed.total_pop_LA + mobility_modifier * \\\n                       torch.sum(outside_visitors_LAR - traveling_residents_LAR, dim=2)\n\n    return effective_pop_LA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_flu_contact_matrix","title":"<code>compute_flu_contact_matrix(params: FluFullMetapopParamsTensors, schedules: FluFullMetapopScheduleTensors, day_counter: int) -&gt; torch.Tensor</code>","text":"<p>Computes flu model contact matrix in tensor format -- makes adjustments based on whether day is school day or work day.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, A))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_flu_contact_matrix(params: FluFullMetapopParamsTensors,\n                               schedules: FluFullMetapopScheduleTensors,\n                               day_counter: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes flu model contact matrix in tensor format -- makes\n    adjustments based on whether day is school day or work day.\n\n    Returns:\n        (torch.Tensor of size (L, A, A))\n    \"\"\"\n\n    # Here, using schedules.is_school_day[day_counter][:,:,0] and similarly for\n    #   is_work_day because each contact matrix (as a metapop tensor) is L x A x A --\n    #   we don't use risk -- assume here that we do not have a different school/work-day\n    #   schedule based on risk, so just grab the first risk group\n    # But then we have to take (1 - schedules.is_school_day[day_counter][:, :, 0]), which is\n    #   L x A, and then make it L x A x 1 (unsqueeze the last dimension) to make the\n    #   broadcasting work (because this gets element-wise multiplied by params.school_contact_matrix)\n    flu_contact_matrix = \\\n        params.total_contact_matrix - \\\n        params.school_contact_matrix * (1 - schedules.is_school_day[day_counter][:, :, 0]).unsqueeze(dim=2) - \\\n        params.work_contact_matrix * (1 - schedules.is_work_day[day_counter][:, :, 0]).unsqueeze(dim=2)\n\n    return flu_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_local_to_local_exposure","title":"<code>compute_local_to_local_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, sum_residents_nonlocal_travel_prop: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, location_ix: int) -&gt; torch.Tensor</code>","text":"<p>Raw means that this is unnormalized by <code>relative_suscept</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A): For a given location (specified by <code>location_ix</code>), compute local transmission caused by residents traveling within their home location, summed over risk groups.</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_local_to_local_exposure(flu_contact_matrix: torch.Tensor,\n                                    mobility_modifier: torch.Tensor,\n                                    sum_residents_nonlocal_travel_prop: torch.Tensor,\n                                    wtd_infectious_ratio_LLA: torch.Tensor,\n                                    location_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Raw means that this is unnormalized by `relative_suscept`.\n    Excludes beta and population-level immunity adjustments --\n    those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A):\n            For a given location (specified by `location_ix`), compute\n            local transmission caused by residents traveling within their\n            home location, summed over risk groups.\n    \"\"\"\n\n    # WARNING: we assume `mobility_modifier` is input as (A, 1) --\n    # if this changes, we have to change the implementation.\n    # The risk dimension does not have unique values, so we just\n    # grab the first element of the risk dimension.\n    mobility_modifier = mobility_modifier[location_ix, :, 0]\n\n    result = np.maximum(0, (1 - mobility_modifier * sum_residents_nonlocal_travel_prop[location_ix])) * \\\n             torch.matmul(flu_contact_matrix[location_ix, :, :],\n                          wtd_infectious_ratio_LLA[location_ix, location_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_outside_visitors_exposure","title":"<code>compute_outside_visitors_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, travel_proportions: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, local_ix: int, visitors_ix: int) -&gt; torch.Tensor</code>","text":"<p>Computes raw (unnormalized by <code>relative_suscept</code>) transmission to <code>local_ix</code> due to outside visitors from <code>visitors_ix</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_outside_visitors_exposure(flu_contact_matrix: torch.Tensor,\n                                      mobility_modifier: torch.Tensor,\n                                      travel_proportions: torch.Tensor,\n                                      wtd_infectious_ratio_LLA: torch.Tensor,\n                                      local_ix: int,\n                                      visitors_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes raw (unnormalized by `relative_suscept`) transmission\n    to `local_ix` due to outside visitors from `visitors_ix`.\n    Excludes beta and population-level immunity adjustments --\n    those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A)\n    \"\"\"\n\n    # In location `local_ix`, we are looking at the visitors from\n    #   `visitors_ix` who come to `local_ix` (and infect folks in `local_ix`)\n\n    # See WARNING in `compute_local_to_local_exposure()`\n    mobility_modifier = mobility_modifier[visitors_ix, :, 0]\n\n    result = travel_proportions[visitors_ix, local_ix] * \\\n             torch.matmul(mobility_modifier * flu_contact_matrix[local_ix, :, :],\n                          wtd_infectious_ratio_LLA[visitors_ix, local_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_pop_by_age","title":"<code>compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A x 1 array -- where A is the number of age groups -- where ith element corresponds to total population (across all compartments, including \"D\", and across all risk groups) in age group i</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray:\n            A x 1 array -- where A is the number of age groups --\n            where ith element corresponds to total population\n            (across all compartments, including \"D\", and across all risk groups)\n            in age group i\n    \"\"\"\n\n    return np.sum(subpop_params.total_pop_age_risk, axis=1, keepdims=True)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_residents_traveling_exposure","title":"<code>compute_residents_traveling_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, travel_proportions: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, local_ix: int, dest_ix: int) -&gt; torch.Tensor</code>","text":"<p>Computes raw (unnormalized by <code>relative_suscept</code>) transmission to <code>local_ix</code>, due to residents of <code>local_ix</code> traveling to <code>dest_ix</code> and getting infected in <code>dest_ix</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_residents_traveling_exposure(flu_contact_matrix: torch.Tensor,\n                                         mobility_modifier: torch.Tensor,\n                                         travel_proportions: torch.Tensor,\n                                         wtd_infectious_ratio_LLA: torch.Tensor,\n                                         local_ix: int,\n                                         dest_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes raw (unnormalized by `relative_suscept`) transmission\n    to `local_ix`, due to residents of `local_ix` traveling to `dest_ix`\n    and getting infected in `dest_ix`. Excludes beta and population-level\n    immunity adjustments -- those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A)\n    \"\"\"\n\n    # See WARNING in `compute_local_to_local_exposure()`\n    mobility_modifier = mobility_modifier[local_ix, :, 0]\n\n    result = mobility_modifier * travel_proportions[local_ix, dest_ix] * \\\n             torch.matmul(flu_contact_matrix[local_ix, :, :],\n                          wtd_infectious_ratio_LLA[dest_ix, dest_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_rsquared","title":"<code>compute_rsquared(reference_timeseries: list[np.ndarray], simulated_timeseries: list[np.ndarray]) -&gt; float</code>","text":"Source code in <code>CLT_BaseModel/flu_core/flu_accept_reject.py</code> <pre><code>def compute_rsquared(reference_timeseries: list[np.ndarray],\n                     simulated_timeseries: list[np.ndarray]) -&gt; float:\n    if len(reference_timeseries) != len(simulated_timeseries):\n        raise ValueError(\"Reference time series and simulated time series \\n\"\n                         \"must have same length.\")\n\n    reference_timeseries = np.asarray(reference_timeseries)\n    simulated_timeseries = np.asarray(simulated_timeseries)\n\n    ybar = reference_timeseries.mean(axis=0)\n\n    ss_residual = np.sum(np.square(simulated_timeseries - reference_timeseries))\n    ss_total = np.sum(np.square(reference_timeseries - ybar))\n\n    return 1 - ss_residual / ss_total\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_total_mixing_exposure","title":"<code>compute_total_mixing_exposure(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Computes \"total mixing exposure\" for location-age-risk (l, a, r) -- the rate of exposure to infectious individuals, accounting for both local transmission, incoming visitors, and residents traveling. Normalized by <code>relative_suscept</code>!</p> <p>Combines subroutines <code>compute_local_to_local_exposure()</code>, <code>compute_outside_visitors_exposure()</code>, and <code>compute_residents_traveling_exposure()</code>. Note that these subroutines do not include relative susceptibility -- but this function includes relative susceptibility -- this is to avoid unnecessary repeated multiplication by relative susceptible in each subroutine.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_total_mixing_exposure(state: FluTravelStateTensors,\n                                  params: FluTravelParamsTensors,\n                                  precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Computes \"total mixing exposure\" for location-age-risk\n    (l, a, r) -- the rate of exposure to infectious individuals,\n    accounting for both local transmission, incoming visitors, and\n    residents traveling. **Normalized by `relative_suscept`!**\n\n    Combines subroutines `compute_local_to_local_exposure()`,\n    `compute_outside_visitors_exposure()`, and `compute_residents_traveling_exposure()`.\n    Note that these subroutines do not include relative susceptibility --\n    but this function includes relative susceptibility -- this is to avoid\n    unnecessary repeated multiplication by relative susceptible in each subroutine.\n\n    Returns:\n        torch.Tensor of size (L, A, R)\n    \"\"\"\n\n    L, A, R = precomputed.L, precomputed.A, precomputed.R\n\n    mobility_modifier = params.mobility_modifier\n    flu_contact_matrix = state.flu_contact_matrix\n    travel_proportions = params.travel_proportions\n\n    sum_residents_nonlocal_travel_prop = precomputed.sum_residents_nonlocal_travel_prop\n    wtd_infectious_ratio_LLA = compute_wtd_infectious_ratio_LLA(state, params, precomputed)\n\n    relative_suscept = params.relative_suscept[0, :, 0]\n\n    total_mixing_exposure = torch.tensor(np.zeros((L, A, R)))\n\n    # Couldn't figure out how to do this without two for-loops ;)\n    # Welcoming any efficiency improvements!\n    for l in np.arange(L):\n\n        raw_total_mixing_exposure = torch.tensor(np.zeros(A))\n\n        raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                    compute_local_to_local_exposure(flu_contact_matrix,\n                                                                    mobility_modifier,\n                                                                    sum_residents_nonlocal_travel_prop,\n                                                                    wtd_infectious_ratio_LLA,\n                                                                    l)\n\n        for k in np.arange(L):\n            if k == l:\n                continue # no visit terms from a location to itself\n\n            raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                        compute_outside_visitors_exposure(\n                                            flu_contact_matrix,\n                                            mobility_modifier,\n                                            travel_proportions,\n                                            wtd_infectious_ratio_LLA,\n                                            l,\n                                            k)\n\n            raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                        compute_residents_traveling_exposure(\n                                            flu_contact_matrix,\n                                            mobility_modifier,\n                                            travel_proportions,\n                                            wtd_infectious_ratio_LLA,\n                                            l,\n                                            k)\n\n        normalized_total_mixing_exposure = relative_suscept * raw_total_mixing_exposure\n\n        total_mixing_exposure[l, :, :] = normalized_total_mixing_exposure.view(A, 1).expand((A, R))\n\n    return total_mixing_exposure\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_infectious_LA","title":"<code>compute_wtd_infectious_LA(state: FluTravelStateTensors, params: FluTravelParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A): Weighted infectious, summed over risk groups: includes presymptomatic, asymptomatic, and symptomatic, weighted by relative infectiousness</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_wtd_infectious_LA(state: FluTravelStateTensors,\n                              params: FluTravelParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, A):\n            Weighted infectious, summed over risk groups:\n            includes presymptomatic, asymptomatic, and symptomatic,\n            weighted by relative infectiousness\n    \"\"\"\n\n    # Einstein notation here means sum over risk groups\n    ISR = torch.einsum(\"lar-&gt;la\", state.ISR)\n    ISH = torch.einsum(\"lar-&gt;la\", state.ISH)\n    wtd_IP = \\\n        params.IP_relative_inf * torch.einsum(\"lar-&gt;la\", state.IP)\n    wtd_IA = \\\n        params.IA_relative_inf * torch.einsum(\"lar-&gt;la\", state.IA)\n\n    return ISR + ISH + wtd_IP + wtd_IA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_infectious_ratio_LLA","title":"<code>compute_wtd_infectious_ratio_LLA(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, L, A): Element i,j,a corresponds to ratio of weighted infectious people in location i, age group a (summed over risk groups) to the effective population in location j (summed over risk groups)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_wtd_infectious_ratio_LLA(state: FluTravelStateTensors,\n                                     params: FluTravelParamsTensors,\n                                     precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, L, A):\n            Element i,j,a corresponds to ratio of weighted infectious people\n            in location i, age group a (summed over risk groups) to the effective\n            population in location j (summed over risk groups)\n    \"\"\"\n\n    wtd_infectious_LA = compute_wtd_infectious_LA(state, params)\n\n    effective_pop_LA = compute_effective_pop_LA(state, params, precomputed)\n\n    prop_wtd_infectious = torch.einsum(\"ka,la-&gt;kla\",\n                                       wtd_infectious_LA,\n                                       1 / effective_pop_LA)\n\n    return prop_wtd_infectious\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_presymp_asymp_by_age","title":"<code>compute_wtd_presymp_asymp_by_age(subpop_state: FluSubpopState, subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns weighted sum of IP and IA compartment for     subpopulation with given state and parameters.     IP and IA are weighted by their relative infectiousness     respectively, and then summed over risk groups.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_wtd_presymp_asymp_by_age(subpop_state: FluSubpopState,\n                                     subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns weighted sum of IP and IA compartment for\n        subpopulation with given state and parameters.\n        IP and IA are weighted by their relative infectiousness\n        respectively, and then summed over risk groups.\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # sum over risk groups\n    wtd_IP = \\\n        subpop_params.IP_relative_inf * np.sum(subpop_state.IP, axis=1, keepdims=True)\n    wtd_IA = \\\n        subpop_params.IA_relative_inf * np.sum(subpop_state.IA, axis=1, keepdims=True)\n\n    return wtd_IP + wtd_IA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.create_dict_of_tensors","title":"<code>create_dict_of_tensors(d: dict, requires_grad: bool = True) -&gt; dict</code>","text":"<p>Converts dictionary entries to <code>tensor</code> (of type <code>torch.float32</code>) and if <code>requires_grad</code> is <code>True</code>, turns on gradient tracking for each entry -- returns new dictionary.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def create_dict_of_tensors(d: dict,\n                           requires_grad: bool = True) -&gt; dict:\n    \"\"\"\n    Converts dictionary entries to `tensor` (of type `torch.float32`)\n    and if `requires_grad` is `True`, turns on gradient tracking for\n    each entry -- returns new dictionary.\n    \"\"\"\n\n    def to_tensor(k, v):\n        if v is None:\n            return None\n        else:\n            return torch.tensor(v, dtype=torch.float32, requires_grad=requires_grad)\n\n    return {k: to_tensor(k, v) for k, v in d.items()}\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_approx_binom_probability_from_rate","title":"<code>torch_approx_binom_probability_from_rate(rate, dt)</code>","text":"<p>Torch-compatible implementation of converting a rate into a probability. See analogous numpy implementation <code>base_components/approx_binom_probability_from_rate()</code> docstring for details.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_approx_binom_probability_from_rate(rate, dt):\n    \"\"\"\n    Torch-compatible implementation of converting a\n    rate into a probability. See analogous numpy implementation\n    `base_components/approx_binom_probability_from_rate()` docstring\n    for details.\n    \"\"\"\n\n    return 1 - torch.exp(-rate * dt)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_simulate_full_history","title":"<code>torch_simulate_full_history(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, schedules: FluFullMetapopScheduleTensors, num_days: int, timesteps_per_day: int) -&gt; Tuple[dict, dict]</code>","text":"<p>Simulates the flu model with a differentiable torch implementation that carries out <code>binom_deterministic_no_round</code> transition types -- returns hospital admits for calibration use.</p> <p>See subroutine <code>advance_timestep</code> for additional details.</p> <p>Returns:</p> Type Description <code>Tuple[dict, dict]</code> <p>Returns compartment states and transition variables for day, location, age, risk, in tensor format.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_simulate_full_history(state: FluFullMetapopStateTensors,\n                                params: FluFullMetapopParamsTensors,\n                                precomputed: FluPrecomputedTensors,\n                                schedules: FluFullMetapopScheduleTensors,\n                                num_days: int,\n                                timesteps_per_day: int) -&gt; Tuple[dict, dict]:\n    \"\"\"\n    Simulates the flu model with a differentiable torch implementation\n    that carries out `binom_deterministic_no_round` transition types --\n    returns hospital admits for calibration use.\n\n    See subroutine `advance_timestep` for additional details.\n\n    Returns:\n        (Tuple[dict, dict]):\n            Returns compartment states and transition variables\n            for day, location, age, risk, in tensor format.\n    \"\"\"\n\n    dt = 1 / float(timesteps_per_day)\n\n    state_history_dict = defaultdict(list)\n    tvar_history_dict = defaultdict(list)\n\n    # This could probably be written better so we don't have\n    #   unused variables \"_\" that grab `advance_timestep` output?\n\n    for day in range(num_days):\n        state = update_state_with_schedules(state, params, schedules, day)\n\n        for timestep in range(timesteps_per_day):\n            # TODO double check whether this split makes sense\n            #   to get the total transition variables we should need to save values\n            #   at each timestep when there are several steps per day\n            #   (these variables may not be used anywhere right now)\n            if timestep == timesteps_per_day-1:\n                state, _, tvar_history = \\\n                    advance_timestep(state, params, precomputed, dt, save_tvar_history=True)\n                for key in tvar_history:\n                    tvar_history_dict[key].append(tvar_history[key])\n            else:\n                state, _, _ = \\\n                    advance_timestep(state, params, precomputed, dt, save_tvar_history=False)\n\n        for field in fields(state):\n            if field.name == \"init_vals\":\n                continue\n            state_history_dict[str(field.name)].append(getattr(state, field.name).clone())\n\n    return state_history_dict, tvar_history_dict\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_simulate_hospital_admits","title":"<code>torch_simulate_hospital_admits(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, schedules: FluFullMetapopScheduleTensors, num_days: int, timesteps_per_day: int) -&gt; torch.Tensor</code>","text":"<p>Analogous to <code>torch_simulate_full_history</code> but only saves and returns hospital admits for calibration use.</p> <p>Returns:</p> Type Description <code>torch.Tensor of size (num_days, L, A, R)</code> <p>Returns hospital admits (the ISH to HR and HD  transition variable values) for day, location, age, risk, in tensor format.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_simulate_hospital_admits(state: FluFullMetapopStateTensors,\n                                     params: FluFullMetapopParamsTensors,\n                                     precomputed: FluPrecomputedTensors,\n                                     schedules: FluFullMetapopScheduleTensors,\n                                     num_days: int,\n                                     timesteps_per_day: int) -&gt; torch.Tensor:\n    \"\"\"\n    Analogous to `torch_simulate_full_history` but only saves and\n    returns hospital admits for calibration use.\n\n    Returns:\n        (torch.Tensor of size (num_days, L, A, R)):\n            Returns hospital admits (the ISH to HR and HD \n            transition variable values) for day, location,\n            age, risk, in tensor format.\n    \"\"\"\n\n    hospital_admits_history = []\n\n    dt = 1 / float(timesteps_per_day)\n\n    for day in range(num_days):\n        state = update_state_with_schedules(state, params, schedules, day)\n        for timestep in range(timesteps_per_day):\n            state, calibration_targets, _ = \\\n                advance_timestep(state, params, precomputed, dt, save_calibration_targets=True)\n        hospital_admits_history.append(calibration_targets[\"ISH_to_H\"].clone())\n\n    return torch.stack(hospital_admits_history)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.update_state_with_schedules","title":"<code>update_state_with_schedules(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, schedules: FluFullMetapopScheduleTensors, day_counter: int) -&gt; FluFullMetapopStateTensors</code>","text":"<p>Returns new dataclass formed by copying the current <code>state</code> and updating specific values according to <code>schedules</code> and the simulation's current <code>day_counter</code>.</p> <p>Returns:</p> Type Description <code>FluFullMetapopStateTensors</code> <p>New state with updated schedule-related values:   - <code>flu_contact_matrix</code>   - <code>absolute_humidity</code>   - <code>daily_vaccines</code> All other fields remain unchanged from the input <code>state</code>.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def update_state_with_schedules(state: FluFullMetapopStateTensors,\n                                params: FluFullMetapopParamsTensors,\n                                schedules: FluFullMetapopScheduleTensors,\n                                day_counter: int) -&gt; FluFullMetapopStateTensors:\n    \"\"\"\n    Returns new dataclass formed by copying the current `state`\n    and updating specific values according to `schedules` and\n    the simulation's current `day_counter`.\n\n    Returns:\n        (FluFullMetapopStateTensors):\n            New state with updated schedule-related values:\n              - `flu_contact_matrix`\n              - `absolute_humidity`\n              - `daily_vaccines`\n            All other fields remain unchanged from the input `state`.\n    \"\"\"\n\n    flu_contact_matrix = compute_flu_contact_matrix(params, schedules, day_counter)\n    absolute_humidity = schedules.absolute_humidity[day_counter]\n    daily_vaccines = schedules.daily_vaccines[day_counter]\n\n    state_new = FluFullMetapopStateTensors(\n        S=state.S,\n        E=state.E,\n        IP=state.IP,\n        ISR=state.ISR,\n        ISH=state.ISH,\n        IA=state.IA,\n        HR=state.HR,\n        HD=state.HD,\n        R=state.R,\n        D=state.D,\n        M=state.M,\n        MV=state.MV,\n        absolute_humidity=absolute_humidity,\n        daily_vaccines=daily_vaccines,\n        flu_contact_matrix=flu_contact_matrix\n    )\n\n    return state_new\n</code></pre>"},{"location":"flu_input_requirements/","title":"Math-to-Code Input Mappings","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) <p>\\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow [ISR, ISH]}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateISRtoR{\\gamma^{ISR\\rightarrow R}}\\) \\(\\def\\rateISHtoH{\\sigma^{ISH\\rightarrow [HR, HD]}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateHRtoR{\\gamma^{HR\\rightarrow R}}\\) \\(\\def\\rateHDtoD{\\sigma^{HD\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a,r}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) </p> <p>Here, we provide mappings between the mathematical variables in the mathematical formulation and input variable names in the code. For users to customize the values (not the structure) of the flu model given in <code>flu_components.py</code>, they must abide by certain input specifications.</p> <p>Recall that the class <code>FluSubpopModel</code> simulates the flu model given by this mathematical formulation for a specific subpopulation. Multiple <code>FluSubpopModel</code> instances can be combined as input into a <code>FluMetapopModel</code> instance to simulate multiple subpopulations and travel between these subpopulations. To implement a concrete <code>FluSubpopModel</code> instance requires user-specified inputs, including demographics, epidemiological parameters, and simulation settings.</p>"},{"location":"flu_input_requirements/#flusubpopstate","title":"<code>FluSubpopState</code>","text":"<p>Note that there is one <code>FluSubpopState</code> for each <code>SubpopModel</code> instance. The following matrices are for a specific subpopulation. But here we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. </p> Dataclass Field Name Math Variable Dimension <code>S</code> \\(\\boldsymbol{S}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>E</code> \\(\\boldsymbol{E}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IP</code> \\(\\boldsymbol{IP}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>ISR</code> \\(\\boldsymbol{ISR}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>ISH</code> \\(\\boldsymbol{ISH}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IA</code> \\(\\boldsymbol{IA}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>HR</code> \\(\\boldsymbol{HR}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>HD</code> \\(\\boldsymbol{HD}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>R</code> \\(\\boldsymbol{R}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>D</code> \\(\\boldsymbol{D}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>M</code> \\(\\boldsymbol{M}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>MV</code> \\(\\boldsymbol{MV}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\)"},{"location":"flu_input_requirements/#flusubpopparams","title":"<code>FluSubpopParams</code>","text":"<p>This dataclass specifies the subpopulation's epidemiological parameters -- it specifies values such as transition rates as well as number of age groups and risk groups. We assume that these values do not change throughout the course of the simulation.  </p> <p>The following variables are for a specific subpopulation, although many of these variables will be the same across subpopulations in practice. Here in the table below we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. Variables that are positive floats can be generalized to be age-risk dependent.</p> Dataclass Field Name Math Variable Dimension <code>num_age_groups</code> \\(\\lvert \\mathcal A \\rvert\\) positive <code>int</code> <code>num_risk_groups</code> \\(\\lvert \\mathcal R \\rvert\\) positive <code>int</code> <code>beta_baseline</code> \\(\\beta_0\\) positive <code>float</code> <code>total_pop_age_risk</code> \\(\\boldsymbol{N}\\) \\(\\lvert \\mathcal A \\rvert \\times  \\lvert \\mathcal R \\rvert\\) <code>humidity_impact</code> \\(\\xi\\) <code>float</code> <code>inf_induced_saturation</code> \\(o\\) nonnegative <code>float</code> <code>vax_induced_saturation</code> \\(o_v\\) nonnegative <code>float</code> <code>inf_induced_immune_wane</code> \\(w\\) nonnegative <code>float</code> <code>vax_induced_immune_wane</code> \\(w_v\\) nonnegative <code>float</code> <code>inf_induced_inf_risk_reduce</code> \\(k^I\\) <code>float</code> in \\([0,1)\\) <code>inf_induced_hosp_risk_reduce</code> \\(k^H\\) <code>float</code> in \\([0,1)\\) <code>inf_induced_death_risk_reduce</code> \\(k^D\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_inf_risk_reduce</code> \\(k^I_v\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_hosp_risk_reduce</code> \\(k^H_v\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_death_risk_reduce</code> \\(k^D_v\\) <code>float</code> in \\([0,1)\\) <code>R_to_S_rate</code> \\(\\rateRtoS\\) positive <code>float</code> <code>E_to_I_rate</code> \\(\\rateEtoI\\) positive <code>float</code> <code>IP_to_IS_rate</code> \\(\\rateIPtoIS\\) positive <code>float</code> <code>ISR_to_R_rate</code> \\(\\rateISRtoR\\) positive <code>float</code> <code>ISH_to_H_rate</code> \\(\\rateISHtoH\\) positive <code>float</code> <code>IA_to_R_rate</code> \\(\\rateIAtoR\\) positive <code>float</code> <code>HR_to_R_rate</code> \\(\\rateHRtoR\\) positive <code>float</code> <code>HD_to_D_rate</code> \\(\\rateHDtoD\\) positive <code>float</code> <code>E_to_IA_prop</code> \\(\\propIA\\) <code>float</code> in \\([0,1]\\) <code>IP_to_ISH_prop</code> \\(\\propH\\) <code>float</code> in \\([0,1]\\) <code>ISH_to_HD_prop</code> \\(\\propD\\) <code>float</code> in \\([0,1]\\) <code>IP_relative_inf</code> \\(r_{IP}\\) positive <code>float</code> <code>IA_relative_inf</code> \\(r_{IA}\\) positive <code>float</code> <code>relative_suscept</code> \\(\\psi\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>mobility_modifier</code> \\(m\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>total_contact_matrix</code> \\(\\phi^{(\\ell), \\text{total}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>school_contact_matrix</code> \\(\\phi^{(\\ell), \\text{work}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>work_contact_matrix</code> \\(\\phi^{(\\ell), \\text{school}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <p>See the next section on <code>FluSubpopSchedules</code> for how \\(d_{\\text{work}}(t)\\) and \\(d_{\\text{school}}(t)\\) are defined.</p>"},{"location":"flu_input_requirements/#flusubpopschedules","title":"<code>FluSubpopSchedules</code>","text":"Dataclass Field Name Column Name Math Variable Dimension <code>absolute_humidity</code> <code>absolute_humidity</code> \\(h(t)\\) positive <code>float</code> <code>flu_contact_matrix</code> <code>is_school_day</code> \\(d_{\\text{work}}(t)\\) <code>float</code> in \\([0,1]\\) <code>flu_contact_matrix</code> <code>is_work_day</code> \\(d_{\\text{school}}(t)\\) <code>bool</code> <code>daily_vaccines</code> <code>daily_vaccines</code> \\(V^{(\\ell)}_{a, r}(t)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) of <code>float</code> in \\([0,1]\\)"},{"location":"flu_input_requirements/#flumixingparams","title":"<code>FluMixingParams</code>","text":"Dataclass Field Name Math Variable Dimension <code>num_locations</code> \\(\\lvert \\mathcal A \\rvert\\) positive <code>int</code> <code>travel_proportions</code> \\(p^{\\ell \\rightarrow k}\\) \\(\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert\\) of <code>float</code> in \\([0,1]\\)"},{"location":"flu_input_requirements/#simulationsettings","title":"<code>SimulationSettings</code>","text":"<p>The field <code>timesteps_per_day</code> is the number of timesteps to take per day, which equals \\(1/(\\Delta t)\\), where \\(\\Delta t\\) is the discretization interval. The field <code>transition_type</code> determines the distribution used for transitions between compartments (see page on transitions). The field <code>start_real_date</code> is the real-world date in string format <code>\"YYYY-MM-DD\"</code> corresponding to the start of the simulation. </p> <p>See <code>SimulationSettings</code> docstring for other fields (those are not directly related to the mathematical formulation and only specify how simulation output is saved).</p> <p>Updated 12/12/2025. Written by LP and updated by R\u00e9my Pasco, edited by Susan Ptak.</p>"},{"location":"math_flu_components/","title":"MetroFluSim Mathematical Formulation","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) \\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow [ISR, ISH]}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\rateISRtoR{\\gamma^{ISR\\rightarrow R}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateISHtoH{\\sigma^{ISH\\rightarrow [HR, HD]}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateHRtoR{\\gamma^{HR\\rightarrow R}}\\) \\(\\def\\rateHDtoD{\\sigma^{HD\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) \\(\\def\\proptravelelltok{p^{\\ell \\rightarrow k}}\\) \\(\\def\\propdaytravelktoell{p^{k \\rightarrow \\ell}}\\) \\(\\def\\LambdaIlocagerisktime{\\Lambda^{(\\ell), I}_{a,r}(t)}\\) \\(\\def\\LambdaHlocagerisktime{\\Lambda^{(\\ell), H}_{a,r}(t)}\\) \\(\\def\\LambdaDlocagerisktime{\\Lambda^{(\\ell), D}_{a,r}(t)}\\) \\(\\def\\locationell{^{(\\ell)}}\\) \\(\\def\\locationk{^{(k)}}\\) \\(\\def\\locagerisk{\\locationell_{a, r}}\\) \\(\\def\\locagerisktime{\\locagerisk(t)}\\) \\(\\def\\agetime{_a(t)}\\) \\(\\def\\agerisk{_{a, r}}\\) \\(\\def\\agerisktime{_{a, r}(t)}\\) \\(\\def\\ageprimeriskprime{_{a^\\prime, r^\\prime}}\\) \\(\\def\\locageprimeriskprime{\\locationell_{a^\\prime, r^\\prime}}\\) \\(\\def\\Nlocagerisk{N\\locationell_{a,r}}\\) \\(\\def\\effectiveNlocagerisktime{\\tilde{N}\\locationell_{a,r}(t)}\\) \\(\\def\\effectiveNlocageprimeriskprimetime{\\tilde{N}\\locationell_{a^\\prime,r^\\prime}(t)}\\) \\(\\def\\multipliersymptom{h_{\\text{symp}}}\\) \\(\\def\\tvarloc{y^{(\\ell)}}\\) \\(\\def\\jointtvarloc{y^{(\\ell) *}}\\) \\(\\def\\simstate{\\boldsymbol{\\Xi}_t}\\) \\(\\def\\agegroups{\\mathcal A}\\) \\(\\def\\riskgroups{\\mathcal R}\\) \\(\\def\\numagegroups{\\lvert \\agegroups \\rvert}\\) \\(\\def\\numriskgroups{\\lvert \\riskgroups \\rvert}\\) \\(\\def\\poik{\\text{POI}(k)}\\) \\(\\def\\poiell{\\text{POI}(\\ell)}\\) </p> <p>The mathematical framework is inspired by the immunoSEIRS model of the Meyers Lab (see Bi and Bandekar et al. 2023, Bi et al. 2022 and Bouchnita et al. 2021 for some related recent publications).</p> <p>Please note that the MetroFluSim model requires extensive notation -- please review the entirety of each section for provided definitions.</p>"},{"location":"math_flu_components/#flu-model-diagram","title":"Flu model: diagram","text":""},{"location":"math_flu_components/#flu-model-deterministic-differential-equations","title":"Flu model: deterministic differential equations","text":"<p>We start off with common indices and arguments: - \\(t \\in \\mathbb N\\): current simulation day - \\(\\ell\\): location, i.e. subpopulation, \\(\\mathcal L\\): set of all locations/subpopulations - \\(a\\): age group, \\(\\agegroups\\): set of all age groups - \\(r\\): risk group, \\(\\riskgroups\\): set of all risk groups - \\(i\\): type of immunity-inducing event, \\(\\mathcal{I} := \\left\\{\\text{infection}, \\text{vaccine}\\right\\}\\): the set of all types of immunity-inducing events: infection and vaccination, respectively.</p>"},{"location":"math_flu_components/#population-level-immunity","title":"Population-level immunity","text":"<p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\):</p> \\[\\begin{align*} \\frac{dM\\locationell\\agerisktime}{dt} &amp;= \\frac{\\rateRtoS(t) R\\locagerisktime}{N\\locationell_{a, r}} \\cdot (1 - oM\\locationell\\agerisktime - o_v MV\\locationell\\agerisktime) - wM\\locationell\\agerisktime \\tag{M1} \\\\ \\frac{dMV\\locationell\\agerisktime}{dt} &amp;= V\\locationell\\agerisk(t - \\delta) - w_v MV\\locationell\\agerisktime \\tag{M2} \\end{align*}\\] <p>where</p> <ul> <li>\\(\\rateRtoS\\): rate at which recovered individuals become susceptible, so that \\(1/\\rateRtoS\\) is the average number of days a person is totally immune from reinfection until being susceptible again.</li> <li>\\(V\\locationell\\agerisktime\\): proportion of individuals residing in location \\(\\ell \\in \\mathcal L\\) in age-risk group \\(a\\), \\(r\\) who receive vaccines at time \\(t\\).</li> <li>\\(o\\), \\(o_v\\): positive constants modeling the saturation of antibody production in individuals who have infection-induced immunity and vaccination-induced immunity, respectively.</li> <li>\\(\\delta\\): number of days after dose for vaccine to become effective.</li> <li>\\(w\\): rate at which infection-induced immunity wanes.</li> <li>\\(w_V\\): rate at which vaccine-induced immunity wanes.</li> </ul>"},{"location":"math_flu_components/#compartment-equations","title":"Compartment equations","text":"<p>Note that the following are all \\(\\numagegroups \\times \\numriskgroups \\times \\lvert \\mathcal I \\rvert\\) matrices:</p> <ul> <li>\\(\\boldsymbol{K}^I = [\\boldsymbol{K}^I, \\boldsymbol{K}^I_{V}]\\): reduction in infection risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^{H} = [\\boldsymbol{K}^H, \\boldsymbol{K}^H_{V}]\\): reduction in hospitalization risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^D = [\\boldsymbol{K}^D, \\boldsymbol{K}^D_{V}]\\): reduction in death risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{M}\\locationell = \\boldsymbol{M}\\locationell(t) = [\\boldsymbol{M}\\locationell(t), \\boldsymbol{M}\\locationell_{V}(t)]\\): location \\(\\ell \\in \\mathcal L\\) population-level immunity.  </li> </ul> <p>To simplify notation, we have the following terms that characterize the effect of population-level immunities for a given subpopulation \\(\\ell\\), age \\(a\\), and risk \\(r\\):</p> \\[\\begin{align*} \\LambdaIlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{I}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{I}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I1} \\\\ \\LambdaHlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{H}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{H}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I2} \\\\ \\LambdaDlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{D}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{D}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I3} \\end{align*}\\] <p>where \\(\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1}\\) is an \\(\\lvert \\mathcal L \\rvert \\times 1\\) vector of \\(1\\)'s and the fraction notation indicates element-wise division. </p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\), we have the following equations that characterize transitions between compartments:</p> \\[\\begin{align} \\frac{dS\\locagerisktime}{dt} &amp;= \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}}  -\\underbrace{S\\locagerisktime \\frac{\\beta\\locationell(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIlocagerisktime\\right)}}_{\\text{$S$ to $E$}} \\tag{C1} \\\\[1.5em] \\frac{dE\\locagerisktime}{dt} &amp;= \\underbrace{S\\locagerisktime \\frac{\\beta\\locationell(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIlocagerisktime\\right)}}_{\\text{$S$ to $E$}} - \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}} - \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}} \\tag{C2} \\\\[1.5em] \\frac{dIP\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}} - \\underbrace{\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $ISR$ and $ISH$}} \\tag{C3} \\\\[1.5em] \\frac{dISR\\locagerisktime}{dt} &amp;= \\underbrace{\\left(1-\\frac{\\pi^H}{1 + \\LambdaHlocagerisktime}\\right)\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $ISR$}}  - \\underbrace{\\rateISRtoR ISR\\locagerisktime}_{\\text{$ISR$ to $R$}} \\tag{C4} \\\\[1.5em] \\frac{dISH\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\pi^H \\rateIPtoIS IP\\locagerisktime}{1 + \\LambdaHlocagerisktime}}_{\\text{$IP$ to $ISH$}} - \\underbrace{\\rateISHtoH ISH\\locagerisktime}_{\\text{$ISH$ to $HR$ and $HD$}} \\tag{C5} \\\\[1.5em] \\frac{dIA\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}}  - \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}} \\tag{C6} \\\\[1.5em] \\frac{dHR\\locagerisktime}{dt} &amp;= \\underbrace{\\left(1-\\frac{\\pi^D_{a, r}}{1 + \\LambdaDlocagerisktime}\\right) \\rateISHtoH ISH\\locagerisktime}_{\\text{$ISH$ to $HR$}} - \\underbrace{\\rateHRtoR HR\\locagerisktime}_{\\text{$HR$ to $R$}} \\tag{C7} \\\\[1.5em] \\frac{dHD\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\pi^D_{a, r} \\rateISHtoH ISH\\locagerisktime}{1 + \\LambdaDlocagerisktime}}_{\\text{$ISH$ to $HD$}} - \\underbrace{\\rateHDtoD HD\\locagerisktime}_{\\text{$HD$ to $D$}} \\tag{C8} \\\\[1.5em] \\frac{dR\\locagerisktime}{dt} &amp;= \\underbrace{\\rateISRtoR ISR\\locagerisktime}_{\\text{$ISR$ to $R$}} + \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}} + \\underbrace{\\rateHRtoR HR\\locagerisktime}_{\\text{$HR$ to $R$}} - \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}} \\tag{C9} \\\\[1.5em] \\frac{dD\\locagerisktime}{dt} &amp;= \\underbrace{\\rateHDtoD HD\\locagerisktime}_{\\text{$HD$ to $D$}}. \\tag{C10} \\end{align}\\] <p>where</p> <ul> <li>The \\(\\lambda\\)-terms are location/subpopulation mixing terms that we define in the next section on the travel model. </li> <li>\\(\\boldsymbol{N}\\locationell\\): \\(\\numagegroups \\times \\numriskgroups\\) matrix corresponding to total population in location \\(\\ell \\in \\mathcal L\\), where element \\(N\\locagerisk\\) is the total population of age group \\(a\\) and risk group \\(\\ell\\) in location \\(\\ell\\).</li> <li>\\(\\beta\\locationell(t) = \\beta\\locationell_0 (1 + q(t))\\): time-dependent transmission rate per day for individuals residing in location \\(\\ell \\in \\mathcal L\\). </li> <li>\\(q(t) = \\xi \\cdot \\exp^{-180 * h(t)}\\): humidity adjustment, where \\(\\xi\\) is the humidity impact factor and \\(h(t)\\) is absolute humidity. This formula is taken from this paper.</li> <li>\\(\\propIA\\): proportion exposed who are completely asymptomatic when infectious.</li> <li>\\(r_{IP}\\), \\(r_{IA}\\): relative infectiousness (compared to infected symptomatic people) of infected presymptomatic and infected asymptomatic people respectively. </li> <li>\\(\\rateISRtoR, \\rateHRtoR, \\rateIAtoR\\): recovery rates for infected symptomatic (\\(ISR\\)),  hospital (\\(HR\\)), and infected asymptomatic (\\(IA\\)) compartments respectively, so that \\(1/\\gamma\\) is the average number of days it takes for an infected person not in the hospital to recover, and \\(1/\\rateHtoR\\) is analogous, but for an infected person in the hospital. </li> <li>\\(\\rateEtoI\\): infection rate (both exposed to infected presymptomatic transition rate and exposed to infected asymptomatic transition rate), so that \\(1/\\rateEtoI\\) is the average number of days after exposure before a person becomes infectious.</li> <li>\\(\\rateIPtoIS\\): infected presymptomatic to infected symptomatic (both \\(ISR\\) and \\(ISH\\)) transition rate, so that \\(1/\\rateIPtoIS\\) is the average number of days that an infected person is presymptomatic before becoming symptomatic. </li> <li>\\(\\rateISHtoH\\): hospitalization rate (infected to hospital transition rate), so that \\(1/\\rateISHtoH\\) is the average number of days a person is infected before going to the hospital.</li> <li>\\(\\rateHDtoD\\): death rate from hospital, so that \\(1/\\rateHDtoD\\) is the average number of days a person spends in the hospital before dying.</li> </ul> <ul> <li>\\(\\boldsymbol{\\propH}\\): \\(\\numagegroups \\times \\numriskgroups\\) proportion hospitalized based on age-risk group \\(a, r\\).</li> </ul> <ul> <li>\\(\\boldsymbol{\\propD}\\): \\(\\numagegroups \\times \\numriskgroups\\) in-hospital mortality rate (proportion who die based on age-risk group \\(a, r\\)).</li> </ul>"},{"location":"math_flu_components/#flu-model-travel-model","title":"Flu model: travel model","text":""},{"location":"math_flu_components/#exposure-intensity","title":"Exposure intensity","text":"<p>For each \\(\\ell \\in \\mathcal L\\), \\(k \\in \\mathcal L \\setminus \\{\\ell\\}\\), \\(a \\in \\agegroups\\), we have</p> \\[ \\totalforceofinfection = \\lambda^{(\\ell), \\text{local}}\\agetime + \\lambda^{(\\ell), \\text{visitors}}\\agetime + \\lambda^{(\\ell), \\text{residents traveling}}\\agetime. \\tag{T1} \\] <p>This can loosely can be interpreted as exposure intensity: the (weighted) proportion of the population that interacts with \\(\\ell,a\\) individuals that are infectious. </p> <p>The decompositions model the following phenomenon:</p> <ul> <li>\\(\\lambda^{(\\ell), \\text{local}}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(\\ell\\) (this contact occurs in location \\(\\ell\\)).</li> <li>\\(\\lambda^{(\\ell), \\text{visitors from } k}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\) but travel to location \\(\\ell\\) (this contact occurs in location \\(\\ell\\)).</li> <li>\\(\\lambda^{(\\ell), \\text{residents traveling to } k}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\), due to individuals who live in location \\(\\ell\\) traveling to location \\(k\\) (this contact occurs in location \\(k\\)).</li> </ul> <p>Note that we assume this exposure intensity is the same for a given age group regardless of risk group, so we do not have the \\(r\\)-subscript here.</p> <p>Specifically, we have</p> \\[\\begin{align*} \\lambda^{(\\ell), \\text{local}}\\agetime &amp;= \\psi_a \\left(1 - m_a \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok \\right) \\cdot \\sum \\limits_{a^\\prime \\in \\agegroups} \\phi\\locationell_{a,a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationell_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime} \\tag{T2} \\\\[1.5em] \\lambda^{(\\ell), \\text{visitors}}\\agetime &amp;= \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\underbrace{\\left(\\psi_a \\cdot \\propdaytravelktoell \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} m_{a^\\prime}(t) \\cdot \\phi\\locationell_{a, a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationk_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime}\\right)}_{\\text{Each summand: } \\lambda^{(\\ell), \\text{visitors from } k}\\agetime} \\tag{T3} \\\\[1.5em] \\lambda_{a,r}^{(\\ell), \\text{residents traveling}}(t) &amp;= \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}}  \\underbrace{\\left(\\psi_a \\cdot \\proptravelelltok  \\cdot m_a \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} \\phi\\locationell_{a, a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationk_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\tilde{N}^{(k)}_{a^\\prime, r^\\prime} (t)}\\right)}_{\\text{Each summand: } \\lambda\\agerisk^{(\\ell), \\text{residents traveling to } k}(t)} \\tag{T4} \\end{align*}\\] <p>where</p> \\[ \\texttt{I_weighted}\\locationell_{a^\\prime}(t) := \\sum_{r^\\prime \\in \\riskgroups} \\left[ISR\\locationell\\ageprimeriskprime(t) + ISH\\locationell\\ageprimeriskprime(t) + r_{IP} IP\\locationell\\ageprimeriskprime(t) + r_{IA} IA\\locationell\\ageprimeriskprime(t)\\right] \\tag{T5} \\] <p>and where</p> \\[\\begin{align*} \\effectiveNlocagerisktime &amp;= \\Nlocagerisk + m_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\propdaytravelktoell \\cdot (N^{(k)}_{a, r} - HR^{(k)}_{a,r}(t) - HD^{(k)}_{a,r}(t)) \\\\ &amp;\\quad\\quad\\quad - m_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok  \\cdot (N\\locagerisk - HR\\locationell_{a,r}(t) - HD\\locationell_{a,r}(t)) \\tag{T6} \\end{align*}\\] <p>is the effective population in location \\(\\ell \\in \\mathcal L\\) and age-risk group \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\) at time \\(t\\).</p>"},{"location":"math_flu_components/#contact-matrix","title":"Contact matrix","text":"<p>The contact matrix is defined as</p> <ul> <li>\\(\\phi_{a, a^\\prime}\\locationell(t)\\): the number of contacts that individuals in age group \\(a \\in \\agegroups\\) residing in location \\(\\ell \\in \\mathcal L\\) have with other individuals (regardless of location) in age group \\(a^\\prime \\in \\agegroups\\) on day \\(t\\).</li> </ul> <p>Let \\(\\phi^{(\\ell), \\text{total}}\\), \\(\\phi^{(\\ell), \\text{work}}\\), and \\(\\phi^{(\\ell), \\text{school}}\\) represent the total contact matrix, school contact matrix, and work contact matrix, respectively for subpopulation \\(\\ell\\).</p> <p>Then the contact matrix for the subpopulation at time \\(t\\) is $$ \\phi^{(\\ell)}(t) := \\phi^{(\\ell), \\text{total}} - (1 - d_{\\text{work}}(t)) \\phi^{(\\ell), \\text{work}} - (1 - d_{\\text{school}}(t)) \\phi^{(\\ell), \\text{school}} $$ where \\(d_{\\text{work}}(t)\\) is \\(1\\) if the real-world date corresponding to simulation time \\(t\\) is a work day and \\(0\\) otherwise, and \\(d_{\\text{school}}(t) \\in [0, 1]\\) is defined analogously for school days and represents the proportion of schools open on day \\(t\\).</p>"},{"location":"math_flu_components/#other-travel-parameters","title":"Other travel parameters","text":"<p>We have</p> <ul> <li>\\(\\psi_a \\in [0, 1]\\): relative susceptibility of individuals in age group \\(a \\in \\agegroups\\).</li> <li>\\(m_a\\): a positive scalar modifying travel intensity depending on age \\(a\\).</li> <li>\\(\\propdaytravelktoell\\): (on average) proportion of the day that a resident of \\(k\\) spends traveling to location \\(\\ell \\in \\mathcal L\\).</li> </ul> <p>Note that the arrows in \\(\\propdaytravelktoell\\) correspond to direction of travel (e.g. \\(k \\rightarrow \\ell\\) represents residents of location \\(k\\) traveling to location \\(\\ell\\)). The \\(\\propdaytravelktoell\\) values are calculated from mobility data, corresponding to</p> \\[\\begin{align*} \\bar{p}^{k \\rightarrow \\ell} &amp;= \\sum_{\\poiell} c^{\\poiell} \\cdot v^{k \\rightarrow \\poiell} \\tag{T7} \\\\[1.5em] \\propdaytravelktoell &amp;= \\frac{\\bar{p}^{k \\rightarrow \\ell}}{\\sum_{\\ell \\in \\mathcal L} \\bar{p}^{k \\rightarrow \\ell}} \\tag{T8} \\end{align*}\\] <p>where</p> <ul> <li>\\(c^{\\poiell}\\): average proportion of a day spent at \\(\\poiell\\).</li> <li>\\(v^{k \\rightarrow \\poiell}\\): average number of visits per day per resident of \\(k\\) to \\(\\poiell\\).</li> </ul> <p>Therefore the rows of the mobility matrix \\(p\\) sum to 1: \\(\\sum_{\\ell \\in \\mathcal L} \\propdaytravelktoell = 1\\).</p>"},{"location":"math_flu_components/#flu-model-discretized-stochastic-implementation","title":"Flu model: discretized stochastic implementation","text":"<p>To actually implement/simulate this compartmental model, we discretize the deterministic differential equations and treat transitions between compartments as stochastic to model uncertainty. We extend the notation from the deterministic differential equations to capture the stochastic elements.</p> <p>Let \\(\\boldsymbol{\\mathcal X}(t) = \\left\\{\\boldsymbol{S}(t), \\boldsymbol{E}(t), \\boldsymbol{IA}(t), \\boldsymbol{IP}(t), \\boldsymbol{ISR}(t), \\boldsymbol{ISH}(t), \\boldsymbol{HR}(t), \\boldsymbol{HD}(t), \\boldsymbol{R}(t), \\boldsymbol{D}(t), \\boldsymbol{M}(t), \\boldsymbol{MV}(t), q(t), \\boldsymbol{\\phi}(t), V\\locationell(t)\\right\\}\\) be the \"simulation state\" at time \\(t\\). \\(\\boldsymbol{\\mathcal X}(t)\\) is a set of matrices. </p> <p>Let \\(\\boldsymbol{\\Theta}\\) be the set of fixed parameters. </p> <p>Then given initial state \\(\\boldsymbol{\\mathcal X}_0 = \\boldsymbol{\\mathcal X}(0)\\), we can formulate our discretized stochastic implementation as</p> \\[ \\boldsymbol{\\mathcal X}(t + \\Delta t) = \\boldsymbol{\\mathcal X}(t) + f\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega; \\boldsymbol{\\Theta}\\right) \\quad \\text{for} \\quad t \\ge 0, \\] <p>where \\(f\\) is parametrized by \\(\\boldsymbol{\\Theta}\\), and depends on the step size of discretization \\(\\Delta t\\) and a sample path \\(\\omega\\). We assume that each sample path \\(\\omega\\) is realized from a random process that does not depend on \\(\\boldsymbol{\\mathcal X}(t)\\) or \\(\\Delta t\\) for each \\(t\\). When we are discussing a single model with a fixed set of parameters \\(\\boldsymbol{\\Theta}\\), we drop the \\(\\boldsymbol{\\Theta}\\) notation for simplicity.  </p> <p>Now we formulate how we implement discretized stochastic transitions. We assume that \\(q(t)\\), \\(\\boldsymbol{\\phi}(t)\\), and \\(V\\locationell(t)\\)  are updated deterministically according to some \"schedule.\"  </p> <p>We model stochastic transitions between compartments using \"transition variables.\" Transition variables correspond to incoming and outgoing flows of epidemiological compartments (see the compartment equations above). </p> <p>Below we formulate the discretized stochastic transitions. Note that the population-level immunity variables behave as aggregate epidemiological metrics. They are deterministic functions of the simulation state and transitions between compartments.</p> <p>IMPORTANT NOTE_: all \\(y\\) and \\(y^*\\)-variables depend on \\(\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). For notation simplicity, we define \\(\\simstate := \\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and write \\(y\\) and \\(y^*\\)-variables as functions of \\(\\simstate\\).</p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), and \\(r \\in \\riskgroups\\):</p> \\[\\begin{align} M_{a, r}\\locationell(t + \\Delta t) &amp;= M\\locationell\\agerisktime + \\frac{dM\\locationell\\agerisktime}{dt} \\cdot \\Delta t \\\\ MV_{a,r}\\locationell(t + \\Delta t) &amp;= MV\\agerisktime\\locationell + \\frac{dMV\\agerisktime\\locationell}{dt} \\cdot \\Delta t \\\\ S\\locagerisk(t + \\Delta t) &amp;= S_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} - \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} \\\\ E\\locagerisk(t + \\Delta t) &amp;= E_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} \\\\ IP\\locagerisk(t + \\Delta t) &amp;= IP\\locagerisktime + \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\tvarloc_{IP \\rightarrow ISR, a, r}(\\Xi_t)}_{\\text{$IP$ to $ISR$}} - \\underbrace{\\tvarloc_{IP \\rightarrow ISH, a, r}(\\Xi_t)}_{\\text{$IP$ to $ISH$}} \\\\ IA_{a, r}\\locationell(t + \\Delta t) &amp;= IA_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} - \\underbrace{\\tvarloc_{IA \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IA$ to $R$}} \\\\ ISR\\locagerisk(t + \\Delta t) &amp;= ISR_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{IP \\rightarrow ISR, a, r}(\\Xi_t)}_{\\text{$IP$ to $ISR$}} - \\underbrace{\\jointtvarloc_{ISR \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$ISR$ to $R$}} \\\\ ISH\\locagerisk(t + \\Delta t) &amp;= ISH_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{IP \\rightarrow ISH, a, r}(\\Xi_t)}_{\\text{$IP$ to $ISH$}} - \\underbrace{\\jointtvarloc_{ISH \\rightarrow HR, a, r}(\\Xi_t)}_{\\text{$ISH$ to $HR$}} - \\underbrace{\\jointtvarloc_{ISH \\rightarrow HD, a, r}(\\Xi_t)}_{\\text{$ISH$ to $HD$}} \\\\ HR\\locagerisk(t + \\Delta t) &amp;= HR_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{ISH \\rightarrow HR, a, r}(\\Xi_t)}_{\\text{$ISH$ to $HR$}} - \\underbrace{\\jointtvarloc_{HR\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$HR$ to $R$}} \\\\ HD\\locagerisk(t + \\Delta t) &amp;= HD_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{ISH \\rightarrow HD, a, r}(\\Xi_t)}_{\\text{$ISH$ to $HD$}} - \\underbrace{\\jointtvarloc_{HD\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$HD$ to $D$}} \\\\ R\\locagerisk(t + \\Delta t) &amp;= R_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{IA \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IA$ to $R$}} + \\underbrace{\\jointtvarloc_{ISR \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$ISR$ to $R$}} + \\underbrace{\\jointtvarloc_{HR\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$HR$ to $R$}} - \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} \\\\ D\\locagerisk(t + \\Delta t) &amp;= D_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{HD\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$HD$ to $D$}}.  \\end{align}\\] <p>IMPORTANT NOTE: the \"\\(*\\)\" superscript indicates that the transition variable has a joint distribution with another transition variable. In general, if a compartment has more than one outgoing transition variable, these transition variables must be modeled jointly. </p> <p>Consider the two transitions out of the infected symptomatic compartment, for example. Given that a patient is infected and symptomatic, exactly one outcome occurs: they recover (from home) or they go to the hospital. Since one and only one of these outcomes must occur, we must model these two transition variables jointly. Joint distribution derivation details are provided in the next section on transition types.</p> <p>Each transition variable depends on a \"base count\" and a \"rate\" (which both depend on the current state of the system). This decomposition is displayed in the table below. Note that these transitions are for a given location \\(\\ell \\in \\mathcal L\\).</p> Transition Transition variable Base count Rate \\(R\\) to \\(S\\) \\(\\tvarloc_{R \\rightarrow S, a, r}(\\simstate)\\) \\(R_{a, r}\\locationell(t)\\) \\(\\rateRtoS\\) \\(S\\) to \\(E\\) \\(\\tvarloc_{S \\rightarrow E, a, r}(\\simstate)\\) \\(S_{a, r}\\locationell(t)\\) \\(\\frac{\\beta(t) \\totalforceofinfection}{1 + \\LambdaIlocagerisktime}\\) \\(E\\) to \\(IP\\) \\(\\jointtvarloc_{E \\rightarrow IP, a, r}(\\simstate)\\) \\(E_{a, r}\\locationell(t)\\) \\(\\rateEtoI (1 - \\propIA)\\) \\(E\\) to \\(IA\\) \\(\\jointtvarloc_{E \\rightarrow IA, a, r}(\\simstate)\\) \\(E_{a, r}\\locationell(t)\\) \\(\\rateEtoI \\propIA\\) \\(IP\\) to \\(ISR\\) \\(\\tvarloc_{IP \\rightarrow ISR, a, r}(\\simstate)\\) \\(IP_{a, r}\\locationell(t)\\) \\(\\rateIPtoIS \\left(1-\\frac{\\pi^H_{a,r}}{1 + \\LambdaHlocagerisktime}\\right)\\) \\(IP\\) to \\(ISH\\) \\(\\tvarloc_{IP \\rightarrow ISH, a, r}(\\simstate)\\) \\(IP_{a, r}\\locationell(t)\\) \\(\\rateIPtoIS \\frac{\\pi^H_{a,r}}{1 + \\LambdaHlocagerisktime}\\) \\(ISR\\) to \\(R\\) \\(\\jointtvarloc_{ISR \\rightarrow R, a, r}(\\simstate)\\) \\(ISR_{a, r}\\locationell(t)\\) \\(\\gamma^{ISR\\rightarrow R}\\) \\(ISH\\) to \\(HR\\) \\(\\jointtvarloc_{ISH \\rightarrow HR, a, r}(\\simstate)\\) \\(ISH_{a, r}\\locationell(t)\\) \\(\\rateISHtoH \\left(1-\\frac{\\pi^D_{a,r}}{1 + \\LambdaDlocagerisktime}\\right)\\) \\(ISH\\) to \\(HD\\) \\(\\jointtvarloc_{ISH \\rightarrow HD, a, r}(\\simstate)\\) \\(ISH_{a, r}\\locationell(t)\\) \\(\\rateISHtoH \\frac{\\pi^D_{a,r}}{1 + \\LambdaDlocagerisktime}\\) \\(IA\\) to \\(R\\) \\(\\tvarloc_{IA \\rightarrow R, a, r}(\\simstate)\\) \\(IA_{a, r}\\locationell(t)\\) \\(\\rateIAtoR\\) \\(HR\\) to \\(R\\) \\(\\jointtvarloc_{HR \\rightarrow R, a, r}(\\simstate)\\) \\(HR_{a, r}\\locationell(t)\\) \\(\\rateHRtoR\\) \\(HD\\) to \\(D\\) \\(\\jointtvarloc_{HD \\rightarrow D, a, r}(\\simstate)\\) \\(HD_{a, r}\\locationell(t)\\) \\(\\rateHDtoD\\) <p>The base count and rate of a transition variable parameterize the distribution that defines its realization. </p> <p>See this page for mathematical formulations of marginal and joint stochastic transitions between compartments. </p>"},{"location":"math_flu_components/#general-model-discretized-stochastic-implementation","title":"General model: discretized stochastic implementation","text":"<p>We make the important note that the flu model's discretized stochastic implementation can be generalized to models with different structures. More broadly, we let \\(\\boldsymbol{\\mathcal C}(t)\\) be a model's set of epidemiological compartments, \\(\\boldsymbol{\\mathcal M}(t)\\) its set of aggregate epidemiological metrics, and \\(\\boldsymbol{S (t)}\\) its set of schedule-dependent (time-dependent) deterministic values. Then the above formulation still holds.</p> <p>In fact, in our code, we model \\(\\boldsymbol{\\mathcal C(t)}\\) using an <code>Compartment</code> class, \\(\\boldsymbol{\\mathcal M}(t)\\) using an <code>EpiMetric</code> class, and \\(\\boldsymbol{\\mathcal S(t)}\\) using a <code>Schedule</code> class. We handle stochastic transitions using <code>TransitionVariable</code> and <code>TransitionVariableGroup</code> classes. These classes form some of the building blocks of the base model code. </p> <p>Updated 12/12/2025. Documentation written by LP and updated by R\u00e9my Pasco, mathematical notation by LP (advised by Lauren Meyers and Dave Morton, edited by Susan Ptak, Meyers Lab, and Shiyuan Liang), travel model conceptualized by R\u00e9my and Susan Ptak, immunity formulation by Anass Bouchnita.</p>"},{"location":"math_transitions/","title":"Stochastic Transitions","text":"<p>Written by LP, updated 01/30/2025 </p>"},{"location":"math_transitions/#marginal-transition-types","title":"Marginal transition types","text":"<p>Our codebase currently implements six types of transitions: three stochastic transitions and three deterministic counterparts.</p> <p>First we consider marginal (not joint) transition variables. For the following table, consider \\(y_{\\texttt{C}\\rightarrow\\texttt{C}^\\prime, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) from compartment \\(\\texttt{C}\\) to \\(\\texttt{C}^\\prime\\). Let \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t)\\) be its current value of its base count and \\(\\texttt{r} = \\texttt{r}_{a, \\ell}(t)\\) be its current value of its rate. Then depending on its transition type, its distribution (or deterministic value) is given below.</p> <p>Note that \\(\\alpha\\) is a function that converts a \"rate\" into a probability. It is given by: $$ \\alpha(\\texttt{r}, \\Delta t) = 1 - \\exp(-\\texttt{r} \\cdot \\Delta t) $$ and corresponds to the probability that a Poisson process with rate \\(\\texttt{r}\\) produces at least one event in an interval of length \\(\\Delta t\\). </p> <p>The following table provides the mathematical distribution or deterministic output for each transition type. </p> Output Binomial \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\alpha(\\texttt{r}, \\Delta t)\\right)\\) Binomial  Taylor Approx \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\texttt{r} \\cdot \\Delta t\\right)\\) Poisson \\(\\sim \\text{Poisson}\\left(\\lambda = \\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\right)\\) Binomial Deterministic \\(\\texttt{b} \\cdot \\alpha(\\texttt{r}, \\Delta t)\\) Binomial Taylor Approx Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\) Poisson Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\)"},{"location":"math_transitions/#joint-transition-types","title":"Joint transition types","text":"<p>Here we describe joint transition variables. For the following table, consider a compartment \\(\\texttt{C}_0\\) with two outgoing compartments, \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). We describe \\(2\\) transition variables: \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). They respectively correspond to the number of people that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_1\\) and the number that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_2\\) at a given simulate state. Let their rates be \\(\\texttt{r}_1\\) and \\(\\texttt{r}_2\\) respectively.  </p> <p>We can also write the number that remain in \\(\\texttt{C}_0\\) explicitly as  \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) = \\texttt{C}_{0, a, \\ell}(t) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). Note that this quantity is purely for parametrizing multinomial distributions (which needs to have its probability parameters sum to \\(1\\)) and does not need to be literally modeled as a transition variable either mathematically or in code. </p> <p>Let \\(\\alpha\\) be defined as in the previous section on marginal transition types.</p> <p>The following table gives the parameters for multinomial transitions when \\(\\texttt{C}_0\\) has two outgoing compartments \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). The values \\([y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)]\\) are sampled jointly, using \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t) = \\texttt{C}_{0, a, \\ell}(t)\\) as the \"number of trials\" parameter \\(n\\) in a multinomial distribution.</p> Transition  Variable Group (Jointly Sampled) Multinomial Probability Parameter Multinomial with Taylor Approx Probability Parameter \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_1}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_1 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_2}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_2 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(1 - \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(1 - (\\texttt{r}_1 + \\texttt{r}_2) \\Delta t\\)"},{"location":"math_transitions/#important-notes","title":"Important notes","text":"<ul> <li> <p>The transition variable group table formulas generalize to an arbitrary number of outgoing compartments -- however, this is not shown here.</p> </li> <li> <p>Note that Poisson is not included in the above table. Recall the splitting property of Poisson processes. If the total outflow (going to either compartment, \\(\\texttt{C}_1\\) or \\(\\texttt{C}_2\\)) is Poisson, we can split the process into two independent Poisson processes. So joint sampling is not actually needed. </p> </li> <li> <p>In contrast, the binomial distribution does not have such a splitting property. If the total outflow is binomial with parameters \\(n\\) and \\(p\\), then we cannot use a similar Poisson splitting technique to create two independent binomial random variables with the same number of trial parameters \\(n\\). Thus, joint sampling is needed. </p> </li> <li> <p>An advantage of binomial/multinomial transition variables (with joint sampling when there are multiple outflows from a compartment) is that we cannot have more people leaving the origin compartment than are actually in the compartment. We set the \"number of trials\" parameter in the multinomial distribution to be the current number of people in the compartment. This is NOT the case for Poisson transition variables, which are unbounded! Thus, we recommend using binomial/multinomial transition types.</p> </li> <li> <p>See <code>update_compartments</code> method in <code>clt_toolkit / base_components.py / MetapopModel</code> for details on how we adjust compartment values for deterministic implementations. Note that the stochastic transitions have realizations that are always integer, and due to multinomial sampling (see previous point), the compartments are always nonnegative. With any of our deterministic transitions, our transitions are not guaranteed to be integer, and our compartments are not guaranteed to be nonnegative. With deterministic transitions, we apply a \"softplus\" function (a smooth approximation to the ReLU function) to all compartment values of all compartments. This makes compartments nonnegative. </p> </li> <li> <p>For the binomial/multinomial Taylor approximation transition type, if the simulation discretization parameter \\(\\Delta t\\) is too large, then it is possible for the \"probability parameter\" to be nonsensical. For example, in the table above, it is possible for \\(r_1 \\Delta t &gt; 1\\) or \\(r_2 \\Delta t &gt; 1\\) if \\(\\Delta t\\) is not sufficiently small. Similarly, it is possible for \\(1 - (r_1 + r_2) \\Delta t &lt; 0\\) if \\(\\Delta t\\) is not sufficiently small. Thus, we cannot use these values as probabilities input for the binomial distribution. As a result, we recommend using the binomial transition type with no Taylor approximation. This transition type converts rates into probabilities that are always between \\([0,1]\\) and thus always well-defined to be input as a probability parameter in a binomial distribution.</p> </li> </ul>"},{"location":"python_resources/","title":"Python Resources for Modelers","text":"<p>Written by LP, updated 08/25/2025 (work in progress) </p> <p>Here we provide a list of fundamental concepts for epidemiologists to know to responsibly create, collaborate on, and interact with responsible and reproducible Python code. We have outlined this somewhat like a syllabus for self-directed learning, with links to resources to get started. The reader should make sure they understand all key concepts in the checklist, and read more otherwise. </p> <p>Note: we particularly like Real Python, which has many free and thorough tutorials on various Python subjects!</p>"},{"location":"python_resources/#coding-correctly","title":"Coding correctly","text":"<p>Clean code matters for academic research with high standards.</p> <p>Recommended textbooks (PDF links are unaffiliated with epi-ENGAGE):</p> <ul> <li>***MUST READ: \"The Art of Readable Code\" by Boswell &amp; Foucher</li> <li>\"A Philosophy of Software Design\" by Ousterhout</li> <li>\"Refactoring: Improving the Design of Existing Code\" by Fowler &amp; Beck</li> <li>\"Clean Code: A Handbook of Agile Software Craftsmanship\" by Martin</li> </ul> <p>Key concepts</p> <ul> <li>\"The Fundamental Theorem of Readability: Code should be written to minimize the time it would take for someone else to understand it.\" (Boswell &amp; Foucher)</li> <li>Function and variable names should be specific and precise -- ChatGPT is great at helping brainstorm names!</li> <li>DOT -- DO ONE THING -- \"Functions should do one thing. They should do it well. They should do it only.\" And \"functions should do something, or answer something, but not both.\" (Martin) -- nice articles here and here.</li> <li>DRY -- DON'T REPEAT YOURSELF (Hunt &amp; Thomas) -- example resources here and here.</li> <li>Tactical instead of strategic programming leads to technical debt -- \"Complexity comes from an accumulation of dependencies and obscurities. As complexity increases, it leads to change amplification, a high cognitive load, and unknown unknowns.\" (Ousterhout) </li> </ul> <p>Advanced concepts</p> <ul> <li>For classes -- \"Single Responsibility Principle\" (Martin) -- example resources here and here.</li> </ul>"},{"location":"python_resources/#test-test-test","title":"Test, test, test!","text":"<p>Key concepts</p> <ul> <li>Any time a user changes code or adds code, they should add new tests and also make sure that all the old tests still pass. </li> <li>Unit testing is critical to ensuring code behaves as intended and ensuring that changes/updates do not add new bugs or break existing functionality. If we haven't tested it, we shouldn't trust it. We should prove our code works! Check out this great MIT lecture on testing here.</li> <li>Testing should have good coverage and handle different edge cases -- bugs often occur \"on the boundaries\" of inputs. </li> <li>The CLT Base Model code uses <code>pytest</code> for easy management of unit testing -- here's an in-depth tutorial. </li> <li>We must also implement higher-level tests such as integration tests and acceptance tests, to make sure the whole shebang works.</li> <li>One crucial reason to write modular code (and functions that do one thing only) is to allow for testing of specific modules and functions (Boswell &amp; Foucher). If the code is not easy to test, we cannot easily guarantee its quality.</li> </ul> <p>Bonus articles on testing</p> <ul> <li>Check out these nice articles on unit testing here and here.  And here is a nice overview of TDD -- Test-Driven Development (Martin).</li> </ul>"},{"location":"python_resources/#python-modules-and-imports-ides-and-running-python-scripts","title":"Python modules and imports, IDEs, and running Python scripts","text":"<p>Key concepts</p> <ul> <li>Jupyter notebooks are for exploration, NOT for collaborative software development. Nature wrote a blog post warning about Jupyter notebooks: \"computational notebooks can also be confusing and foster poor coding practices. And they are difficult to share, collaborate on and reproduce. A 2019 study found that just 24% of 863,878 publicly available Jupyter notebooks on GitHub could be successfully re-executed, and only 4% produced the same results\" -- blog post link here and conference paper here. </li> <li>As programs grow in size, they should be split into smaller files and organized -- modules and importing are key here. Here's a quick tutorial and a more in-depth tutorial.</li> <li>Interactive Developer Environments (IDEs) are ideal for working with Python modules. We recommend Pycharm -- the community edition here is free to download.</li> <li>Python can be run in many different ways -- users should understand the difference between running a script in an IDE Console and from the command line -- here's a guide.</li> <li>We recommend pip or conda for Python package management. There can sometimes be some issues with mixing pip and conda, so it may be helpful to consistently only use one or the other. </li> <li>Users should be comfortable reading API documentation such as the CLT Base Model Code's references or numpy's references -- there is no need to try to memorize syntax. Users should be comfortable parsing the technical details of classes and methods, customizing default arguments, and playtesting parts of the package for themselves. </li> </ul> <p>More reading</p> <ul> <li>Jupyter notebooks have issues with hidden states -- read more here.</li> </ul>"},{"location":"python_resources/#documentation-and-version-control","title":"Documentation and version control","text":"<p>Key concepts</p> <ul> <li> <p>Users should be familiar with git. We strongly recommend this nice guide on github collaboration here.</p> <ul> <li>Specifically, users should know the following concepts in git: cloning a repo, local and remote repos, committing and pushing, pull requests, pulling, merging.</li> </ul> </li> <li> <p>Collaborators should never push to main -- they should create a pull request (after adding tests and checking all tests) to request the main branch incorporate any new changes.</p> </li> <li> <p>Users should STOP the common practice of saving versions like <code>simulation_v3.2_final_final_01302025</code> -- this is horrible for many reasons. Users should instead use git version control and intentional git commit messages to keep track of their code versions.</p> </li> <li> <p>Users should add <code>.txt</code> and <code>.md</code> files documenting any mathematical parameters to their repo and make this a part of their version control setup. This way, users can keep track of WHY and WHEN certain parameter values were changed. </p> </li> <li> <p>The CLT Base Model Code documentation on this website is generated using <code>mkdocs</code>, and automatically populates code references hosted on this website from the code. The code docstrings must follow a specific format, outlined here.</p> </li> <li>Users should always write proper function signatures in their code -- specifying data input and return types is very important. This article here is a starting point to learn more.  </li> </ul>"},{"location":"python_resources/#other-important-points","title":"Other important points...","text":"<p>Key concepts</p> <ul> <li>The CLT Base Model code uses object-oriented programming (OOP), which may be new to some modelers. The coding structure is similar to StarSim and TACC's Pandemic Simulator -- it is a tried and tested strategy. We strongly recommend this tutorial for those new to OOP.<ul> <li>Specifically, users should know the following concepts: inheritance, attributes, abstract base classes, abstract methods.</li> </ul> </li> <li>We need to be responsible with random number generation. Please, stop using <code>np.random.seed</code>! Use generators instead! Here is a superb article outlining some dangers with misusing <code>numpy</code> random number generation, with links to the relevant numpy documentation. </li> <li>For-loops are horrible for efficiency and vectorized operations are better. Often, when possible, mathematical computations should be written in matrix multiplication form instead of for-loops. Here is a tutorial on the essentials of <code>numpy</code> and vectorized operations on <code>numpy</code> arrays.</li> <li>The <code>dataclasses</code> module makes storing data very easy -- here's a quick tutorial.</li> <li>Users should understand interfaces and duck typing in Python -- here's a short overview.</li> </ul>"}]}